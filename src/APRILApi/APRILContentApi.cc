/// \file APRILContentApi.cc
/*
 *
 * APRILContentApi.cc source template automatically generated by a class generator
 * Creation date : mar. avr. 28 2015
 *
 * This file is part of APRILContent libraries.
 * 
 * APRILContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * APRILContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with APRILContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "APRILApi/APRILContentApi.h"

#include "APRILObjects/CaloHit.h"
#include "APRILObjects/Connector.h"
#include "APRILObjects/APRILMetaData.h"

#include "Api/PandoraContentApi.h"

april_content::ClusterFactory APRILContentApi::m_clusterFactory;

pandora::StatusCode APRILContentApi::AlterMetadata(const pandora::Algorithm &algorithm, const april_content::CaloHit *const pCaloHit, const APRILContentApi::CaloHitMetadata &caloHitMetadata)
{
  // alter pandora calo hit meta data
  const pandora::CaloHit *const pPandoraCaloHit(pCaloHit);
  const PandoraContentApi::CaloHit::Metadata pandoraCaloHitMetadata(caloHitMetadata);

  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::CaloHit::AlterMetadata(algorithm, pPandoraCaloHit, pandoraCaloHitMetadata));

  if(caloHitMetadata.m_surroundingEnergy.IsInitialized())
    APRILContentApi::Modifiable(pCaloHit)->m_surroundingEnergy = caloHitMetadata.m_surroundingEnergy.Get();

  if(caloHitMetadata.m_density.IsInitialized())
    APRILContentApi::Modifiable(pCaloHit)->m_density = caloHitMetadata.m_density.Get();

  return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool APRILContentApi::IsConnected(const april_content::CaloHit *const pCaloHit1, const april_content::CaloHit *const pCaloHit2)
{
  return pCaloHit1->m_pCaloHitMetaData->IsConnected(pCaloHit2);
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool APRILContentApi::IsConnected(const april_content::CaloHit *const pCaloHit1, const april_content::CaloHit *const pCaloHit2, april_content::ConnectorDirection direction)
{
  return pCaloHit1->m_pCaloHitMetaData->IsConnected(pCaloHit2, direction);
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode APRILContentApi::FindConnector(const april_content::CaloHit *const pCaloHit1, const april_content::CaloHit *const pCaloHit2, const april_content::Connector *&pConnector)
{
  return pCaloHit1->m_pCaloHitMetaData->FindConnector(pCaloHit2, pConnector);
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode APRILContentApi::FindConnector(const april_content::CaloHit *const pCaloHit1, const april_content::CaloHit *const pCaloHit2, april_content::ConnectorDirection direction,
    const april_content::Connector *&pConnector)
{
  return pCaloHit1->m_pCaloHitMetaData->FindConnector(pCaloHit2, direction, pConnector);
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool APRILContentApi::HasAnyConnection(const april_content::CaloHit *const pCaloHit)
{
  return pCaloHit->m_pCaloHitMetaData->HasAnyConnection();
}

//------------------------------------------------------------------------------------------------------------------------------------------

const april_content::ConnectorList &APRILContentApi::GetConnectorList(const april_content::CaloHit *const pCaloHit)
{
  return pCaloHit->m_pCaloHitMetaData->GetConnectorList();
}

//------------------------------------------------------------------------------------------------------------------------------------------

const april_content::ConnectorList &APRILContentApi::GetConnectorList(const april_content::CaloHit *const pCaloHit, april_content::ConnectorDirection direction)
{
  return pCaloHit->m_pCaloHitMetaData->GetConnectorList(direction);
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool APRILContentApi::IsSeed(const april_content::CaloHit *const pCaloHit)
{
  return pCaloHit->m_pCaloHitMetaData->IsSeed();
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool APRILContentApi::IsLeaf(const april_content::CaloHit *const pCaloHit)
{
  return pCaloHit->m_pCaloHitMetaData->IsLeaf();
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode APRILContentApi::Connect(const april_content::CaloHit *const pCaloHit1, const april_content::CaloHit *const pCaloHit2, april_content::ConnectorDirection direction,
    float referenceLength, unsigned int creationStage)
{
  const april_content::Connector *pConnector = NULL;
  return APRILContentApi::Connect(pCaloHit1, pCaloHit2, direction, pConnector, referenceLength, creationStage);
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode APRILContentApi::Connect(const april_content::CaloHit *const pCaloHit1, const april_content::CaloHit *const pCaloHit2, april_content::ConnectorDirection direction,
    const april_content::Connector *&pConnector, float referenceLength, unsigned int creationStage)
{
  pConnector = NULL;

  april_content::CaloHit *const pCaloHitFrom = direction == april_content::BACKWARD_DIRECTION ? APRILContentApi::Modifiable(pCaloHit2) : APRILContentApi::Modifiable(pCaloHit1);
  april_content::CaloHit *const pCaloHitTo = direction == april_content::BACKWARD_DIRECTION ? APRILContentApi::Modifiable(pCaloHit1) : APRILContentApi::Modifiable(pCaloHit2);

  pConnector = new april_content::Connector(pCaloHitFrom, pCaloHitTo, referenceLength, creationStage);

  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pCaloHitFrom->m_pCaloHitMetaData->AddConnector(pConnector, april_content::FORWARD_DIRECTION));
  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pCaloHitTo->m_pCaloHitMetaData->AddConnector(pConnector, april_content::BACKWARD_DIRECTION));

  return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode APRILContentApi::RemoveConnectionBetween(const april_content::CaloHit *const pCaloHit1, const april_content::CaloHit *const pCaloHit2)
{
  if(NULL == pCaloHit1 || NULL == pCaloHit2)
    return pandora::STATUS_CODE_INVALID_PARAMETER;

  const april_content::Connector *pConnector = NULL;
  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pCaloHit1->m_pCaloHitMetaData->FindConnector(pCaloHit2, pConnector));

  return APRILContentApi::RemoveAndDeleteConnector(pConnector);
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode APRILContentApi::RemoveConnector(const april_content::Connector *const pConnector)
{
  if(NULL == pConnector)
    return pandora::STATUS_CODE_INVALID_PARAMETER;

  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, APRILContentApi::Modifiable(pConnector->GetFrom())->m_pCaloHitMetaData->RemoveConnector(pConnector));
  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, APRILContentApi::Modifiable(pConnector->GetTo())->m_pCaloHitMetaData->RemoveConnector(pConnector));

  return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode APRILContentApi::RemoveAndDeleteConnector(const april_content::Connector *const pConnector)
{
  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, APRILContentApi::RemoveConnector(pConnector));
  delete APRILContentApi::Modifiable(pConnector);

  return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode APRILContentApi::RemoveAndDeleteAllConnections(const april_content::CaloHit *const pCaloHit)
{
  april_content::ConnectorList backwardConnectorList(pCaloHit->m_pCaloHitMetaData->GetConnectorList(april_content::BACKWARD_DIRECTION));
  april_content::ConnectorList forwardConnectorList(pCaloHit->m_pCaloHitMetaData->GetConnectorList(april_content::FORWARD_DIRECTION));

  for(april_content::ConnectorList::const_iterator iter = backwardConnectorList.begin(), endIter = backwardConnectorList.end() ;
      endIter != iter ; ++iter)
  {
    const april_content::Connector *const pConnector = *iter;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, APRILContentApi::RemoveAndDeleteConnector(pConnector));
  }

  for(april_content::ConnectorList::const_iterator iter = forwardConnectorList.begin(), endIter = forwardConnectorList.end() ;
      endIter != iter ; ++iter)
  {
    const april_content::Connector *const pConnector = *iter;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, APRILContentApi::RemoveAndDeleteConnector(pConnector));
  }

  return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode APRILContentApi::Tag(const april_content::CaloHit *const pCaloHit, april_content::HitTag tag, bool value)
{
  APRILContentApi::Modifiable(pCaloHit)->m_hitTagMap.set(tag, value);
  return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool APRILContentApi::IsTagged(const april_content::CaloHit *const pCaloHit, april_content::HitTag tag)
{
  return pCaloHit->m_hitTagMap.test(tag);
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode APRILContentApi::ResetTags(const april_content::CaloHit *const pCaloHit)
{
  if(NULL == pCaloHit)
    return pandora::STATUS_CODE_INVALID_PARAMETER;

  APRILContentApi::Modifiable(pCaloHit)->m_hitTagMap.reset();

  return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode APRILContentApi::InitializeReclustering(const pandora::Algorithm &algorithm, const pandora::TrackList &inputTrackList,
    const pandora::ClusterList &inputClusterList, std::string &originalClustersListName)
{
  // Initialize re-clustering within pandora
  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::InitializeReclustering(algorithm, inputTrackList, inputClusterList, originalClustersListName));

  // Current calo hit list here is the one for re-clustering
  // Get it, save and create new meta data for each
  const pandora::CaloHitList *pCaloHitList = NULL;
  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(algorithm, pCaloHitList));

  for(pandora::CaloHitList::const_iterator iter = pCaloHitList->begin(), endIter = pCaloHitList->end() ;
      endIter != iter ; ++iter)
  {
    const april_content::CaloHit *const pCaloHit = dynamic_cast<const april_content::CaloHit *const>(*iter);

    if(NULL == pCaloHit)
      return pandora::STATUS_CODE_FAILURE;

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, APRILContentApi::Modifiable(pCaloHit)->SaveReclusterMetaData(originalClustersListName));
  }

  return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode APRILContentApi::RunReclusteringAlgorithm(const pandora::Algorithm &algorithm, const std::string &clusteringAlgorithmName,
    const pandora::ClusterList *&pNewClusterList, std::string &newClusterListName)
{
  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::RunClusteringAlgorithm(algorithm, clusteringAlgorithmName, pNewClusterList, newClusterListName));

  return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode APRILContentApi::PostRunReclusteringAlgorithm(const pandora::Algorithm &algorithm, const std::string &clusterListName)
{
  // Get the current re-clustering calo hit list
  // Save meta data for each calo hit
  const pandora::CaloHitList *pCaloHitList = NULL;
  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(algorithm, pCaloHitList));

  for(pandora::CaloHitList::const_iterator iter = pCaloHitList->begin(), endIter = pCaloHitList->end() ;
      endIter != iter ; ++iter)
  {
    const april_content::CaloHit *const pCaloHit = dynamic_cast<const april_content::CaloHit *const>(*iter);

    if(NULL == pCaloHit)
      return pandora::STATUS_CODE_FAILURE;

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, APRILContentApi::Modifiable(pCaloHit)->SaveReclusterMetaData(clusterListName));
  }

  return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode APRILContentApi::EndReclustering(const pandora::Algorithm &algorithm, const std::string &selectedClusterListName)
{
  const pandora::CaloHitList *pCaloHitList = NULL;
  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(algorithm, pCaloHitList));

  for(pandora::CaloHitList::const_iterator iter = pCaloHitList->begin(), endIter = pCaloHitList->end() ;
      endIter != iter ; ++iter)
  {
    const april_content::CaloHit *const pCaloHit = dynamic_cast<const april_content::CaloHit *const>(*iter);

    if(NULL == pCaloHit)
      return pandora::STATUS_CODE_FAILURE;

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, APRILContentApi::Modifiable(pCaloHit)->EndReclustering(selectedClusterListName));
  }

  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::EndReclustering(algorithm, selectedClusterListName));

  return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode APRILContentApi::Create(const pandora::Algorithm &algorithm, 
		PandoraContentApi::Cluster::Parameters clusterParameters, const pandora::Cluster *&pCluster)
{
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::Cluster::Create(algorithm, clusterParameters, pCluster));

	pandora::CaloHitList& caloHitList(clusterParameters.m_caloHitList);

	for(auto& caloHit : caloHitList)
	{
        const april_content::CaloHit *const pAPRILCaloHit = dynamic_cast<const april_content::CaloHit *const>(caloHit);
		Modifiable(pAPRILCaloHit)->SetMother(pCluster);
	}

    return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------
pandora::StatusCode APRILContentApi::CreateAPRILCluster(const pandora::Algorithm &algorithm, 
		PandoraContentApi::Cluster::Parameters clusterParameters, const pandora::Cluster *&pCluster)
{
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::Cluster::Create(algorithm, clusterParameters, pCluster, m_clusterFactory));

	pandora::CaloHitList& caloHitList(clusterParameters.m_caloHitList);

	for(auto& caloHit : caloHitList)
	{
        const april_content::CaloHit *const pAPRILCaloHit = dynamic_cast<const april_content::CaloHit *const>(caloHit);
		Modifiable(pAPRILCaloHit)->SetMother(pCluster);
	}

    return pandora::STATUS_CODE_SUCCESS;

}
            
//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode APRILContentApi::RemoveFromCluster(const pandora::Algorithm &algorithm, 
		const pandora::Cluster *const pCluster, const pandora::CaloHit *const pCaloHit)
{
    const april_content::CaloHit *const pAPRILCaloHit = dynamic_cast<const april_content::CaloHit *const>(pCaloHit);
	Modifiable(pAPRILCaloHit)->SetMother(nullptr);

	return PandoraContentApi::RemoveFromCluster(algorithm, pCluster, pCaloHit);
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode APRILContentApi::MergeAndDeleteClusters(const pandora::Algorithm &algorithm, 
		const pandora::Cluster *const pClusterToEnlarge, const pandora::Cluster *pClusterToDelete)
{
	pandora::CaloHitList origClusterHits;
    pClusterToEnlarge->GetOrderedCaloHitList().FillCaloHitList(origClusterHits);
	pandora::CaloHitList origIsoCaloHitList = pClusterToEnlarge->GetIsolatedCaloHitList();
	origClusterHits.insert(origClusterHits.begin(), origIsoCaloHitList.begin(), origIsoCaloHitList.end());

	pandora::CaloHitList clusterHits;
    pClusterToDelete->GetOrderedCaloHitList().FillCaloHitList(clusterHits);
	pandora::CaloHitList isoCaloHitList = pClusterToDelete->GetIsolatedCaloHitList();
	clusterHits.insert(clusterHits.begin(), isoCaloHitList.begin(), isoCaloHitList.end());

	origClusterHits.insert(origClusterHits.begin(), clusterHits.begin(), clusterHits.end());

	for(auto& caloHit : origClusterHits)
	{
        const april_content::CaloHit *const pAPRILCaloHit = dynamic_cast<const april_content::CaloHit *const>(caloHit);
		Modifiable(pAPRILCaloHit)->SetMother(pClusterToEnlarge);
	}

	return PandoraContentApi::MergeAndDeleteClusters(algorithm, pClusterToEnlarge, pClusterToDelete);
}
        
//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode APRILContentApi::AddToCluster(const pandora::Algorithm &algorithm, 
		const pandora::Cluster *const pCluster, const pandora::CaloHitList *const pCaloHitList)
{
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::AddToCluster(algorithm, pCluster, pCaloHitList));

	for(auto& caloHit : *pCaloHitList)
	{
        const april_content::CaloHit *const pAPRILCaloHit = dynamic_cast<const april_content::CaloHit *const>(caloHit);
		Modifiable(pAPRILCaloHit)->SetMother(pCluster);
	}

    return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

template <typename T>
T *APRILContentApi::Modifiable(const T *const pT)
{
  return const_cast<T*>(pT);
}

//------------------------------------------------------------------------------------------------------------------------------------------


template april_content::APRILCluster *APRILContentApi::Modifiable(const april_content::APRILCluster *const);

template april_content::CaloHit   *APRILContentApi::Modifiable(const april_content::CaloHit   *const);
template april_content::Connector *APRILContentApi::Modifiable(const april_content::Connector *const);

