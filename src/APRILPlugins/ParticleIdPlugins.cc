/// \file ParticleIdPlugins.cc
/*
 *
 * ParticleIdPlugins.cc source template automatically generated by a class generator
 * Creation date : lun. oct. 17 2016
 *
 * This file is part of APRILContent libraries.
 * 
 * APRILContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * APRILContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with APRILContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "APRILPlugins/ParticleIdPlugins.h"

#include "Pandora/AlgorithmHeaders.h"
#include "APRILObjects/CaloHit.h"
#include "APRILHelpers/ClusterHelper.h"
#include "APRILHelpers/GeometryHelper.h"
#include "APRILHelpers/HistogramHelper.h"

namespace april_content
{
  ParticleIdHelper::StartingLayerSettings::StartingLayerSettings() :
        m_maxForwardPseudoLayer(3),
        m_minPseudoLayerNHits(4),
        m_minFitHitDistanceFine(50.f),
        m_minFitHitDistanceCoarse(100.f),
        m_minNInteractingLayers(2),
        m_lowEnergyClusterCut(4.f)
  {
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ParticleIdHelper::GetStartingPseudoLayer(const pandora::Pandora &pandora, const pandora::Cluster *const pCluster, const ParticleIdHelper::StartingLayerSettings &settings, unsigned int &startingPseudoLayer)
  {
    startingPseudoLayer = std::numeric_limits<unsigned int>::max();

    if(pCluster->GetNCaloHits() == 0)
      return pandora::STATUS_CODE_FAILURE;

    pandora::CaloHitList clusterCaloHitList, nonIsolatedCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);
    pandora::ClusterFitPointList clusterFitPointList;
    unsigned int innerPseudoLayer(std::numeric_limits<unsigned int>::max());

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin(), endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit(*iter);

      if(pCaloHit->IsIsolated())
        continue;

      nonIsolatedCaloHitList.push_back(pCaloHit);
      clusterFitPointList.push_back(pandora::ClusterFitPoint(pCaloHit));

      if(pCaloHit->GetPseudoLayer() < innerPseudoLayer)
        innerPseudoLayer = pCaloHit->GetPseudoLayer();
    }

    if(clusterFitPointList.empty())
    {
//      std::cout << "ParticleIdHelper::GetStartingPseudoLayer: non isolated hit list empty " << std::endl;
      return pandora::STATUS_CODE_FAILURE;
    }

    bool lowEnergyEmCluster(pCluster->GetElectromagneticEnergy() < settings.m_lowEnergyClusterCut.Get()
        && !ClusterHelper::ContainsHitType(pCluster, pandora::HCAL)
    && pCluster->GetAssociatedTrackList().empty());

    if(lowEnergyEmCluster)
    {
      startingPseudoLayer = innerPseudoLayer;
//      std::cout << "ParticleIdHelper::GetStartingPseudoLayer: (low) starting pseudo layer = " << startingPseudoLayer << std::endl;
      return pandora::STATUS_CODE_SUCCESS;
    }

    const pandora::OrderedCaloHitList &orderedCaloHitList(pCluster->GetOrderedCaloHitList());

    pandora::CartesianVector centroid(0.f, 0.f, 0.f);
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::GetCentroid(pCluster, centroid));

    pandora::ClusterFitResult fitResult;

	try
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::ClusterFitHelper::FitPoints(clusterFitPointList, fitResult));
	}
    catch(const pandora::StatusCodeException &exception)
	{
	}

    if(!fitResult.IsFitSuccessful())
    {
      std::cout << "ParticleIdHelper::GetStartingPseudoLayer: invalid fit" << std::endl;
      return pandora::STATUS_CODE_FAILURE;
    }

    bool chargedCluster(pCluster->GetAssociatedTrackList().size() == 1);
    pandora::Helix *pHelix(NULL);
    const float bField(pandora.GetPlugins()->GetBFieldPlugin()->GetBField(pandora::CartesianVector(0.f, 0.f, 0.f)));

    if(chargedCluster)
    {
      const pandora::Track *const pTrack(*pCluster->GetAssociatedTrackList().begin());
      const pandora::CartesianVector trackMomentum(pTrack->GetTrackStateAtCalorimeter().GetMomentum());
      const pandora::CartesianVector trackProjection(pTrack->GetTrackStateAtCalorimeter().GetPosition());
      const int trackCharge(pTrack->GetCharge());

      pHelix = new pandora::Helix(trackProjection, trackMomentum, trackCharge, bField);
    }

    const pandora::CartesianVector clusterDirection(fitResult.GetDirection());
    bool startingLayerFound(false);
    const pandora::GeometryManager *const pGeometryManager(pandora.GetGeometry());

    try
    {
      // walk along the ordered calo hit list and find the shower start layer
      for(pandora::OrderedCaloHitList::const_iterator layerIter = orderedCaloHitList.begin(), layerEndIter = orderedCaloHitList.end() ;
          layerEndIter != layerIter ; ++layerIter)
      {
        const unsigned int pseudoLayer(layerIter->first);
        unsigned int nInteractionLayers(0);

        for(pandora::OrderedCaloHitList::const_iterator layerIter2 = layerIter, layerEndIter2 = orderedCaloHitList.end() ;
            layerEndIter2 != layerIter2 ; ++layerIter2)
        {
          const unsigned int pseudoLayer2(layerIter2->first);

          if(pseudoLayer == pseudoLayer2)
            continue;

          if(pseudoLayer2 > pseudoLayer + settings.m_maxForwardPseudoLayer.Get())
            break;

          unsigned int nPseudoLayerHits(0);

          for(pandora::CaloHitList::const_iterator iter = layerIter2->second->begin(), endIter = layerIter2->second->end() ;
              endIter != iter ; ++iter)
          {
            const pandora::CaloHit *const pCaloHit(*iter);

            float distanceToFit(std::numeric_limits<float>::max());
            const pandora::Granularity granularity(pGeometryManager->GetHitTypeGranularity(pCaloHit->GetHitType()));
            const float minFitHitDistance(granularity <= pandora::FINE ?
                settings.m_minFitHitDistanceFine.Get() : settings.m_minFitHitDistanceCoarse.Get());

            if(pHelix)
            {
              if(pandora::STATUS_CODE_SUCCESS != GeometryHelper::GetDistanceToHelix(*pHelix, pCaloHit->GetPositionVector(), distanceToFit))
                continue;
            }
            else
            {
              if(pandora::STATUS_CODE_SUCCESS != GeometryHelper::GetClosestDistanceToLine(centroid, clusterDirection, pCaloHit->GetPositionVector(), distanceToFit))
                continue;
            }

            if(distanceToFit > minFitHitDistance)
              continue;

            ++nPseudoLayerHits;
          }

          if(nPseudoLayerHits > settings.m_minPseudoLayerNHits.Get())
            ++nInteractionLayers;
        }

        //        std::cout << "    => Pseudo layer " << pseudoLayer << ", n interacting layers = " << nInteractionLayers << std::endl;

        if(nInteractionLayers > settings.m_minNInteractingLayers.Get())
        {
          startingPseudoLayer = pseudoLayer;
          startingLayerFound = true;
          break;
        }
      }
    }
    catch(const pandora::StatusCodeException &exception)
    {
      if(pHelix) delete pHelix;

      std::cout << "ParticleIdHelper::GetStartingPseudoLayer: caught exception in loop : " << exception.ToString() << std::endl;
      return exception.GetStatusCode();
    }

    if(pHelix) delete pHelix;

    if(!startingLayerFound)
    {
//      std::cout << "ParticleIdHelper::GetStartingPseudoLayer: starting layer not found !" << std::endl;
      return pandora::STATUS_CODE_NOT_FOUND;
    }

//    std::cout << "ParticleIdHelper::GetStartingPseudoLayer: starting pseudo layer = " << startingPseudoLayer << std::endl;

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ParticleIdHelper::GetClusterVolume(const pandora::Cluster *const pCluster, float& clusterVolume)
  {
    pandora::CartesianVector centroid(0.f, 0.f, 0.f);
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::GetCentroid(pCluster, centroid));

    float clusterEnergy(0.);

	clusterVolume = 0.;

    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin(), endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit(*iter);

      float hitEnergy(0.);

      if(pCaloHit->GetHitType() == pandora::ECAL)
      {
        hitEnergy = pCaloHit->GetElectromagneticEnergy();
      }
	  else
      {
        hitEnergy = pCaloHit->GetHadronicEnergy();
      }

	  clusterEnergy += hitEnergy;

	  pandora::CartesianVector hitPosition = pCaloHit->GetPositionVector();
	  pandora::CartesianVector relativePosition = hitPosition - centroid;

      float deltaVol = hitEnergy * relativePosition.GetMagnitude();
      clusterVolume += deltaVol;
    }

	// FIXME:: clusterEnergy should not be zero
	if(clusterEnergy < 0.0001) 
	{
		clusterVolume = 0.;
	}
	else
	{
		clusterVolume = clusterVolume/clusterEnergy;
	}

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  //------------------------------------------------------------------------------------------------------------------------------------------

  APRILParticleIdPlugins::APRILEmShowerId::APRILEmShowerId() :
        m_maxStartPseudoLayer(12),
        m_maxPseudoLayerExtension(30),
        m_maxAngleWithOrigin(M_PI/4.f),
        m_maxHadronicEnergyFraction(0.2f),
        m_minOuterEcalPseudoLayerEnergyCut(25),
        m_maxOuterEcalEnergyFraction(0.1f)
  {
  }

  bool APRILParticleIdPlugins::APRILEmShowerId::m_canRecord = false;

  void APRILParticleIdPlugins::APRILEmShowerId::SetRecord(bool canRecord)
  {
	  m_canRecord = canRecord;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  bool APRILParticleIdPlugins::APRILEmShowerId::IsMatch(const pandora::Cluster *const pCluster) const
  {
    if(!ClusterHelper::ContainsHitType(pCluster, pandora::ECAL))
    {
      return false;
    }

    unsigned int endPseudoLayer(0);

    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

    float totalEcalEnergy(0.f), totalHcalEnergy(0.f), totalOuterEmEnergy(0.f);

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin(), endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit(*iter);

      if(pCaloHit->IsIsolated())
      {
        continue;
      }

      if(pCaloHit->GetHitType() == pandora::ECAL)
      {
        if(pCaloHit->GetPseudoLayer() > m_minOuterEcalPseudoLayerEnergyCut)
        {
          totalOuterEmEnergy += pCaloHit->GetElectromagneticEnergy();
        }

        totalEcalEnergy += pCaloHit->GetElectromagneticEnergy();
      }

      if(pCaloHit->GetHitType() == pandora::HCAL)
      {
        totalHcalEnergy += pCaloHit->GetHadronicEnergy();
      }

      if(pCaloHit->GetPseudoLayer() > endPseudoLayer)
      {
        endPseudoLayer = pCaloHit->GetPseudoLayer();
      }
    }

    const float hadronicEnergyFraction(totalHcalEnergy / (totalEcalEnergy+totalHcalEnergy));
    const float outerEmEnergyFraction(totalOuterEmEnergy / (totalEcalEnergy));

    // cut on hadronic energy fraction
    if(hadronicEnergyFraction > m_maxHadronicEnergyFraction)
    {
      return false;
    }

    if(outerEmEnergyFraction > m_maxOuterEcalEnergyFraction)
    {
      return false;
    }

    unsigned int startPseudoLayer(0);

    if(pandora::STATUS_CODE_SUCCESS != ParticleIdHelper::GetStartingPseudoLayer(this->GetPandora(), pCluster, m_startingLayerSettings, startPseudoLayer))
    {
      return false;
    }

    if(startPseudoLayer > m_maxStartPseudoLayer)
    {
      return false;
    }

    if(startPseudoLayer >= endPseudoLayer)
    {
      return false;
    }

    const unsigned int pseudoLayerExtension(endPseudoLayer-startPseudoLayer);

    if(pseudoLayerExtension > m_maxPseudoLayerExtension)
    {
      return false;
    }

    // TODO add piece of code to cut on transverse ratio

    if(pCluster->GetAssociatedTrackList().empty())
    {
      pandora::CartesianVector centroid(0.f, 0.f, 0.f);

      try
      {
        centroid = this->GetEnergyWeightedCentroid(pCluster, startPseudoLayer, endPseudoLayer);
      }
      catch(...)
      {
        return false;
      }

      pandora::ClusterFitPointList photonFitPoints;

      for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin(), endIter = clusterCaloHitList.end() ;
          endIter != iter ; ++iter)
      {
        const pandora::CaloHit *const pCaloHit(*iter);

        if(pCaloHit->IsIsolated() || pCaloHit->GetHitType() != pandora::ECAL)
        {
          continue;
        }

        if(pCaloHit->GetPseudoLayer() < startPseudoLayer || pCaloHit->GetPseudoLayer() > endPseudoLayer)
        {
          continue;
        }

        photonFitPoints.push_back(pandora::ClusterFitPoint(pCaloHit));
      }

      pandora::ClusterFitResult clusterFitResult;

      if(pandora::STATUS_CODE_SUCCESS != pandora::ClusterFitHelper::FitPoints(photonFitPoints, clusterFitResult))
        return false;

      if(!clusterFitResult.IsFitSuccessful())
        return false;

      const pandora::CartesianVector clusterDirection(clusterFitResult.GetDirection());

      if(clusterDirection.GetOpeningAngle(centroid) > m_maxAngleWithOrigin)
      {
        return false;
      }
    }

    return true;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  bool APRILParticleIdPlugins::APRILEmShowerId::IsMatch(const pandora::ParticleFlowObject *const ) const
  {
	  return true;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  
  const pandora::CartesianVector APRILParticleIdPlugins::APRILEmShowerId::GetEnergyWeightedCentroid(const pandora::Cluster *const pCluster, const unsigned int innerPseudoLayer,
      const unsigned int outerPseudoLayer) const
  {
    float energySum(0.f);
    pandora::CartesianVector energyPositionSum(0.f, 0.f, 0.f);
    const pandora::OrderedCaloHitList &orderedCaloHitList(pCluster->GetOrderedCaloHitList());

    for (pandora::OrderedCaloHitList::const_iterator iter = orderedCaloHitList.begin(), iterEnd = orderedCaloHitList.end(); iter != iterEnd; ++iter)
    {
      if (iter->first > outerPseudoLayer)
        break;

      if (iter->first < innerPseudoLayer)
        continue;

      for (pandora::CaloHitList::const_iterator hitIter = iter->second->begin(), hitIterEnd = iter->second->end(); hitIter != hitIterEnd; ++hitIter)
      {
        const float electromagneticEnergy((*hitIter)->GetElectromagneticEnergy());
        energySum += electromagneticEnergy;
        energyPositionSum += ((*hitIter)->GetPositionVector() * electromagneticEnergy);
      }
    }

    if (energySum < std::numeric_limits<float>::epsilon())
      throw pandora::StatusCodeException(pandora::STATUS_CODE_NOT_INITIALIZED);

    return (energyPositionSum * (1.f / energySum));
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode APRILParticleIdPlugins::APRILEmShowerId::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    unsigned int maxForwardPseudoLayer = m_startingLayerSettings.m_maxForwardPseudoLayer.Get();
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxForwardPseudoLayer", maxForwardPseudoLayer));
    m_startingLayerSettings.m_maxForwardPseudoLayer = maxForwardPseudoLayer;

    unsigned int minPseudoLayerNHits = m_startingLayerSettings.m_minPseudoLayerNHits.Get();
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinPseudoLayerNHits", minPseudoLayerNHits));
    m_startingLayerSettings.m_minPseudoLayerNHits = minPseudoLayerNHits;

    float minFitHitDistanceFine = m_startingLayerSettings.m_minFitHitDistanceFine.Get();
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinFitHitDistanceFine", minFitHitDistanceFine));
    m_startingLayerSettings.m_minFitHitDistanceFine = minFitHitDistanceFine;

    float minFitHitDistanceCoarse = m_startingLayerSettings.m_minFitHitDistanceCoarse.Get();
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinFitHitDistanceCoarse", minFitHitDistanceCoarse));
    m_startingLayerSettings.m_minFitHitDistanceCoarse = minFitHitDistanceCoarse;

    unsigned int minNInteractingLayers = m_startingLayerSettings.m_minNInteractingLayers.Get();
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinNInteractingLayers", minNInteractingLayers));
    m_startingLayerSettings.m_minNInteractingLayers = minNInteractingLayers;

    float lowEnergyClusterCut = m_startingLayerSettings.m_lowEnergyClusterCut.Get();
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "LowEnergyClusterCut", lowEnergyClusterCut));
    m_startingLayerSettings.m_lowEnergyClusterCut = lowEnergyClusterCut;

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxStartPseudoLayer", m_maxStartPseudoLayer));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxPseudoLayerExtension", m_maxPseudoLayerExtension));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxAngleWithOrigin", m_maxAngleWithOrigin));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxHadronicEnergyFraction", m_maxHadronicEnergyFraction));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinOuterEcalPseudoLayerEnergyCut", m_minOuterEcalPseudoLayerEnergyCut));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxOuterEcalEnergyFraction", m_maxOuterEcalEnergyFraction));

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  //------------------------------------------------------------------------------------------------------------------------------------------

  bool APRILParticleIdPlugins::APRILPhotonId::m_canRecord = false;

  void APRILParticleIdPlugins::APRILPhotonId::SetRecord(bool canRecord)
  {
	  m_canRecord = canRecord;
  }

  bool APRILParticleIdPlugins::APRILPhotonId::IsMatch(const pandora::Cluster *const pCluster) const
  {
#if 0
    if (pandora::PHOTON == pCluster->GetParticleId())
    {
      return true;
    }
#endif

    bool isEmShower = this->GetPandora().GetPlugins()->GetParticleId()->IsEmShower(pCluster);

    if(isEmShower)
    {
      bool isPhoton(pCluster->GetAssociatedTrackList().empty());

      if(isPhoton)
      {
        return true;
      }
    }

    return false;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  
  bool APRILParticleIdPlugins::APRILPhotonId::IsMatch(const pandora::ParticleFlowObject *const ) const
  {
	  return true;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode APRILParticleIdPlugins::APRILPhotonId::ReadSettings(const pandora::TiXmlHandle /*xmlHandle*/)
  {
    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  //------------------------------------------------------------------------------------------------------------------------------------------

  bool APRILParticleIdPlugins::APRILElectronId::IsMatch(const pandora::Cluster *const pCluster) const
  {
    if (pandora::E_MINUS == std::abs(pCluster->GetParticleId()))
      return true;

    if(this->GetPandora().GetPlugins()->GetParticleId()->IsEmShower(pCluster))
    {
      bool isElectron(!pCluster->GetAssociatedTrackList().empty());

      if(isElectron)
      {
        return true;
      }
    }

    return false;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  bool APRILParticleIdPlugins::APRILElectronId::IsMatch(const pandora::ParticleFlowObject *const ) const
  {
	  return true;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  pandora::StatusCode APRILParticleIdPlugins::APRILElectronId::ReadSettings(const pandora::TiXmlHandle /*xmlHandle*/)
  {
    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  //------------------------------------------------------------------------------------------------------------------------------------------

  APRILParticleIdPlugins::APRILMuonId::APRILMuonId() :
        m_lowMomentumMuonCut(0.5),
        m_maxNCaloHitsInPseudoLayerFine(2),
        m_maxNCaloHitsInPseudoLayerCoarse(4),
        m_maxNHighDensityPseudoLayer(3),
        m_minEcalPseudoLayers(20),
        m_minEcalLayers(20),
        m_minHcalPseudoLayers(20),
        m_minHcalLayers(20)
  {
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  bool APRILParticleIdPlugins::APRILMuonId::IsMatch(const pandora::Cluster *const pCluster) const
  {
    if (pandora::MU_MINUS == std::abs(pCluster->GetParticleId()))
      return true;

    if(pCluster->GetAssociatedTrackList().empty())
      return false;

    if(pCluster->GetNCaloHits() == 0)
      return false;

    const pandora::TrackList &trackList(pCluster->GetAssociatedTrackList());
    float energyAtDca(0.f);

    for(pandora::TrackList::const_iterator iter = trackList.begin(), endIter = trackList.end() ;
        endIter != iter ; ++iter)
      energyAtDca += (*iter)->GetEnergyAtDca();

    //    const bool lowMometumMuon(energyAtDca < m_lowMomentumMuonCut);
    const pandora::OrderedCaloHitList orderedCaloHitList(pCluster->GetOrderedCaloHitList());
    unsigned int nHighDensityPseudoLayers(0);
    std::set<unsigned int> ecalPseudoLayerList, ecalLayerList, hcalPseudoLayerList, hcalLayerList;

    try
    {
      for(pandora::OrderedCaloHitList::const_iterator layerIter = orderedCaloHitList.begin(), layerEndIter = orderedCaloHitList.end() ;
          layerEndIter != layerIter ; ++layerIter)
      {
        unsigned int nPseudoLayerCaloHitsFine(0), nPseudoLayerCaloHitsCoarse(0);

        for(pandora::CaloHitList::const_iterator iter = layerIter->second->begin(), endIter = layerIter->second->end() ;
            endIter != iter ; ++iter)
        {
          const april_content::CaloHit *const pCaloHit(dynamic_cast<const april_content::CaloHit *const>(*iter));

          if(NULL == pCaloHit)
            throw pandora::StatusCodeException(pandora::STATUS_CODE_FAILURE);

          if(pCaloHit->IsIsolated())
            continue;

          const pandora::Granularity granularity(this->GetPandora().GetGeometry()->GetHitTypeGranularity(pCaloHit->GetHitType()));

          if(granularity <= pandora::FINE)
          {
            ++nPseudoLayerCaloHitsFine;
          }
          else
          {
            ++nPseudoLayerCaloHitsCoarse;
          }

          if(pCaloHit->GetHitType() == pandora::ECAL)
          {
            ecalPseudoLayerList.insert(pCaloHit->GetPseudoLayer());
            ecalLayerList.insert(pCaloHit->GetLayer());
          }

          if(pCaloHit->GetHitType() == pandora::HCAL)
          {
            hcalPseudoLayerList.insert(pCaloHit->GetPseudoLayer());
            hcalLayerList.insert(pCaloHit->GetLayer());
          }
        }

        const unsigned int nPseudoLayerCaloHits(nPseudoLayerCaloHitsFine+nPseudoLayerCaloHitsCoarse);
        const unsigned int maxNCaloHitsInPseudoLayer(nPseudoLayerCaloHitsCoarse >= nPseudoLayerCaloHitsFine ?
            m_maxNCaloHitsInPseudoLayerCoarse : m_maxNCaloHitsInPseudoLayerFine);

        if(nPseudoLayerCaloHits > maxNCaloHitsInPseudoLayer)
          ++nHighDensityPseudoLayers;
      }
    }
    catch(const pandora::StatusCodeException &exception)
    {
      return false;
    }

    const unsigned int nEcalPseudoLayers(ecalPseudoLayerList.size());
    const unsigned int nEcalLayers(ecalLayerList.size());
    const unsigned int nHcalPseudoLayers(hcalPseudoLayerList.size());
    const unsigned int nHcalLayers(hcalLayerList.size());

    if(nEcalPseudoLayers < m_minEcalPseudoLayers && nEcalLayers < m_minEcalLayers)
      return false;

    if(nHcalPseudoLayers < m_minHcalPseudoLayers && nHcalLayers < m_minHcalLayers)
      return false;

    if(nHighDensityPseudoLayers < m_maxNHighDensityPseudoLayer)
    {
      return true;
    }

    return false;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  
  bool APRILParticleIdPlugins::APRILMuonId::IsMatch(const pandora::ParticleFlowObject *const ) const
  {
	  return true;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode APRILParticleIdPlugins::APRILMuonId::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "LowMomentumMuonCut", m_lowMomentumMuonCut));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxNCaloHitsInPseudoLayerFine", m_maxNCaloHitsInPseudoLayerFine));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxNCaloHitsInPseudoLayerCoarse", m_maxNCaloHitsInPseudoLayerCoarse));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxNHighDensityPseudoLayer", m_maxNHighDensityPseudoLayer));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinEcalPseudoLayers", m_minEcalPseudoLayers));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinEcalLayers", m_minEcalLayers));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinHcalPseudoLayers", m_minHcalPseudoLayers));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinHcalLayers", m_minHcalLayers));

    return pandora::STATUS_CODE_SUCCESS;
  }

} 

