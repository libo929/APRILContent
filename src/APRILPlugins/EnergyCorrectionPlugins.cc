/// \file EnergyCorrectionPlugin.cc
/*
 *
 * EnergyCorrectionPlugin.cc source template automatically generated by a class generator
 * Creation date : mar. nov. 17 2015
 *
 * This file is part of APRILContent libraries.
 * 
 * APRILContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * APRILContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with APRILContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "APRILPlugins/EnergyCorrectionPlugins.h"
#include "APRILHelpers/ClusterHelper.h"
#include "APRILPlugins/ParticleIdPlugins.h"

#include "Pandora/AlgorithmHeaders.h"

namespace april_content
{
  AnalogicEnergyFunction::AnalogicEnergyFunction() :
        m_ecalEnergyType(0),
        m_hcalEnergyType(0),
        m_muonEnergyType(0),
        m_otherEnergyType(0)
  {
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode AnalogicEnergyFunction::MakeEnergyCorrections(const pandora::Cluster *const pCluster, float &correctedEnergy) const
  {
    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

    correctedEnergy = 0.f;

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin(), endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit = *iter;

      const pandora::HitType hitType(pCaloHit->GetHitType());

      const unsigned int energyType(
          (hitType == pandora::ECAL) ? m_ecalEnergyType :
              (hitType == pandora::HCAL) ? m_hcalEnergyType :
                  (hitType == pandora::MUON) ? m_muonEnergyType :
                      m_otherEnergyType);

      switch(energyType)
      {
      case 0:
        correctedEnergy += pCaloHit->GetInputEnergy();
        break;
      case 1:
        correctedEnergy += pCaloHit->GetElectromagneticEnergy();
        break;
      case 2:
        correctedEnergy += pCaloHit->GetHadronicEnergy();
        break;
      default:
        correctedEnergy += pCaloHit->GetInputEnergy();
        break;
      }
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode AnalogicEnergyFunction::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    m_ecalEnergyType = 0;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "EcalEnergyType", m_ecalEnergyType));

    m_hcalEnergyType = 0;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "HcalEnergyType", m_hcalEnergyType));

    m_muonEnergyType = 0;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MuonEnergyType", m_muonEnergyType));

    m_otherEnergyType = 0;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "OtherEnergyType", m_otherEnergyType));

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  //------------------------------------------------------------------------------------------------------------------------------------------

  SdhcalQuadraticEnergyFunction::SdhcalQuadraticEnergyFunction()
  {
    m_energyConstantParameters.push_back(0.0385315);
    m_energyConstantParameters.push_back(4.22584e-05);
    m_energyConstantParameters.push_back(-7.54657e-09);
    m_energyConstantParameters.push_back(0.0784297);
    m_energyConstantParameters.push_back(-5.69439e-05);
    m_energyConstantParameters.push_back(-4.95924e-08);
    m_energyConstantParameters.push_back(0.127212);
    m_energyConstantParameters.push_back(4.56414e-05);
    m_energyConstantParameters.push_back(1.41142e-08);

    m_sdhcalThresholds.push_back(1);
    m_sdhcalThresholds.push_back(2);
    m_sdhcalThresholds.push_back(3);
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode SdhcalQuadraticEnergyFunction::MakeEnergyCorrections(const pandora::Cluster *const pCluster, float &correctedEnergy) const
  {
    unsigned int NHadronicHit  = 0;
    unsigned int NHadronicHit1 = 0;
    unsigned int NHadronicHit2 = 0;
    unsigned int NHadronicHit3 = 0;

    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

    float emEnergy = 0.f;
    float otherEnergy = 0.f;

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin(), endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit = *iter;

      // Ecal case. Get the calibrated hit energy
      if(pandora::ECAL == pCaloHit->GetHitType())
      {
        emEnergy += pCaloHit->GetElectromagneticEnergy();
        continue;
      }
      // SDHCAL case. Do thresholds counting
      else if(pandora::HCAL == pCaloHit->GetHitType())
      {
        if(fabs(m_sdhcalThresholds.at(0) - pCaloHit->GetInputEnergy()) < std::numeric_limits<float>::epsilon())
          NHadronicHit1++;
        else if(fabs(m_sdhcalThresholds.at(1) - pCaloHit->GetInputEnergy()) < std::numeric_limits<float>::epsilon())
          NHadronicHit2++;
        else if(fabs(m_sdhcalThresholds.at(2) - pCaloHit->GetInputEnergy()) < std::numeric_limits<float>::epsilon())
          NHadronicHit3++;
        else
        {
          otherEnergy += pCaloHit->GetInputEnergy();
          continue;
        }

        NHadronicHit++;
      }
      // Other hit types ... should never happen
      else
      {
        otherEnergy += pCaloHit->GetInputEnergy();
      }
    }

    // estimate of sdhcal energy
    const float alpha(m_energyConstantParameters.at(0) + m_energyConstantParameters.at(1)*NHadronicHit + m_energyConstantParameters.at(2)*NHadronicHit*NHadronicHit);
    const float beta(m_energyConstantParameters.at(3) + m_energyConstantParameters.at(4)*NHadronicHit + m_energyConstantParameters.at(5)*NHadronicHit*NHadronicHit);
    const float gamma(m_energyConstantParameters.at(6) + m_energyConstantParameters.at(7)*NHadronicHit + m_energyConstantParameters.at(8)*NHadronicHit*NHadronicHit);
    const float hadEnergy(NHadronicHit1*alpha + NHadronicHit2*beta + NHadronicHit3*gamma);

    correctedEnergy = emEnergy + hadEnergy + otherEnergy;

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode SdhcalQuadraticEnergyFunction::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    pandora::FloatVector energyConstantParameters;
    pandora::StatusCode statusCode = pandora::XmlHelper::ReadVectorOfValues(xmlHandle,
        "EnergyConstantParameters", energyConstantParameters);

    if(statusCode == pandora::STATUS_CODE_SUCCESS)
    {
      m_energyConstantParameters = energyConstantParameters;
    }
    else if(statusCode != pandora::STATUS_CODE_NOT_FOUND)
    {
      return statusCode;
    }

    if(9 != m_energyConstantParameters.size())
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    pandora::FloatVector sdhcalThresholds;
    statusCode = pandora::XmlHelper::ReadVectorOfValues(xmlHandle,
        "SdhcalThresholds", sdhcalThresholds);

    if(statusCode == pandora::STATUS_CODE_SUCCESS)
    {
      m_sdhcalThresholds = sdhcalThresholds;
    }
    else if(statusCode != pandora::STATUS_CODE_NOT_FOUND)
    {
      return statusCode;
    }

    if(3 != m_sdhcalThresholds.size())
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  //------------------------------------------------------------------------------------------------------------------------------------------

  BarrelGapEnergyFunction::BarrelGapEnergyFunction() :
        m_ecalDistanceToGap(10.f),  // 8 mm + 2 mm
        m_hcalDistanceToGap(30.f),  // 20 mm + 10 mm
        m_ecalGapAlpha(0),
        m_ecalGapBeta(0),
        m_hcalGapAlpha(1.5254),
        m_hcalGapBeta(0)
  {
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode BarrelGapEnergyFunction::MakeEnergyCorrections(const pandora::Cluster *const pCluster, float &correctedEnergy) const
  {
	  //std::cout << "BarrelGapEnergyFunction::MakeEnergyCorrections" << std::endl;
    if(m_ecalZGapPositions.empty() && m_hcalZGapPositions.empty())
      return pandora::STATUS_CODE_SUCCESS;

    if(pCluster->GetNCaloHits() == 0)
      return pandora::STATUS_CODE_SUCCESS;

    float ecalGapEnergy(0), hcalGapEnergy(0);

    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin(), endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit(*iter);
      const bool nearbyGap(this->IsNearbyGap(pCaloHit));

      if(!nearbyGap)
        continue;

      if(pCaloHit->GetHitType() == pandora::ECAL)
        ecalGapEnergy += pCaloHit->GetHadronicEnergy();
      else if(pCaloHit->GetHitType() == pandora::HCAL)
        hcalGapEnergy += pCaloHit->GetHadronicEnergy();
    }

    correctedEnergy +=
        m_ecalGapAlpha * ecalGapEnergy + m_ecalGapBeta * ecalGapEnergy * ecalGapEnergy +
        m_hcalGapAlpha * hcalGapEnergy + m_hcalGapBeta * hcalGapEnergy * hcalGapEnergy;

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  bool BarrelGapEnergyFunction::IsNearbyGap(const pandora::CaloHit *const pCaloHit) const
  {
    if(pCaloHit->GetHitRegion() != pandora::BARREL)
      return false;

    if(pCaloHit->GetHitType() != pandora::ECAL && pCaloHit->GetHitType() != pandora::HCAL)
      return false;

    const pandora::FloatVector zGapPositions(pCaloHit->GetHitType() == pandora::ECAL ? m_ecalZGapPositions : m_hcalZGapPositions);
    const float distanceToGap(pCaloHit->GetHitType() == pandora::ECAL ? m_ecalDistanceToGap : m_hcalDistanceToGap);
    const float hitZ(pCaloHit->GetPositionVector().GetZ());

    for(pandora::FloatVector::const_iterator iter = zGapPositions.begin(), endIter = zGapPositions.end() ;
        endIter != iter ; ++iter)
    {
      const float gapZPosition(*iter);

      if( ((hitZ < gapZPosition) && (hitZ > gapZPosition-distanceToGap))
       || ((hitZ > gapZPosition) && (hitZ < gapZPosition+distanceToGap)) )
      {
        return true;
      }
    }

    return false;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode BarrelGapEnergyFunction::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadVectorOfValues(xmlHandle,
        "EcalZGapPositions", m_ecalZGapPositions));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadVectorOfValues(xmlHandle,
        "HcalZGapPositions", m_hcalZGapPositions));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "EcalDistanceToGap", m_ecalDistanceToGap));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "HcalDistanceToGap", m_hcalDistanceToGap));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "EcalGapAlpha", m_ecalGapAlpha));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "EcalGapBeta", m_ecalGapBeta));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "HcalGapAlpha", m_hcalGapAlpha));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "HcalGapBeta", m_hcalGapBeta));

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  //------------------------------------------------------------------------------------------------------------------------------------------

  ThetaEnergyFunction::ThetaEnergyFunction() :
        m_lowEnergyCut(3.f),
        m_barrelP00(-2.36284),
        m_barrelP01(1.14627),
        m_barrelP02(-0.00152029),
        m_barrelP10(0.325533),
        m_barrelP11(-0.126941),
        m_barrelP12(0.000462463),
        m_endcapP00(-2.16956),
        m_endcapP01(0.801878),
        m_endcapP02(1.27263e-05),
        m_endcapP10(0.157559),
        m_endcapP11(0.34754),
        m_endcapP12(-0.00122559)
  {
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ThetaEnergyFunction::MakeEnergyCorrections(const pandora::Cluster *const pCluster, float &correctedEnergy) const
  {
	//std::cout << "ThetaEnergyFunction::MakeEnergyCorrections" << std::endl;

	// FIXME: we should investigate this function ... 
    return pandora::STATUS_CODE_SUCCESS;

    if(pCluster->GetNCaloHits() == 0)
      return pandora::STATUS_CODE_SUCCESS;

    if(correctedEnergy < m_lowEnergyCut)
      return pandora::STATUS_CODE_SUCCESS;

	//std::cout << "the energy to correct: " << correctedEnergy << std::endl;

    unsigned int startingPseudoLayer(std::numeric_limits<unsigned int>::max());

    const pandora::StatusCode statusCode(ParticleIdHelper::GetStartingPseudoLayer(this->GetPandora(), pCluster, ParticleIdHelper::StartingLayerSettings(), startingPseudoLayer));

	//std::cout << "startingPseudoLayer: " << startingPseudoLayer << std::endl;

    // do not apply energy corrections if starting layer not found
    if(pandora::STATUS_CODE_SUCCESS != statusCode)
      return pandora::STATUS_CODE_SUCCESS;

    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

    const float clusterEnergy(pCluster->GetHadronicEnergy());
    float startingHadronicEnergySum(0.f);
    float barrelEnergyFraction(0.f);
    float endcapEnergyFraction(0.f);
    bool noShowerHit(true);

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin(), endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit(*iter);

      if(pCaloHit->GetHitRegion() == pandora::BARREL)
      {
        barrelEnergyFraction += pCaloHit->GetHadronicEnergy();
      }
      else if(pCaloHit->GetHitRegion() == pandora::ENDCAP)
      {
        endcapEnergyFraction += pCaloHit->GetHadronicEnergy();
      }

      if(pCaloHit->GetPseudoLayer() >= startingPseudoLayer)
	  {
        continue;
	  }
	  else
	  {
		  //std::cout << "calo hit pseudo layer: " << pCaloHit->GetPseudoLayer() << std::endl;
	  }

      startingHadronicEnergySum += pCaloHit->GetHadronicEnergy();
      noShowerHit = false;
    }

    if(noShowerHit)
      return pandora::STATUS_CODE_SUCCESS;

    // evaluate corrected energy fraction of the main shower part
    // used in following computation since calibration of this correction is done
    // with kaon0L particles. This avoid to correct energy of mip like hadrons
    const float startingHadronicEnergyFraction(startingHadronicEnergySum/pCluster->GetHadronicEnergy());
	//std::cout << "startingHadronicEnergySum: " << startingHadronicEnergySum << ", cluster hadronicEnergy: " << 
		//pCluster->GetHadronicEnergy() << std::endl;

    const float correctedStartingHadronicEnergy(startingHadronicEnergyFraction*correctedEnergy);
    const float mainCorrectedShowerEnergy(correctedEnergy - correctedStartingHadronicEnergy);
	//std::cout << "mainCorrectedShowerEnergy: " << mainCorrectedShowerEnergy << std::endl;

    barrelEnergyFraction /= clusterEnergy;
    endcapEnergyFraction /= clusterEnergy;

	//std::cout << "barrelEnergyFraction: " << barrelEnergyFraction << " endcapEnergyFraction: " << endcapEnergyFraction << std::endl;

    try
    {
      const float clusterCosTheta(this->GetCosTheta(pCluster));

      correctedEnergy = barrelEnergyFraction*this->GetBarrelCorrectedEnergy(mainCorrectedShowerEnergy, clusterCosTheta)
          + endcapEnergyFraction*this->GetEndcapCorrectedEnergy(mainCorrectedShowerEnergy, clusterCosTheta);

	  //std::cout << "correctedEnergy: " << correctedEnergy << std::endl;
    }
    catch(const pandora::StatusCodeException &exception)
    {
      //std::cerr << "ThetaEnergyFunction::MakeEnergyCorrections: Couldn't evaluate cluster cos theta : " << exception.ToString() << std::endl;
      return pandora::STATUS_CODE_SUCCESS;
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  float ThetaEnergyFunction::GetCosTheta(const pandora::Cluster *const pCluster) const
  {
    pandora::CartesianVector centroid(0.f, 0.f, 0.f);
    PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::GetCentroid(pCluster, centroid));

    return fabs(centroid.GetCosOpeningAngle(pandora::CartesianVector(0.f, 0.f, 1.f)));
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  float ThetaEnergyFunction::GetBarrelCorrectedEnergy(float inputEnergy, float cosTheta) const
  {
	  std::cout << "inputEnergy: " << inputEnergy << ", cosTheta: " << cosTheta << std::endl;
    return (-1*(m_barrelP01+m_barrelP11*cosTheta) + std::sqrt((m_barrelP01+m_barrelP11*cosTheta)*(m_barrelP01+m_barrelP11*cosTheta)
        - 4*(m_barrelP02+m_barrelP12*cosTheta)*(m_barrelP00+m_barrelP10*cosTheta - inputEnergy)))/(2*(m_barrelP02+m_barrelP12*cosTheta));
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  float ThetaEnergyFunction::GetEndcapCorrectedEnergy(float inputEnergy, float cosTheta) const
  {
    return (-1*(m_endcapP01+m_endcapP11*cosTheta) + std::sqrt((m_endcapP01+m_endcapP11*cosTheta)*(m_endcapP01+m_endcapP11*cosTheta)
        - 4*(m_endcapP02+m_endcapP12*cosTheta)*(m_endcapP00+m_endcapP10*cosTheta - inputEnergy)))/(2*(m_endcapP02+m_endcapP12*cosTheta));
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ThetaEnergyFunction::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "LowEnergyCut", m_lowEnergyCut));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "BarrelP00", m_barrelP00));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "BarrelP01", m_barrelP01));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "BarrelP02", m_barrelP02));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "BarrelP10", m_barrelP10));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "BarrelP11", m_barrelP11));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "BarrelP12", m_barrelP12));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "EndcapP00", m_endcapP00));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "EndcapP01", m_endcapP01));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "EndcapP02", m_endcapP02));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "EndcapP10", m_endcapP10));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "EndcapP11", m_endcapP11));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "EndcapP12", m_endcapP12));

    return pandora::STATUS_CODE_SUCCESS;
  }

CleanCluster::CleanCluster() :
    m_minCleanHitEnergy(0.5f),
    m_minCleanHitEnergyFraction(0.01f),
    m_minCleanCorrectedHitEnergy(0.1f)
{
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode CleanCluster::MakeEnergyCorrections(const pandora::Cluster *const pCluster, float &correctedHadronicEnergy) const
{
    const unsigned int firstPseudoLayer(this->GetPandora().GetPlugins()->GetPseudoLayerPlugin()->GetPseudoLayerAtIp());

    const float clusterHadronicEnergy(pCluster->GetHadronicEnergy());

    if (std::fabs(clusterHadronicEnergy) < std::numeric_limits<float>::epsilon())
        throw pandora::StatusCodeException(pandora::STATUS_CODE_FAILURE);

    bool isFineGranularity(true);
    const pandora::OrderedCaloHitList &orderedCaloHitList(pCluster->GetOrderedCaloHitList());

    // Loop over all constituent inner layer fine granularity hits, looking for anomalies
    for (pandora::OrderedCaloHitList::const_iterator layerIter = orderedCaloHitList.begin(), layerIterEnd = orderedCaloHitList.end();
        (layerIter != layerIterEnd) && isFineGranularity; ++layerIter)
    {
        const unsigned int pseudoLayer(layerIter->first);

        for (pandora::CaloHitList::const_iterator hitIter = layerIter->second->begin(), hitIterEnd = layerIter->second->end();
            hitIter != hitIterEnd; ++hitIter)
        {
            const pandora::CaloHit *const pCaloHit = *hitIter;

            if (this->GetPandora().GetGeometry()->GetHitTypeGranularity((*hitIter)->GetHitType()) > pandora::FINE)
            {
                isFineGranularity = false;
                break;
            }

            const float hitHadronicEnergy(pCaloHit->GetHadronicEnergy());

            if ((hitHadronicEnergy > m_minCleanHitEnergy) && (hitHadronicEnergy / clusterHadronicEnergy > m_minCleanHitEnergyFraction))
            {
                // Calculate new energy from surrounding layers
                float energyInPreviousLayer(0.);

                if (pseudoLayer > firstPseudoLayer)
                    energyInPreviousLayer = this->GetHadronicEnergyInLayer(orderedCaloHitList, pseudoLayer - 1);

                float energyInNextLayer(0.);

                if (pseudoLayer < std::numeric_limits<unsigned int>::max())
                    energyInNextLayer = this->GetHadronicEnergyInLayer(orderedCaloHitList, pseudoLayer + 1);

                const float energyInCurrentLayer = this->GetHadronicEnergyInLayer(orderedCaloHitList, pseudoLayer);

                // Calculate new energy estimate for hit and update cluster best energy estimate
                float energyInAdjacentLayers(energyInPreviousLayer + energyInNextLayer);

                if (pseudoLayer > firstPseudoLayer)
                    energyInAdjacentLayers /= 2.f;

                float newHitHadronicEnergy(energyInAdjacentLayers - energyInCurrentLayer + hitHadronicEnergy);
                newHitHadronicEnergy = std::max(newHitHadronicEnergy, m_minCleanCorrectedHitEnergy);

                if (newHitHadronicEnergy < hitHadronicEnergy)
                    correctedHadronicEnergy += newHitHadronicEnergy - hitHadronicEnergy;
            }
        }
    }

    return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

float CleanCluster::GetHadronicEnergyInLayer(const pandora::OrderedCaloHitList &orderedCaloHitList, const unsigned int pseudoLayer) const
{
	pandora::OrderedCaloHitList::const_iterator iter = orderedCaloHitList.find(pseudoLayer);

    float hadronicEnergy(0.f);

    if (iter != orderedCaloHitList.end())
    {
        for (pandora::CaloHitList::const_iterator hitIter = iter->second->begin(), hitIterEnd = iter->second->end(); hitIter != hitIterEnd; ++hitIter)
        {
            hadronicEnergy += (*hitIter)->GetHadronicEnergy();
        }
    }

    return hadronicEnergy;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode CleanCluster::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinCleanHitEnergy", m_minCleanHitEnergy));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinCleanHitEnergyFraction", m_minCleanHitEnergyFraction));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinCleanCorrectedHitEnergy", m_minCleanCorrectedHitEnergy));

    return pandora::STATUS_CODE_SUCCESS;
}

}

