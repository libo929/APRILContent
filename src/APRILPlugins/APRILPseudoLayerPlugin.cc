/// \file APRILPseudoLayerPlugin.cc
/*
 *
 * APRILPseudoLayerPlugin.cc source template automatically generated by a class generator
 * Creation date : sam. mars 21 2015
 *
 * This file is part of APRILContent libraries.
 *
 * APRILContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * APRILContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with APRILContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author John Marshall
 */

#include "Pandora/AlgorithmHeaders.h"

#include "APRILPlugins/APRILPseudoLayerPlugin.h"

namespace april_content
{

  APRILPseudoLayerPlugin::APRILPseudoLayerPlugin() :
      m_barrelInnerR(0.f),
      m_endCapInnerZ(0.f),
      m_barrelInnerRMuon(0.f),
      m_endCapInnerZMuon(0.f),
      m_rCorrection(0.f),
      m_zCorrection(0.f),
      m_rCorrectionMuon(0.f),
      m_zCorrectionMuon(0.f),
      m_barrelEdgeR(0.f),
      m_endCapEdgeZ(0.f),
      m_useCoordinateCorrections(false)
  {
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode APRILPseudoLayerPlugin::Initialize()
  {
    try
    {
      this->StoreLayerPositions();
      this->StoreDetectorOuterEdge();
      this->StorePolygonAngles();
      this->StoreOverlapCorrectionDetails();
    }
    catch (pandora::StatusCodeException &statusCodeException)
    {
      std::cout << "APRILPseudoLayerPlugin: Incomplete geometry - consider using a different PseudoLayerCalculator." << std::endl;
      return statusCodeException.GetStatusCode();
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  unsigned int APRILPseudoLayerPlugin::GetPseudoLayer(const pandora::CartesianVector &positionVector) const
  {
    const float zCoordinate(std::fabs(positionVector.GetZ()));

    if (zCoordinate > m_endCapEdgeZ)
      throw pandora::StatusCodeException(pandora::STATUS_CODE_NOT_FOUND);

    const float rCoordinate(this->GetMaximumRadius(m_eCalBarrelAngleVector, positionVector.GetX(), positionVector.GetY()));
    const float rCoordinateMuon(this->GetMaximumRadius(m_muonBarrelAngleVector, positionVector.GetX(), positionVector.GetY()));

    if ((rCoordinateMuon > m_barrelEdgeR) || (rCoordinate > m_barrelEdgeR))
      throw pandora::StatusCodeException(pandora::STATUS_CODE_NOT_FOUND);

    unsigned int pseudoLayer;

    if ((zCoordinate < m_endCapInnerZMuon) && (rCoordinateMuon < m_barrelInnerRMuon))
    {
      const pandora::StatusCode statusCode(this->GetPseudoLayer(rCoordinate, zCoordinate, m_rCorrection, m_zCorrection, m_barrelInnerR,
          m_endCapInnerZ, pseudoLayer));

      if (pandora::STATUS_CODE_SUCCESS != statusCode)
        throw pandora::StatusCodeException(statusCode);
    }
    else
    {
      const pandora::StatusCode statusCode(this->GetPseudoLayer(rCoordinateMuon, zCoordinate, m_rCorrectionMuon, m_zCorrectionMuon,
          m_barrelInnerRMuon, m_endCapInnerZMuon, pseudoLayer));

      if (pandora::STATUS_CODE_SUCCESS != statusCode)
        throw pandora::StatusCodeException(statusCode);
    }

    // Reserve a pseudo layer for track projections, etc.
    return (1 + pseudoLayer);
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode APRILPseudoLayerPlugin::GetPseudoLayer(const float rCoordinate, const float zCoordinate, const float rCorrection,
      const float zCorrection, const float barrelInnerR, const float endCapInnerZ, unsigned int &pseudoLayer) const
  {
    if (zCoordinate < endCapInnerZ)
    {
      return this->FindMatchingLayer(rCoordinate, m_barrelLayerPositions, pseudoLayer);
    }
    else if (rCoordinate < barrelInnerR)
    {
      return this->FindMatchingLayer(zCoordinate, m_endCapLayerPositions, pseudoLayer);
    }
    else
    {
      const float correctedRCoordinate = m_useCoordinateCorrections ? rCoordinate - rCorrection : rCoordinate;
      const float correctedZCoordinate = m_useCoordinateCorrections ? zCoordinate - zCorrection : zCoordinate;

      unsigned int bestBarrelLayer(0);
      const pandora::StatusCode barrelStatusCode(this->FindMatchingLayer(correctedRCoordinate, m_barrelLayerPositions, bestBarrelLayer));

      unsigned int bestEndCapLayer(0);
      const pandora::StatusCode endCapStatusCode(this->FindMatchingLayer(correctedZCoordinate, m_endCapLayerPositions, bestEndCapLayer));

      if ((pandora::STATUS_CODE_SUCCESS != barrelStatusCode) && (pandora::STATUS_CODE_SUCCESS != endCapStatusCode))
        return pandora::STATUS_CODE_NOT_FOUND;

      pseudoLayer = std::max(bestBarrelLayer, bestEndCapLayer);
      return pandora::STATUS_CODE_SUCCESS;
    }
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode APRILPseudoLayerPlugin::FindMatchingLayer(const float position, const LayerPositionList &layerPositionList,
      unsigned int &layer) const
  {
    LayerPositionList::const_iterator upperIter = std::upper_bound(layerPositionList.begin(), layerPositionList.end(), position);

    if (layerPositionList.end() == upperIter)
    {
      return pandora::STATUS_CODE_NOT_FOUND;
    }

    if (layerPositionList.begin() == upperIter)
    {
      layer = 0;
      return pandora::STATUS_CODE_SUCCESS;
    }

    LayerPositionList::const_iterator lowerIter = upperIter - 1;

    if (std::fabs(position - *lowerIter) < std::fabs(position - *upperIter))
    {
      layer = std::distance(layerPositionList.begin(), lowerIter);
    }
    else
    {
      layer = std::distance(layerPositionList.begin(), upperIter);
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  void APRILPseudoLayerPlugin::StoreLayerPositions()
  {
    const pandora::GeometryManager *const pGeometryManager(this->GetPandora().GetGeometry());
    this->StoreLayerPositions(pGeometryManager->GetSubDetector(pandora::ECAL_BARREL), m_barrelLayerPositions);
    this->StoreLayerPositions(pGeometryManager->GetSubDetector(pandora::ECAL_ENDCAP), m_endCapLayerPositions);
    this->StoreLayerPositions(pGeometryManager->GetSubDetector(pandora::HCAL_BARREL), m_barrelLayerPositions);
    this->StoreLayerPositions(pGeometryManager->GetSubDetector(pandora::HCAL_ENDCAP), m_endCapLayerPositions);
    this->StoreLayerPositions(pGeometryManager->GetSubDetector(pandora::MUON_BARREL), m_barrelLayerPositions);
    this->StoreLayerPositions(pGeometryManager->GetSubDetector(pandora::MUON_ENDCAP), m_endCapLayerPositions);

    if (m_barrelLayerPositions.empty() || m_endCapLayerPositions.empty())
    {
      std::cout << "APRILPseudoLayerPlugin: No layer positions specified." << std::endl;
      throw pandora::StatusCodeException(pandora::STATUS_CODE_NOT_INITIALIZED);
    }

    std::sort(m_barrelLayerPositions.begin(), m_barrelLayerPositions.end());
    std::sort(m_endCapLayerPositions.begin(), m_endCapLayerPositions.end());

    LayerPositionList::const_iterator barrelIter = std::unique(m_barrelLayerPositions.begin(), m_barrelLayerPositions.end());
    LayerPositionList::const_iterator endcapIter = std::unique(m_endCapLayerPositions.begin(), m_endCapLayerPositions.end());

    if ((m_barrelLayerPositions.end() != barrelIter) || (m_endCapLayerPositions.end() != endcapIter))
    {
      std::cout << "APRILPseudoLayerPlugin: Duplicate layer position detected." << std::endl;
      throw pandora::StatusCodeException(pandora::STATUS_CODE_FAILURE);
    }
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  void APRILPseudoLayerPlugin::StoreLayerPositions(const pandora::SubDetector &subDetector, LayerPositionList &layerPositionList)
  {
    if (!subDetector.IsMirroredInZ())
    {
      std::cout << "APRILPseudoLayerPlugin: Error, detector must be symmetrical about z=0 plane." << std::endl;
      throw pandora::StatusCodeException(pandora::STATUS_CODE_INVALID_PARAMETER);
    }

    const pandora::SubDetector::SubDetectorLayerVector &subDetectorLayerList(subDetector.GetSubDetectorLayerVector());

    for (pandora::SubDetector::SubDetectorLayerVector::const_iterator iter = subDetectorLayerList.begin(), iterEnd = subDetectorLayerList.end(); iter != iterEnd; ++iter)
    {
      layerPositionList.push_back(iter->GetClosestDistanceToIp());
    }
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  void APRILPseudoLayerPlugin::StoreDetectorOuterEdge()
  {
    const pandora::GeometryManager *const pGeometryManager(this->GetPandora().GetGeometry());

    m_barrelEdgeR = (std::max(pGeometryManager->GetSubDetector(pandora::ECAL_BARREL).GetOuterRCoordinate(), std::max(
        pGeometryManager->GetSubDetector(pandora::HCAL_BARREL).GetOuterRCoordinate(),
        pGeometryManager->GetSubDetector(pandora::MUON_BARREL).GetOuterRCoordinate()) ));

    m_endCapEdgeZ = (std::max(std::fabs(pGeometryManager->GetSubDetector(pandora::ECAL_ENDCAP).GetOuterZCoordinate()), std::max(
        std::fabs(pGeometryManager->GetSubDetector(pandora::HCAL_ENDCAP).GetOuterZCoordinate()),
        std::fabs(pGeometryManager->GetSubDetector(pandora::MUON_ENDCAP).GetOuterZCoordinate())) ));

    if ((m_barrelLayerPositions.end() != std::upper_bound(m_barrelLayerPositions.begin(), m_barrelLayerPositions.end(), m_barrelEdgeR)) ||
        (m_endCapLayerPositions.end() != std::upper_bound(m_endCapLayerPositions.begin(), m_endCapLayerPositions.end(), m_endCapEdgeZ)))
    {
      std::cout << "APRILPseudoLayerPlugin: Layers specified outside detector edge." << std::endl;
      throw pandora::StatusCodeException(pandora::STATUS_CODE_FAILURE);
    }

    m_barrelLayerPositions.push_back(m_barrelEdgeR);
    m_endCapLayerPositions.push_back(m_endCapEdgeZ);
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  void APRILPseudoLayerPlugin::StorePolygonAngles()
  {
    const pandora::GeometryManager *const pGeometryManager(this->GetPandora().GetGeometry());

    this->FillAngleVector(pGeometryManager->GetSubDetector(pandora::ECAL_BARREL).GetInnerSymmetryOrder(),
        pGeometryManager->GetSubDetector(pandora::ECAL_BARREL).GetInnerPhiCoordinate(), m_eCalBarrelAngleVector);

    this->FillAngleVector(pGeometryManager->GetSubDetector(pandora::MUON_BARREL).GetInnerSymmetryOrder(),
        pGeometryManager->GetSubDetector(pandora::MUON_BARREL).GetInnerPhiCoordinate(), m_muonBarrelAngleVector);
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  void APRILPseudoLayerPlugin::StoreOverlapCorrectionDetails()
  {
    const pandora::GeometryManager *const pGeometryManager(this->GetPandora().GetGeometry());

    m_barrelInnerR = pGeometryManager->GetSubDetector(pandora::ECAL_BARREL).GetInnerRCoordinate();
    m_endCapInnerZ = std::fabs(pGeometryManager->GetSubDetector(pandora::ECAL_ENDCAP).GetInnerZCoordinate());
    m_barrelInnerRMuon = pGeometryManager->GetSubDetector(pandora::MUON_BARREL).GetInnerRCoordinate();
    m_endCapInnerZMuon = std::fabs(pGeometryManager->GetSubDetector(pandora::MUON_ENDCAP).GetInnerZCoordinate());

    const float barrelOuterZ = std::fabs(pGeometryManager->GetSubDetector(pandora::ECAL_BARREL).GetOuterZCoordinate());
    const float endCapOuterR = pGeometryManager->GetSubDetector(pandora::ECAL_ENDCAP).GetOuterRCoordinate();
    const float barrelOuterZMuon = std::fabs(pGeometryManager->GetSubDetector(pandora::MUON_BARREL).GetOuterZCoordinate());
    const float endCapOuterRMuon = pGeometryManager->GetSubDetector(pandora::MUON_ENDCAP).GetOuterRCoordinate();

    const bool IsEnclosingEndCap(endCapOuterR > m_barrelInnerR); // true for ILD !
    m_rCorrection = ((!IsEnclosingEndCap) ? 0.f : m_barrelInnerR * ((m_endCapInnerZ / barrelOuterZ) - 1.f));
    m_zCorrection = ((IsEnclosingEndCap) ? 0.f : m_endCapInnerZ * ((m_barrelInnerR / endCapOuterR) - 1.f));
    m_rCorrectionMuon = ((!IsEnclosingEndCap) ? 0.f : m_barrelInnerRMuon * ((m_endCapInnerZMuon / barrelOuterZMuon) - 1.f));
    m_zCorrectionMuon = ((IsEnclosingEndCap) ? 0.f : m_endCapInnerZMuon * ((m_barrelInnerRMuon / endCapOuterRMuon) - 1.f));
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  float APRILPseudoLayerPlugin::GetMaximumRadius(const AngleVector &angleVector, const float x, const float y) const
  {
    if (angleVector.size() <= 2)
      return std::sqrt((x * x) + (y * y));

    float maxRadius(0.);
    for (AngleVector::const_iterator iter = angleVector.begin(), iterEnd = angleVector.end(); iter != iterEnd; ++iter)
    {
      const float radius((x * iter->first) + (y * iter->second));

      if (radius > maxRadius)
        maxRadius = radius;
    }

    return maxRadius;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  void APRILPseudoLayerPlugin::FillAngleVector(const unsigned int symmetryOrder, const float phi0, AngleVector &angleVector) const
  {
    const float twoPi = static_cast<float>(2. * std::acos(-1.));
    angleVector.clear();

    for (unsigned int iSymmetry = 0; iSymmetry < symmetryOrder; ++iSymmetry)
    {
      const float phi = phi0 + ((twoPi * static_cast<float>(iSymmetry)) / static_cast<float>(symmetryOrder));
      angleVector.push_back(std::make_pair(std::cos(phi), std::sin(phi)));
    }
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode APRILPseudoLayerPlugin::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    m_useCoordinateCorrections = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "UseCoordinateCorrections", m_useCoordinateCorrections));

    return pandora::STATUS_CODE_SUCCESS;
  }

}
