/// \file ClusterEfficiencyAlgorithm.cc
/*
 *
 * ClusterEfficiencyAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. juin 2 2016
 *
 * This file is part of APRILContent libraries.
 * 
 * APRILContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * APRILContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with APRILContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "APRILUtility/ClusterEfficiencyAlgorithm.h"

#include "Pandora/AlgorithmHeaders.h"
#include "APRILApi/APRILContentApi.h"
#include "APRILObjects/CaloHit.h"
#include "APRILHelpers/GeometryHelper.h"
#include "APRILHelpers/ReclusterHelper.h"

#include "APRILHelpers/HistogramHelper.h"
using namespace pandora;

namespace april_content
{

  pandora::StatusCode ClusterEfficiencyAlgorithm::Run()
  {
	////////
    const pandora::PfoList *pPfoList = NULL; 
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pPfoList));
	std::cout << "------- # PFO : " << pPfoList->size() << std::endl;

	std::map<const pandora::MCParticle* const, pandora::CaloHitList> mcpCaloHitListMap;
	std::map<const pandora::MCParticle* const, pandora::ClusterList> mcpClusterListMap;

    for(pandora::PfoList::const_iterator iter = pPfoList->begin(), endIter = pPfoList->end(); endIter != iter ; ++iter)
    {
		const pandora::ParticleFlowObject* pfo = *iter;
		//std::cout << "PFO : " << pfo << ", PID: " << pfoPID << ", charge: " << pfoCharge << std::endl;

		const pandora::ClusterList& pfoClusterList = pfo->GetClusterList();
    
		for(pandora::ClusterList::const_iterator cluIter = pfoClusterList.begin(); cluIter != pfoClusterList.end(); ++cluIter)
		{
			const pandora::Cluster* pfoCluster = *cluIter;

			const pandora::MCParticle* pMCClusterParticle = NULL;
	  
			try 
			{
				pMCClusterParticle = pandora::MCParticleHelper::GetMainMCParticle(pfoCluster);
			}
    		catch (pandora::StatusCodeException &)
			{
				continue;
			}

			// make MCP and cluster relationship
			if(pMCClusterParticle != NULL && mcpClusterListMap.find(pMCClusterParticle) == mcpClusterListMap.end())
			{
				pandora::ClusterList cluList;
				cluList.push_back( pfoCluster );
				mcpClusterListMap[pMCClusterParticle] = cluList;
			}
			else
			{
				mcpClusterListMap[pMCClusterParticle].push_back( pfoCluster );
			}

			// make MCP and hit relationship
	        pandora::CaloHitList caloHitList;
	        pfoCluster->GetOrderedCaloHitList().FillCaloHitList(caloHitList);

            for(pandora::CaloHitList::const_iterator caloHitIter = caloHitList.begin(); caloHitIter != caloHitList.end(); ++caloHitIter)
            {
               const pandora::CaloHit* caloHit = *caloHitIter;
			   const pandora::MCParticle* pMCHitParticle  = NULL;

               try
               {
               	 pMCHitParticle = pandora::MCParticleHelper::GetMainMCParticle(caloHit);
               	//std::cout << "calo hit: " << caloHit << ", mcp: " << pMCHitParticle << std::endl;
               }
               catch (pandora::StatusCodeException &)
               {
				   continue;
               }

			   if(pMCHitParticle != NULL && mcpCaloHitListMap.find( pMCHitParticle ) == mcpCaloHitListMap.end())
			   {
				   pandora::CaloHitList hitList;
				   hitList.push_back( caloHit );
				   mcpCaloHitListMap[pMCHitParticle] = hitList;
			   }
			   else
			   {
				   mcpCaloHitListMap[pMCHitParticle].push_back( caloHit );
			   }
	        }
		} // for each cluster
	} // for each pfo

	// consider hit not usd in clusters
#if 1
    const pandora::CaloHitList *pCaloHitList = NULL; 
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pCaloHitList));
	std::cout << "------- # CaloHit : " << pCaloHitList->size() << std::endl;

    for(pandora::CaloHitList::const_iterator iter = pCaloHitList->begin(); iter != pCaloHitList->end(); ++iter)
	{
		const pandora::CaloHit* const pCaloHit = *iter;

        if (PandoraContentApi::IsAvailable(*this, pCaloHit))
		{
		   const pandora::MCParticle* pMCHitParticle  = NULL;

           try
           {
           	 pMCHitParticle = pandora::MCParticleHelper::GetMainMCParticle(pCaloHit);
           	//std::cout << "calo hit: " << caloHit << ", mcp: " << pMCHitParticle << std::endl;
           }
           catch (pandora::StatusCodeException &)
           {
		       continue;
           }

		   if(pMCHitParticle != NULL && mcpCaloHitListMap.find( pMCHitParticle ) == mcpCaloHitListMap.end())
		   {
		       pandora::CaloHitList hitList;
		       hitList.push_back( pCaloHit );
		       mcpCaloHitListMap[pMCHitParticle] = hitList;
		   }
		   else
		   {
		       mcpCaloHitListMap[pMCHitParticle].push_back( pCaloHit );
		   }
		}
	}
#endif

	/////////////

	for(auto it = mcpCaloHitListMap.begin(); it != mcpCaloHitListMap.end(); ++it)
	{
		auto mcp = it->first;

	    // all the hits belong to the mcp based on the MC information
		auto mcpHitList = it->second;

		// all the clusters which has the main mcp 
		auto clusterList = mcpClusterListMap[mcp];
		// the hits from the clusters above
		pandora::CaloHitList clusterHitList;

		float siblingClusterNumber = 0;

		for(auto cluListIt = clusterList.begin(); cluListIt != clusterList.end(); ++cluListIt)
		{
			auto pCluster = *cluListIt;

			pandora::CaloHitList caloHitList;
			pCluster->GetOrderedCaloHitList().FillCaloHitList(caloHitList);

			if(caloHitList.size()>0) ++siblingClusterNumber;

            for(pandora::CaloHitList::const_iterator caloHitIter = caloHitList.begin();
				caloHitIter != caloHitList.end(); ++caloHitIter)
            {
               const pandora::CaloHit* caloHit = *caloHitIter;

			   clusterHitList.push_back( caloHit );
	        }
		}

		--siblingClusterNumber;

		float clusterEnergy = 0.;
		float collectedEnergy = 0.;
		float clusterSize = 0.;
		float collectedHitSize = 0.;
		
		for(auto hitIt = mcpHitList.begin(); hitIt != mcpHitList.end(); ++hitIt)
		{
			auto hit = *hitIt;

			float hitEnergy = hit->GetHadronicEnergy();
			clusterEnergy += hitEnergy;

			++clusterSize;

			if( std::find( clusterHitList.begin(), clusterHitList.end(), *hitIt ) != clusterHitList.end() )
			{
				collectedEnergy += hitEnergy;
				++collectedHitSize;
			}
		}

		float pid = mcp->GetParticleId();
		float clusterCharge = pandora::PdgTable::GetParticleCharge(mcp->GetParticleId());

	    std::vector<float> vars;
	    vars.push_back( clusterSize );
	    vars.push_back( pid );
		vars.push_back( clusterCharge );
	    vars.push_back( clusterEnergy );
	    vars.push_back( collectedHitSize/clusterSize );
	    vars.push_back( collectedEnergy/clusterEnergy );
	    vars.push_back( siblingClusterNumber );
	
		HistogramManager::CreateFill("ClusterEfficiency", 
				"clusterSize:pid:clusterCharge:clusterEnergy:clusterSizeEfficiency:clusterEnergyEfficiency:siblingClusterNumber", vars);
	}

    return pandora::STATUS_CODE_SUCCESS;
  }

  pandora::StatusCode ClusterEfficiencyAlgorithm::Initialize()
  {
	  return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterEfficiencyAlgorithm::ReadSettings(const pandora::TiXmlHandle /* xmlHandle */)
  {
    return pandora::STATUS_CODE_SUCCESS;
  }

}
