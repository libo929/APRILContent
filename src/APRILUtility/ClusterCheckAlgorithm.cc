/// \file ClusterCheckAlgorithm.cc
/*
 *
 * ClusterCheckAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. juin 2 2016
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "ArborUtility/ClusterCheckAlgorithm.h"

#include "Pandora/AlgorithmHeaders.h"
#include "ArborApi/ArborContentApi.h"
#include "ArborObjects/CaloHit.h"
#include "ArborHelpers/GeometryHelper.h"
#include "ArborHelpers/ReclusterHelper.h"


namespace arbor_content
{

  pandora::StatusCode ClusterCheckAlgorithm::Run()
  {
    const pandora::ClusterList *pClusterList = NULL;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));

	std::cout << "  ---> Cluster list size: " << pClusterList->size() << std::endl;

    for(pandora::ClusterList::const_iterator iter = pClusterList->begin(), endIter = pClusterList->end() ;
        endIter != iter ; ++iter)
    {
		const pandora::Cluster* cluster = *iter;
		const pandora::TrackList& trackList = cluster->GetAssociatedTrackList();

        //unsigned int nTrackAssociations(trackList.size());
        //if((nTrackAssociations < m_minTrackAssociations) || (nTrackAssociations > m_maxTrackAssociations)) return false;

        float trackEnergySum(0.);

        for (pandora::TrackList::const_iterator trackIter = trackList.begin(), trackIterEnd = trackList.end(); 
            trackIter != trackIterEnd; ++trackIter)
        {   
          trackEnergySum += (*trackIter)->GetEnergyAtDca();
        }   

        if(trackEnergySum < 1.) continue;

        const float chi(ReclusterHelper::GetTrackClusterCompatibility(this->GetPandora(), cluster, trackList));

		if(std::fabs(chi)>2) {
			std::cout << "chi: " << chi << ", cluster energy: " << cluster->GetHadronicEnergy() 
				      << ", track E: " << trackEnergySum << std::endl; 
		}

		//if(trackList.size()>0)
		//std::cout << "cluster E: " << cluster->GetHadronicEnergy() << ", track E: " << trackEnergy << std::endl;
	}

#if 1
	/////////////////////////
	// check tracks in PFOs
    const pandora::PfoList *pPfoList = NULL; 
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pPfoList));

    for(pandora::PfoList::const_iterator iter = pPfoList->begin(), endIter = pPfoList->end(); endIter != iter ; ++iter)
    {
		const pandora::ParticleFlowObject* pfo = *iter;

		const pandora::TrackList& pfoTrackList = pfo->GetTrackList();
		const pandora::ClusterList& pfoClusterList = pfo->GetClusterList();

		float clustersEnergy = 0.;
		float tracksEnergy = 0.;

		for(pandora::TrackList::const_iterator trackIter = pfoTrackList.begin(); trackIter != pfoTrackList.end(); ++trackIter)
		{
			const pandora::Track* track = *trackIter;
			float trackEnergy = track->GetEnergyAtDca();

			tracksEnergy += trackEnergy;
		}

		for(pandora::ClusterList::const_iterator clusterIter = pfoClusterList.begin(); clusterIter != pfoClusterList.end(); ++clusterIter)
		{
			const pandora::Cluster* cluster = *clusterIter;
			float clusterEnergy = cluster->GetHadronicEnergy();

			clustersEnergy += clusterEnergy;
		}
#if 1

		//const float chi(ReclusterHelper::GetTrackClusterCompatibility(this->GetPandora(), clustersEnergy, tracksEnergy));
		//if(fabs(chi)>2) 
		std::cout << "=======> track - cluster energy: " << tracksEnergy << " : " << clustersEnergy << std::endl;
#endif
	}
#endif

    return pandora::STATUS_CODE_SUCCESS;
  }


  pandora::StatusCode ClusterCheckAlgorithm::Initialize()
  {
      //std::cout << "timing:  "   << m_timing  << std::endl;
      //std::cout << "time cut:  " << m_timeCut << std::endl;
      
	  //std::cout << "********* ClusterCheckAlgorithm init ********" << std::endl;
    
	  return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterCheckAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
	m_timing = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "ApplyTiming", m_timing));

    m_timeCut = 100.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "TimeCut", m_timeCut));

    return pandora::STATUS_CODE_SUCCESS;
  }

} 
