/// \file APRILMetaData.cc
/*
 *
 * APRILMetaData.cc source template automatically generated by a class generator
 * Creation date : sam. mars 21 2015
 *
 * This file is part of APRILContent libraries.
 * 
 * APRILContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * APRILContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with APRILContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "APRILObjects/APRILMetaData.h"
#include "APRILObjects/CaloHit.h"
#include "APRILObjects/Connector.h"
#include "APRILApi/APRILContentApi.h"

namespace april_content
{

  CaloHitMetaData::CaloHitMetaData(april_content::CaloHit *const pCaloHit) :
    m_pCaloHit(pCaloHit),
    m_isLeaf(true),
    m_isSeed(true)
  {
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  CaloHitMetaData::~CaloHitMetaData()
  {
    PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->RemoveAllConnections());
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  const april_content::CaloHit *CaloHitMetaData::GetCaloHit() const
  {
    return m_pCaloHit;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  bool CaloHitMetaData::IsConnected(const april_content::CaloHit *const pCaloHit) const
  {
    for(ConnectorList::const_iterator iter = m_allConnectorList.begin(), endIter = m_allConnectorList.end() ;
        endIter != iter ; ++iter)
    {
      const Connector *const pConnector = *iter;

      if(pConnector->GetFrom() == pCaloHit || pConnector->GetTo() == pCaloHit)
        return true;
    }

    return false;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  bool CaloHitMetaData::IsConnected(const april_content::CaloHit *const pCaloHit, ConnectorDirection direction) const
  {
    ConnectorList::const_iterator beginIterator	= BACKWARD_DIRECTION == direction ? m_backwardConnectorList.begin() : m_forwardConnectorList.begin();
    ConnectorList::const_iterator endIterator	= BACKWARD_DIRECTION == direction ? m_backwardConnectorList.end() : m_forwardConnectorList.end();

    for(ConnectorList::const_iterator iter = beginIterator, endIter = endIterator ;
        endIter != iter ; ++iter)
    {
      const Connector *const pConnector = *iter;

      if(pConnector->GetFrom() == pCaloHit || pConnector->GetTo() == pCaloHit)
        return true;
    }

    return false;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode CaloHitMetaData::RemoveConnector(const Connector *const pConnector)
  {
    if(pConnector->GetTo() != m_pCaloHit && pConnector->GetFrom() != m_pCaloHit)
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    if(m_allConnectorList.erase(pConnector) != 1)
      return pandora::STATUS_CODE_FAILURE;

    if(pConnector->GetTo() == m_pCaloHit)
    {
      if(m_backwardConnectorList.erase(pConnector) != 1)
        return pandora::STATUS_CODE_FAILURE;

      if(m_backwardConnectorList.empty())
        m_isSeed = true;
    }
    else
    {
      if(m_forwardConnectorList.erase(pConnector) != 1)
        return pandora::STATUS_CODE_FAILURE;

      if(m_forwardConnectorList.empty())
        m_isLeaf = true;
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode CaloHitMetaData::RemoveAllConnections()
  {
    m_allConnectorList.clear();
    m_backwardConnectorList.clear();
    m_forwardConnectorList.clear();
    m_isSeed = true;
    m_isLeaf = true;

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode CaloHitMetaData::FindConnector(const april_content::CaloHit *const pCaloHit, const Connector *&pConnector) const
  {
    pConnector = NULL;

    for(ConnectorList::const_iterator iter = m_allConnectorList.begin(), endIter = m_allConnectorList.end() ;
        endIter != iter ; ++iter)
    {
      if((*iter)->GetFrom() == pCaloHit || (*iter)->GetTo() == pCaloHit)
      {
        pConnector = *iter;

        return pandora::STATUS_CODE_SUCCESS;
      }
    }

    return pandora::STATUS_CODE_NOT_FOUND;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode CaloHitMetaData::FindConnector(const april_content::CaloHit *const pCaloHit, ConnectorDirection direction,
      const Connector *&pConnector) const
  {
    pConnector = NULL;

    ConnectorList::const_iterator beginIterator	= BACKWARD_DIRECTION == direction ? m_backwardConnectorList.begin() : m_forwardConnectorList.begin();
    ConnectorList::const_iterator endIterator	= BACKWARD_DIRECTION == direction ? m_backwardConnectorList.end() : m_forwardConnectorList.end();

    for(ConnectorList::const_iterator iter = beginIterator, endIter = endIterator ;
        endIter != iter ; ++iter)
    {
      if((*iter)->GetFrom() == pCaloHit || (*iter)->GetTo() == pCaloHit)
      {
        pConnector = *iter;

        return pandora::STATUS_CODE_SUCCESS;
      }
    }

    return pandora::STATUS_CODE_NOT_FOUND;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  bool CaloHitMetaData::HasAnyConnection() const
  {
    return !(m_allConnectorList.empty());
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  const ConnectorList &CaloHitMetaData::GetConnectorList() const
  {
    return m_allConnectorList;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  const ConnectorList &CaloHitMetaData::GetConnectorList(ConnectorDirection direction) const
  {
    return BACKWARD_DIRECTION == direction ? m_backwardConnectorList : m_forwardConnectorList;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  bool CaloHitMetaData::IsSeed() const
  {
    return m_isSeed;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  bool CaloHitMetaData::IsLeaf() const
  {
    return m_isLeaf;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode CaloHitMetaData::AddConnector(const Connector *const pConnector, ConnectorDirection direction)
  {
    if(!m_allConnectorList.insert(pConnector).second)
      return pandora::STATUS_CODE_FAILURE;

    bool inserted = direction == BACKWARD_DIRECTION ?
        m_backwardConnectorList.insert(pConnector).second : m_forwardConnectorList.insert(pConnector).second;

    if(!inserted)
    {
      m_allConnectorList.erase(pConnector);
      return pandora::STATUS_CODE_FAILURE;
    }

    if(BACKWARD_DIRECTION == direction)
      m_isSeed = false;
    else
      m_isLeaf = false;

    return pandora::STATUS_CODE_SUCCESS;
  }

} 
