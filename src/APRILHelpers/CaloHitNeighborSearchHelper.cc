/// \file CaloHitNeighborSearchHelper.cc
/*
 *
 * CaloHitNeighborSearchHelper.cc source template automatically generated by a class generator
 * Creation date : lun. mars 30 2015
 *
 * This file is part of APRILContent libraries.
 * 
 * APRILContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * APRILContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with APRILContent.  If not, see <http://www.gnu.org/licenses/>.
 &* 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "Api/PandoraContentApi.h"
#include "Objects/OrderedCaloHitList.h"
#include "APRILHelpers/CaloHitNeighborSearchHelper.h"
#include "APRILApi/APRILContentApi.h"
#include "APRILObjects/CaloHit.h"

//#define __DEBUG__ 


using namespace mlpack;
using namespace mlpack::math;

namespace april_content
{
	arma::mat CaloHitNeighborSearchHelper::m_caloHitsMatrix(3,1);
	arma::mat CaloHitNeighborSearchHelper::m_caloHitsMatrix4D(4,1);
	const pandora::CaloHitList* CaloHitNeighborSearchHelper::m_pCaloHitList(nullptr);
	pandora::CaloHitVector CaloHitNeighborSearchHelper::m_caloHitVector;
	mlpack::neighbor::KNN CaloHitNeighborSearchHelper::m_neighborSearch(m_caloHitsMatrix);
	CaloKNN CaloHitNeighborSearchHelper::m_neighborSearch4D(m_caloHitsMatrix4D);
	CaloDBSCAN CaloHitNeighborSearchHelper::m_caloDBSCAN(20., 4);

  //--------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode CaloHitNeighborSearchHelper::FillMatixFromCaloHits(const pandora::CaloHitVector& caloHitVector, arma::mat& caloHitsMatrix)
  {
      arma::mat matrix(3, 1);

	  // first hit 
	  pandora::CartesianVector caloHitPosition0 = caloHitVector.at(0)->GetPositionVector();
	  matrix.col(0) = arma::vec( { caloHitPosition0.GetX(), caloHitPosition0.GetY(), caloHitPosition0.GetZ() } );

	  // other hits
	  //std::cout << "caloHitVector.size : " << caloHitVector.size() << std::endl;
	  matrix.insert_cols(1, caloHitVector.size() - 1); 

	  for(int i = 1; i < caloHitVector.size(); ++i)
	  {
	      pandora::CartesianVector caloHitPosition = caloHitVector.at(i)->GetPositionVector();
	      matrix.col(i) = arma::vec( { caloHitPosition.GetX(), caloHitPosition.GetY(), caloHitPosition.GetZ() } );
	  }

	  caloHitsMatrix = matrix;
	  
	  return pandora::STATUS_CODE_SUCCESS;
  }

  //--------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode CaloHitNeighborSearchHelper::FillMatix4DFromCaloHits(const pandora::CaloHitVector& caloHitVector, arma::mat& caloHitsMatrix4D)
  {
      arma::mat matrix4D(4, 1);

	  // first hit 
	  pandora::CartesianVector caloHitPosition0 = caloHitVector.at(0)->GetPositionVector();
	  matrix4D.col(0) = arma::vec( { caloHitPosition0.GetX(), caloHitPosition0.GetY(), caloHitPosition0.GetZ(), 
			  (float)caloHitVector.at(0)->GetPseudoLayer() } );

	  // other hits
	  //std::cout << "caloHitVector.size : " << caloHitVector.size() << std::endl;
	  matrix4D.insert_cols(1, caloHitVector.size() - 1); 

	  for(int i = 1; i < caloHitVector.size(); ++i)
	  {
	      pandora::CartesianVector caloHitPosition = caloHitVector.at(i)->GetPositionVector();
	      matrix4D.col(i) = arma::vec( { caloHitPosition.GetX(), caloHitPosition.GetY(), caloHitPosition.GetZ(),
				 (float)caloHitVector.at(i)->GetPseudoLayer() } );
	  }

	  caloHitsMatrix4D = matrix4D;
	  
	  return pandora::STATUS_CODE_SUCCESS;
  }

  //--------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode CaloHitNeighborSearchHelper::BuildNeighborSearch(const pandora::CaloHitList *const pCaloHitList)
  {
	  if(pCaloHitList != m_pCaloHitList)
	  {
		  //std::cout << "build new matrix for NeighborSearch..." << std::endl;
		  m_caloHitVector.clear();
	      m_caloHitVector.insert(m_caloHitVector.begin(), pCaloHitList->begin(), pCaloHitList->end());

		  FillMatixFromCaloHits(m_caloHitVector, m_caloHitsMatrix);

	      // the relatively time-comsuming part
	      m_neighborSearch.Train(m_caloHitsMatrix);

		  m_pCaloHitList = pCaloHitList;
	  }

	  return pandora::STATUS_CODE_SUCCESS;
  }

  //--------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode CaloHitNeighborSearchHelper::SearchNeighbourHits(pandora::CartesianVector testPosition, int nNeighbor, 
		  pandora::CaloHitList& neighborHits)
  {
	  neighborHits.clear();

	  /////
      arma::mat testPoint(3, 1);

	  testPoint.col(0)[0] = testPosition.GetX();
	  testPoint.col(0)[1] = testPosition.GetY();
	  testPoint.col(0)[2] = testPosition.GetZ();

	  //std::cout << "point: " << testPoint.col(0)[0] << ", " << testPoint.col(0)[1] << ", " << testPoint.col(0)[2] << std::endl;

	  arma::Mat<size_t> resultingNeighbors;
	  arma::mat resultingDistances;

      m_neighborSearch.Search(testPoint, nNeighbor, resultingNeighbors, resultingDistances);

      for(size_t j=0; j < resultingNeighbors.n_elem; ++j)
      {
      	size_t neighbor = resultingNeighbors[j];

#if 0
      	double hitsDist = resultingDistances[j];

   	    auto posVec = m_caloHitVector.at(neighbor)->GetPositionVector();
   
      	std::cout <<  "    -> neighbor " << neighbor << ", hits distance: " << hitsDist 
   	  	 << ", X = " << posVec.GetX() << ", " << posVec.GetY() << ", " << posVec.GetZ() << std::endl;
#endif

		neighborHits.push_back( m_caloHitVector.at(neighbor) );
      }

   	  return pandora::STATUS_CODE_SUCCESS;
  }

  //--------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode CaloHitNeighborSearchHelper::BuildCaloNeighborSearch(const pandora::CaloHitVector& caloHitVector)
  {
	  FillMatix4DFromCaloHits(caloHitVector, m_caloHitsMatrix4D);
	  
	  //std::cout << "FillMatixFromCaloHits done " << std::endl;
	  m_neighborSearch4D.Train(m_caloHitsMatrix);
	  //std::cout << "m_neighborSearch.Train done " << std::endl;

   	  return pandora::STATUS_CODE_SUCCESS;
  }

  //--------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode CaloHitNeighborSearchHelper::SearchNeighbourHits4D(std::vector<float> testPosition, int nNeighbor, pandora::CaloHitList& neighborHits)
  {
	  neighborHits.clear();

	  /////
      arma::mat testPoint(4, 1);

	  testPoint.col(0)[0] = testPosition.at(0);
	  testPoint.col(0)[1] = testPosition.at(1);
	  testPoint.col(0)[2] = testPosition.at(2);
	  testPoint.col(0)[3] = testPosition.at(3);

	  //std::cout << " --- point: " << testPoint.col(0)[0] << ", " << testPoint.col(0)[1] << ", " << testPoint.col(0)[2] 
		//  << ", " << testPoint.col(0)[3] << std::endl;

	  arma::Mat<size_t> resultingNeighbors;
	  arma::mat resultingDistances;

      m_neighborSearch4D.Search(testPoint, nNeighbor, resultingNeighbors, resultingDistances);

      for(size_t j=0; j < resultingNeighbors.n_elem; ++j)
      {
      	size_t neighbor = resultingNeighbors[j];

#if 0
      	double hitsDist = resultingDistances[j];

   	    auto posVec = m_caloHitVector.at(neighbor)->GetPositionVector();
   
      	std::cout <<  "    -> neighbor " << neighbor << ", hits distance: " << hitsDist 
   	  	 << ", X = " << posVec.GetX() << ", " << posVec.GetY() << ", " << posVec.GetZ() << std::endl;
#endif

		neighborHits.push_back( m_caloHitVector.at(neighbor) );
      }

   	  return pandora::STATUS_CODE_SUCCESS;
  }

  //--------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode CaloHitNeighborSearchHelper::ClusteringByDBSCAN(const pandora::CaloHitVector& caloHitVector, 
		  std::vector<pandora::CaloHitVector>& hitsForCluster, float eps, int minPoints)
  {
	  MLPACKDBSCAN dbscan(eps, minPoints);

	  arma::mat caloHitsMatrix;

      FillMatixFromCaloHits(caloHitVector, caloHitsMatrix);

	  arma::Row< size_t > clu;
	  dbscan.Cluster(caloHitsMatrix, clu);

	  hitsForCluster.clear();
	  hitsForCluster.resize(clu.size());

	  unsigned long noCluster = (unsigned long)-1;

	  int nClusters = 0;

	  for(int i = 0; i < clu.size(); ++i)
      {   
		  unsigned long cluIndex = (unsigned long)clu[i];
		  auto caloHit = caloHitVector.at(i);

          if (cluIndex != noCluster)
          {
			  hitsForCluster.at(cluIndex).push_back(caloHit);

#ifdef __DEBUG__
		      auto hitPos = caloHit->GetPositionVector();
		      auto layer = caloHit->GetPseudoLayer();

              std::cout << " --- " << i << ": " << clu[i] << ", caloHit: " << caloHit 
				  << ", X: " << hitPos.GetX() << ", " << hitPos.GetY() << ", " << hitPos.GetZ() << ", layer: " << layer << std::endl;
#endif

			  if(cluIndex >= nClusters) ++nClusters;
          }
          else
          {
#ifdef __DEBUG__
              std::cout << " --- " << i << ": " << "no cluster, caloHit: " << caloHit 
				  << ", X: " << hitPos.GetX() << ", " << hitPos.GetY() << ", " << hitPos.GetZ() << ", layer: " << layer << std::endl;
#endif
          }
      }

	
#ifdef __DEBUG__
	  std::cout << "nCluster: " << nClusters << std::endl;
#endif

	  hitsForCluster.resize(nClusters);
 
   	  return pandora::STATUS_CODE_SUCCESS;
  }

  //--------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode CaloHitNeighborSearchHelper::ClusteringByDBSCAN4D(const pandora::CaloHitVector& caloHitVector, 
		  std::vector<pandora::CaloHitVector>& hitsForCluster, float eps, int minPoints)
  {
	  CaloDBSCAN caloDBSCAN(eps, minPoints);

	  arma::mat caloHitsMatrix4D;

      FillMatix4DFromCaloHits(caloHitVector, caloHitsMatrix4D);

	  arma::Row< size_t > clu;
	  caloDBSCAN.Cluster(caloHitsMatrix4D, clu);

	  hitsForCluster.clear();
	  hitsForCluster.resize(clu.size());

	  unsigned long noCluster = (unsigned long)-1;

	  int nClusters = 0;

	  for(int i = 0; i < clu.size(); ++i)
      {   
		  unsigned long cluIndex = (unsigned long)clu[i];
		  auto caloHit = caloHitVector.at(i);

          if (cluIndex != noCluster)
          {

			  hitsForCluster.at(cluIndex).push_back(caloHit);
#ifdef __DEBUG__
		      auto hitPos = caloHit->GetPositionVector();
		      auto layer = caloHit->GetPseudoLayer();

              std::cout << " --- " << i << ": " << clu[i] << ", caloHit: " << caloHit 
				  << ", X: " << hitPos.GetX() << ", " << hitPos.GetY() << ", " << hitPos.GetZ() << ", layer: " << layer << std::endl;
#endif

			  if(cluIndex >= nClusters) ++nClusters;
          }
          else
          {
#ifdef __DEBUG__
              std::cout << " --- " << i << ": " << "no cluster, caloHit: " << caloHit 
				  << ", X: " << hitPos.GetX() << ", " << hitPos.GetY() << ", " << hitPos.GetZ() << ", layer: " << layer << std::endl;
#endif
          }
      }

#ifdef __DEBUG__
	  std::cout << "nCluster: " << nClusters << std::endl;
#endif

	  hitsForCluster.resize(nClusters);
 
   	  return pandora::STATUS_CODE_SUCCESS;
  }

}
