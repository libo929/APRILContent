/// \file FragmentsFindingAlgorithm.cc
/*
 *
 * FragmentsFindingAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. juin 30 2016
 *
 * This file is part of APRILContent libraries.
 * 
 * APRILContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * APRILContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with APRILContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "APRILTopologicalAssociation/FragmentsFindingAlgorithm.h"

#include "Pandora/AlgorithmHeaders.h"
#include "APRILUtility/EventPreparationAlgorithm.h"

#include "APRILHelpers/SortingHelper.h"
#include "APRILHelpers/GeometryHelper.h"
#include "APRILHelpers/ReclusterHelper.h"
#include "APRILHelpers/ClusterHelper.h"
#include "APRILHelpers/CaloHitHelper.h"
#include "APRILTools/CaloHitMergingTool.h"
#include "APRILHelpers/HistogramHelper.h"

namespace april_content
{

  pandora::StatusCode FragmentsFindingAlgorithm::Run()
  {
	std::cout << "======= FragmentsFindingAlgorithm ====== " << std::endl;

    // find fragments 
    pandora::ClusterVector fragmentClusterVector;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->FindClusterFragments(fragmentClusterVector));

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode FragmentsFindingAlgorithm::FindClusterFragments(pandora::ClusterVector &fragmentClusterVector) const
  {
    const pandora::ClusterList *pClusterList = NULL;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));

    if(pClusterList->empty())
      return pandora::STATUS_CODE_SUCCESS;

    pandora::ClusterVector clusterVector(pClusterList->begin(), pClusterList->end());
    fragmentClusterVector.clear();

    // loop over clusters and identify fragments
    for(pandora::ClusterVector::iterator clusterIter = clusterVector.begin(), clusterEndIter = clusterVector.end() ;
        clusterEndIter != clusterIter ; ++clusterIter)
    {
      const pandora::Cluster *const pCluster(*clusterIter);
	  float hadEnergy = pCluster->GetHadronicEnergy();
	  int clusterPID = -1e6;
	  int clusterMCPCharge = -1000;
	  float averageTime = -1.;

	  if(hadEnergy < m_minFragmentClusterEnergy || hadEnergy > m_maxEnergyNonFragments) continue;

	  try
	  {
		 auto pClusterMCParticle = pandora::MCParticleHelper::GetMainMCParticle(pCluster);
	     clusterPID = pClusterMCParticle->GetParticleId();
	     clusterMCPCharge = pandora::PdgTable::GetParticleCharge(clusterPID);
		 averageTime  = ClusterHelper::GetAverageTime(pCluster);
	  }
	  catch (pandora::StatusCodeException &)
	  {
	  }

	  int nHit = pCluster->GetNCaloHits();
	  bool isPhoton = PandoraContentApi::GetPlugins(*this)->GetParticleId()->IsPhoton(pCluster);
      bool hasTrack = !(pCluster->GetAssociatedTrackList().empty());

      float meanDensity = -1.;
      ClusterHelper::GetMeanDensity(pCluster, meanDensity);
	  
	  ///////////////////// check at endcap
	  unsigned int nHitAtEndacp = 0;
      pandora::CaloHitList clusterCaloHitList;
      pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

	  float totalHcalEnergy = 0.;

	  for(auto iter = clusterCaloHitList.begin(); iter != clusterCaloHitList.end(); ++iter)
	  {
		  auto pCaloHit = *iter;

		  if(pCaloHit->GetHitRegion() == pandora::ENDCAP)
		  {
			  ++nHitAtEndacp;
		  }

          if(pCaloHit->GetHitType() == pandora::HCAL)
          {
            totalHcalEnergy += pCaloHit->GetHadronicEnergy();
          }
	  }

	  bool isClusterAtEndcap = false;
	  if((float)nHitAtEndacp/clusterCaloHitList.size() > 0.5) isClusterAtEndcap = true;

	  float hadronicEnergyFraction = totalHcalEnergy / pCluster->GetHadronicEnergy();

      unsigned int startPseudoLayer(1000);
      startPseudoLayer = pCluster->GetShowerStartLayer(this->GetPandora());

	  float clusterVolume = -1.;
	  ClusterHelper::GetClusterVolume(pCluster, clusterVolume);

#if 0
	  if(averageTime<5.) 
	  {
		  std::cout << "cluster energy: " << hadEnergy << ", averageTime: " << averageTime << std::endl;

	      pandora::CaloHitList clusterCaloHits;
	      pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHits);

	      for(auto hitIter = clusterCaloHits.begin(); hitIter != clusterCaloHits.end(); ++hitIter)
	      {
	      	auto pCaloHit = *hitIter;
	        float hitTime = pCaloHit->GetTime();
	        float hitEnergy = pCaloHit->GetHadronicEnergy();

			std::cout << " -- hit time: " << hitTime << ", hitEnergy: " << hitEnergy << std::endl;
	      }
	  }
#endif

	  /////////////////////
	  std::vector<float> vars;
	  vars.push_back( float(EventPreparationAlgorithm::GetEventNumber()) );
	  vars.push_back( float(clusterPID) );
	  vars.push_back( float(clusterMCPCharge) );
	  vars.push_back( float(averageTime) );
	  vars.push_back( float(nHit) );
	  vars.push_back( hadEnergy );
	  vars.push_back( float(isPhoton) );
	  vars.push_back( float(hasTrack) );
	  vars.push_back( meanDensity );
	  vars.push_back( isClusterAtEndcap );
	  vars.push_back( hadronicEnergyFraction );
	  vars.push_back( float(startPseudoLayer) );
	  vars.push_back( clusterVolume );
	  HistogramManager::CreateFill("FragmentsFindingAlgorithm", "eventNum:clusterPID:clusterMCPCharge:averageTime:nHit:clusterEnergy:isPhoton:hasTrack:meanDensity:isClusterAtEndcap:hadronicEnergyFraction:startPseudoLayer:clusterVolume", vars);
	  /////////////////////
        
	  fragmentClusterVector.push_back(pCluster);
    }

	std::cout << " ------ fragmentClusterVector size: " << fragmentClusterVector.size() << std::endl;

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode FragmentsFindingAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    m_maxNHitsNonFragments = 200;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxNHitsNonFragments", m_maxNHitsNonFragments));

	m_minFragmentClusterEnergy = 0.2;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinFragmentClusterEnergy", m_minFragmentClusterEnergy));

    m_maxEnergyNonFragments = 3.;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxEnergyNonFragments", m_maxEnergyNonFragments));

    m_maxFragmentDensity = 0.5f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxFragmentDensity", m_maxFragmentDensity));

    return pandora::STATUS_CODE_SUCCESS;
  }

}
