/// \file ClosebySeedMergingAlgorithm.cc
/*
 *
 * ClosebySeedMergingAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. avr. 23 2015
 *
 * This file is part of APRILContent libraries.
 * 
 * APRILContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * APRILContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with APRILContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

#include "Pandora/AlgorithmHeaders.h"

#include "APRILTopologicalAssociation/ClosebySeedMergingAlgorithm.h"

#include "APRILHelpers/CaloHitHelper.h"
#include "APRILHelpers/ClusterHelper.h"

namespace april_content
{

  pandora::StatusCode ClosebySeedMergingAlgorithm::Run()
  {
    const pandora::ClusterList *pClusterList = NULL;
    std::string clusterName;
      
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList, clusterName));

    if(pClusterList->empty())
      return pandora::STATUS_CODE_SUCCESS;

    CaloHitSeedToClusterMap caloHitSeedToClusterMap;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->FindMergeCandidateClusters(pClusterList, caloHitSeedToClusterMap));
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->MergeCloseBySeedClusters(caloHitSeedToClusterMap));

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClosebySeedMergingAlgorithm::FindMergeCandidateClusters(const pandora::ClusterList *const pClusterList, CaloHitSeedToClusterMap &caloHitSeedToClusterMap) const
  {
	std::cout << "ClusterList size before ClosebySeedMerging: " << pClusterList->size() << std::endl;	

    for(pandora::ClusterList::const_iterator iter = pClusterList->begin(), endIter = pClusterList->end() ;
        endIter != iter ; ++iter)
    {
      const pandora::Cluster *const pCluster = *iter;

      // discriminate track
      if(!pCluster->GetAssociatedTrackList().empty())
        continue;

      pandora::CaloHitList clusterCaloHitList;
      pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

      pandora::CaloHitList seedCaloHitList;
      PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, CaloHitHelper::ExtractSeedCaloHitList(&clusterCaloHitList, seedCaloHitList, m_discriminateSeedLeafHits));

      if(seedCaloHitList.empty())
        continue;

      for(pandora::CaloHitList::const_iterator hitIter = seedCaloHitList.begin(), endHitIter = seedCaloHitList.end() ;
          endHitIter != hitIter ; ++hitIter)
      {
        const CaloHit *pSeedCaloHit = dynamic_cast<const CaloHit *>(*hitIter);

        if(pandora::ECAL == pSeedCaloHit->GetHitType() && !m_mergeECalSeedClusters)
          continue;

        if(pandora::HCAL == pSeedCaloHit->GetHitType() && !m_mergeHCalSeedClusters)
          continue;

        if(!caloHitSeedToClusterMap.insert(std::pair<const CaloHit *, const pandora::Cluster *>(pSeedCaloHit, pCluster)).second)
          return pandora::STATUS_CODE_FAILURE;
      }
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClosebySeedMergingAlgorithm::MergeCloseBySeedClusters(CaloHitSeedToClusterMap &caloHitSeedToClusterMap) const
  {
	std::cout << "MergeCloseBySeedClusters: the caloHitSeedToClusterMap size: " << caloHitSeedToClusterMap.size() << std::endl;
	
    for(CaloHitSeedToClusterMap::iterator iterI = caloHitSeedToClusterMap.begin(), endIterI = caloHitSeedToClusterMap.end() ;
        endIterI != iterI ; ++iterI)
    {
      const CaloHit *const pSeedCaloHitI = dynamic_cast<const CaloHit *>(iterI->first);

      if(NULL == iterI->second)
        continue;

      const pandora::Cluster *const pClusterI = iterI->second;

      for(CaloHitSeedToClusterMap::iterator iterJ = caloHitSeedToClusterMap.begin(), endIterJ = caloHitSeedToClusterMap.end() ;
          endIterJ != iterJ ; ++iterJ)
      {
        const CaloHit *const pSeedCaloHitJ = dynamic_cast<const CaloHit *>(iterJ->first);

        if(pSeedCaloHitI == pSeedCaloHitJ)
          continue;

        if(NULL == iterJ->second)
          continue;

        const pandora::Cluster *const pClusterJ = iterJ->second;

        // seeds in the same cluster don't need a merging
        if(pClusterI == pClusterJ)
          continue;

        if(pSeedCaloHitI->GetHitType() != pSeedCaloHitJ->GetHitType())
          continue;

#if 0
		std::cout << "Two clusters are trying to be merged: " <<  std::endl;
		std::cout << "pClusterI: " << pClusterI->GetElectromagneticEnergy() << std::endl;
		std::cout << "pClusterJ: " << pClusterJ->GetElectromagneticEnergy() << std::endl;
#endif

        const unsigned int pseudoLayerI = pSeedCaloHitI->GetPseudoLayer();
        const unsigned int pseudoLayerJ = pSeedCaloHitJ->GetPseudoLayer();

        if(std::max(pseudoLayerI, pseudoLayerJ) - std::min(pseudoLayerI, pseudoLayerJ) > m_maxSeedPseudoLayerDifference)
          continue;

        const pandora::CartesianVector distanceVector(pSeedCaloHitJ->GetPositionVector() - pSeedCaloHitI->GetPositionVector());

        const float seedTransverseDistance(distanceVector.GetMagnitude()*sin(pSeedCaloHitI->GetPositionVector().GetOpeningAngle(distanceVector)));
        const float seedDistance(distanceVector.GetMagnitude());

        const float maxSeedDistance = this->GetPandora().GetGeometry()->GetHitTypeGranularity(pSeedCaloHitI->GetHitType()) <= pandora::FINE ?
            m_maxSeedDistanceFine : m_maxSeedDistanceCoarse;
        const float maxSeedTransverseDistance = this->GetPandora().GetGeometry()->GetHitTypeGranularity(pSeedCaloHitI->GetHitType()) <= pandora::FINE ?
            m_maxSeedTransverseDistanceFine : m_maxSeedTransverseDistanceCoarse;

#if 0
		std::cout << "maxSeedDistance: " << maxSeedDistance << ", seedDistance: " << seedDistance
			      << ", seedTransverseDistance: " << seedTransverseDistance << ", maxSeedTransverseDistance: " << maxSeedTransverseDistance
				  <<  std::endl;
#endif

		//std::cout << "-------" <<  std::endl;
        if(seedDistance > maxSeedDistance || seedTransverseDistance > maxSeedTransverseDistance)
          continue;

        // replace the cluster that will be deleted by the one that will be enlarge
        PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->ReplaceClusterEntryInSeedMap(pClusterJ, pClusterI, caloHitSeedToClusterMap));

        // merge clusters
        PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, APRILContentApi::MergeAndDeleteClusters(*this, pClusterI, pClusterJ));
      }
    }

#if 1
    const pandora::ClusterList *pClusterList = NULL;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));

	std::cout << "Cluster size after ClosebySeedMerging: " << pClusterList->size() << std::endl;
#endif

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClosebySeedMergingAlgorithm::ReplaceClusterEntryInSeedMap(const pandora::Cluster *const pClusterToReplace, const pandora::Cluster *const pClusterReplacement,
      CaloHitSeedToClusterMap &caloHitSeedToClusterMap) const
  {
    if(NULL == pClusterToReplace)
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    for(CaloHitSeedToClusterMap::iterator iter = caloHitSeedToClusterMap.begin(), endIter = caloHitSeedToClusterMap.end() ;
        endIter != iter ; ++iter)
    {
      if(iter->second == pClusterToReplace)
        iter->second = pClusterReplacement;
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClosebySeedMergingAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    m_discriminateSeedLeafHits = true;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "DiscriminateSeedLeafHits", m_discriminateSeedLeafHits));

    m_maxSeedPseudoLayerDifference = 1;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxSeedPseudoLayerDifference", m_maxSeedPseudoLayerDifference));

    m_maxSeedDistanceFine = 25.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxSeedDistanceFine", m_maxSeedDistanceFine));

    m_maxSeedDistanceCoarse = 65.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxSeedDistanceCoarse", m_maxSeedDistanceCoarse));

    m_maxSeedTransverseDistanceFine = 15.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxSeedTransverseDistanceFine", m_maxSeedTransverseDistanceFine));

    m_maxSeedTransverseDistanceCoarse = 30.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxSeedTransverseDistanceCoarse", m_maxSeedTransverseDistanceCoarse));

    m_mergeECalSeedClusters = true;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MergeECalSeedClusters", m_mergeECalSeedClusters));

    m_mergeHCalSeedClusters = true;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MergeHCalSeedClusters", m_mergeHCalSeedClusters));

    return pandora::STATUS_CODE_SUCCESS;
  }


} 

