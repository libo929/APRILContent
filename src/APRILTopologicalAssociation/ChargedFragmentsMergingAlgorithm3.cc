/// \file ChargedFragmentsMergingAlgorithm3.cc
/*
 *
 * ChargedFragmentsMergingAlgorithm3.cc source template automatically generated by a class generator
 * Creation date : jeu. avr. 9 2015
 *
 * This file is part of APRILContent libraries.
 * 
 * APRILContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * APRILContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with APRILContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

#include "Pandora/AlgorithmHeaders.h"
#include "PandoraMonitoringApi.h"
#include "PandoraMonitoring.h"

#include "APRILTopologicalAssociation/ChargedFragmentsMergingAlgorithm3.h"

#include "APRILHelpers/SortingHelper.h"
#include "APRILHelpers/GeometryHelper.h"
#include "APRILHelpers/ReclusterHelper.h"
#include "APRILHelpers/ClusterHelper.h"
#include "APRILHelpers/HistogramHelper.h"
#include "APRILHelpers/ClusterPropertiesHelper.h"

#include "APRILApi/APRILContentApi.h"

#include "APRILUtility/EventPreparationAlgorithm.h"

#include "APRILTools/TrackDrivenSeedingTool.h"
#include "APRILObjects/CaloHit.h"

#include "TMath.h"

#include <algorithm>

#define __DEBUG__

namespace april_content
{
  pandora::StatusCode ChargedFragmentsMergingAlgorithm3::Run()
  {
    // get candidate clusters for association
	std::vector<APRILCluster*> clusterVector;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->GetEligibleClusters(clusterVector));

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// update cluster properties
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	std::vector<pandora::CartesianVector> m_clusterCentroids;
	for(int i = 0; i < clusterVector.size(); ++i)
	{
		auto pCluster = clusterVector.at(i);

		// compute main cluster hits
		const float maxLength = 50.;
		pandora::CaloHitList mainClusterHits;
		ClusterHelper::GetMainClusterHits(pCluster, mainClusterHits, maxLength);

		pandora::OrderedCaloHitList mainOrderedClusterHits;
		mainOrderedClusterHits.Add(mainClusterHits);

		pCluster->SetMainClusterHits(mainClusterHits);
		pCluster->SetMainOrderedClusterHits(mainOrderedClusterHits);
			
		///////
		pandora::CartesianVector centroid(0., 0., 0);
		ClusterHelper::GetCentroid(pCluster, centroid);
		pCluster->SetCentroid(centroid);
		m_clusterCentroids.push_back(centroid);
		
		try
		{
		    pandora::ClusterFitResult clusterFitResult;

			// fit with only connected calo hits; if not successful, with all calo hits.
			pandora::StatusCode fitStatus;

			// FIXME
			// MC
		    bool useHelpFromMC = false;

		    if(useHelpFromMC)
			{
				try
		        {
			    	const pandora::Cluster* const pandoraClu = dynamic_cast<const pandora::Cluster* const>(pCluster);
		        	auto clusterPID = pandora::MCParticleHelper::GetMainMCParticle(pandoraClu)->GetParticleId();
		        	//auto clusterCharge = pandora::PdgTable::GetParticleCharge( clusterPID );
		        
		        	bool isPhoton = (clusterPID == 22);
			    	if(isPhoton) pCluster->SetPhoton(true);
		        }
		        catch(pandora::StatusCodeException &)
		        {
		        	std::cout << "MCP issue: " << std::endl;
		        }
			}

			if(pCluster->IsPhoton())
			{
				// fit all connected calo hits
				fitStatus = ClusterHelper::FitFullCluster(pCluster, clusterFitResult);
			}
			else
			{
				// fit the main connected calo hits
				fitStatus = ClusterHelper::FitFullCluster(pCluster, clusterFitResult, true);
			}

			if(fitStatus)
			{
	            if(m_debugOutput2)
				{
					std::cout << " ---> fit all hits for cluster " << pCluster << ", E: " << pCluster->GetHadronicEnergy() << std::endl;
				}
				pandora::ClusterFitHelper::FitFullCluster(pCluster, clusterFitResult);
			}

		    const pandora::CartesianVector& cluDirection = clusterFitResult.GetDirection();
		    const pandora::CartesianVector& cluIntercept = clusterFitResult.GetIntercept();
			
			pCluster->SetAxis(cluDirection);
			pCluster->SetIntercept(cluIntercept);
		}
		catch(pandora::StatusCodeException &)
		{
	        if(m_debugOutput2)
			{
				std::cout << " ---> fitting cluster " << pCluster << ", E: " << pCluster->GetHadronicEnergy() << " failed." << std::endl;
			}
		}

		try
		{
		    pandora::ClusterFitResult clusterFitResult;

			if(ClusterHelper::FitStart(pCluster, 2, clusterFitResult) != pandora::STATUS_CODE_SUCCESS)
			{
				pandora::ClusterFitHelper::FitStart(pCluster, 2, clusterFitResult);
			}
			
			const pandora::CartesianVector& startingPoint = clusterFitResult.GetIntercept();

			pCluster->SetStartingPoint(startingPoint);


			// if cluster has connected with track, the intercept is taken as starting point and
			// the direction is computed from the hits in first 6 layers.
			const pandora::TrackList& associatedTrackList = pCluster->GetAssociatedTrackList();
		    int nAssociatedTracks = associatedTrackList.size();

			// re-compute axis and starting point for charged cluster
			if(nAssociatedTracks > 0)
			{
				pCluster->SetIntercept(startingPoint);

				if(nAssociatedTracks == 1)
				{
					const pandora::Track* associatedTrack = *( associatedTrackList.begin() );
					const pandora::CartesianVector trackDirectionAtCalo = 
						                           associatedTrack->GetTrackStateAtCalorimeter().GetMomentum().GetUnitVector();

					pCluster->SetAxis(trackDirectionAtCalo);
				}
				else
				{
				    if(pCluster->GetOrderedCaloHitList().size()>6)
				    {
				    	pandora::ClusterFitResult clusterFitResultChg;

				    	if(pandora::ClusterFitHelper::FitStart(pCluster, 6, clusterFitResultChg) != pandora::STATUS_CODE_SUCCESS)
				    	{
				    		pandora::ClusterFitHelper::FitStart(pCluster, 6, clusterFitResultChg);
				    	}

		                const pandora::CartesianVector& axis = clusterFitResultChg.GetDirection();
			
				    	pCluster->SetAxis(axis);
				    }
				}
			}
			else
			{
#ifdef __DEBUG__
				std::cout << "  ---> cluster: " << pCluster << ", E: " << pCluster->GetHadronicEnergy() 
					<< ", Starting: " << startingPoint.GetX() << ", " << startingPoint.GetY() << ", " << startingPoint.GetZ() << std::endl;
#endif
			}
		}
		catch(pandora::StatusCodeException &)
		{
		}

		try
		{
		    pandora::ClusterFitResult clusterFitResult;
			pandora::ClusterFitHelper::FitEnd(pCluster, 3, clusterFitResult);
		    const pandora::CartesianVector& endpoint = clusterFitResult.GetIntercept();

			pCluster->SetEndpoint(endpoint);
		}
		catch(pandora::StatusCodeException &)
		{
		}
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////
	CaloHitRangeSearchHelper::FillMatixByPoints(m_clusterCentroids, m_clusterCentroidsMatrix);

	// For test based on MC truth, which contains the charged clusters, the nearby clusters around
	// a charged cluster, and clusters in the HCAL.
	pandora::ClusterList clustersForMergingByMC;

	// candidates to merge, drop the charged hadronic clusters and photon clusters
	std::vector<APRILCluster*> clustersToMerge;

	for(int i = 0; i < clusterVector.size(); ++i)
	{
		auto pCluster = clusterVector.at(i);

		const pandora::TrackList& associatedTrackList = pCluster->GetAssociatedTrackList();
		if(!associatedTrackList.empty()) 
		{
			clustersForMergingByMC.push_back(pCluster);
    
			int showerStartLayer = 0;
			const pandora::Cluster *const pPandoraCluster = static_cast<const pandora::Cluster *const>(pCluster);
			ClusterHelper::GetShowerStartingLayer(pPandoraCluster, showerStartLayer);

			pandora::CartesianVector startingPoint(0., 0., 0.);
			ClusterHelper::GetShowerStartingPoint(pPandoraCluster, startingPoint);

#ifdef __DEBUG__
			std::cout << "   ---> cluster: " << pPandoraCluster << ", E: " << pPandoraCluster->GetHadronicEnergy() 
				<< ", showerStartingLayer: " << showerStartLayer 
				<< ", pos: " << startingPoint.GetX() << ", " << startingPoint.GetY() << ", " << startingPoint.GetZ() << std::endl;
#endif

			continue;
		}

		bool isPhoton = pCluster->IsPhoton();
		if(isPhoton) 
		{
#ifdef __DEBUG__
			std::cout << "   ---> photon: " << pCluster << ", E: " << pCluster->GetHadronicEnergy() << std::endl;
#endif
			continue;
		}

		// FIXME
		// MC
		bool useHelpFromMC = false;

		if(useHelpFromMC)
		{
			try
		    {
		    	const pandora::Cluster* const pandoraClu = dynamic_cast<const pandora::Cluster* const>(pCluster);
		    	auto clusterPID = pandora::MCParticleHelper::GetMainMCParticle(pandoraClu)->GetParticleId();
		    	auto clusterCharge = pandora::PdgTable::GetParticleCharge( clusterPID );
		    
		    	bool isNeutral = (clusterCharge == 0);

		    	if(isNeutral && pCluster->GetHadronicEnergy() < 10.) continue;
		    }
		    catch(pandora::StatusCodeException &)
		    {
		    	std::cout << "MCP issue: " << std::endl;
		    }
		}
		//////

		clustersToMerge.push_back(pCluster);

		int clusterPID = -1e8;
		int clusterCharge = -1000;

		const pandora::Cluster* const pandoraClu = dynamic_cast<const pandora::Cluster* const>(pCluster);

		try
		{
			clusterPID = pandora::MCParticleHelper::GetMainMCParticle(pandoraClu)->GetParticleId();
			clusterCharge = pandora::PdgTable::GetParticleCharge( clusterPID );
		
			if(m_useMCPForPID) isPhoton = (clusterPID == 22);
		}
		catch(pandora::StatusCodeException &)
		{
			std::cout << "MCP issue: " << pandoraClu << std::endl;
		}

		//std::cout << " --- cluster : " << pCluster << ", energy: " << pCluster->GetHadronicEnergy() << ", PID: " <<
		//	clusterPID << ", charge: " << clusterCharge << std::endl;

		if(m_debugOutput)
		{
			std::cout << "-----------------------------------------------------------------------------------------" << std::endl;
			std::cout << " --- cluster : " << pCluster << ", energy: " << pCluster->GetHadronicEnergy() 
				  << ", associatedTrackList size: " << pCluster->GetAssociatedTrackList().size() << std::endl;
		}

		auto clusterRegion = ClusterHelper::GetRegion(pCluster);

		float clusterIPAngle = ClusterHelper::GetClusterAxisStartingPointAngle(pCluster);
		float clusterTime = ClusterHelper::GetAverageTime(pCluster);
		float clusterTimeECal = ClusterHelper::GetAverageTime(pCluster, true);
		float hadEnergyInEcal = ClusterHelper::GetHadronicEnergyInECAL(pCluster);
		float density = ClusterHelper::GetMeanDensity(pCluster);

		float energyRatio = hadEnergyInEcal / pCluster->GetHadronicEnergy();

		const pandora::OrderedCaloHitList& mainClusterHits = pCluster->GetMainOrderedClusterHits();
		
		float energyRatioOfMainHits;
	   	unsigned int nMainHits;
	   
		ClusterHelper::GetEnergyRatio(mainClusterHits, energyRatioOfMainHits, nMainHits);

		unsigned int innerLayer = pCluster->GetInnerPseudoLayer();
		unsigned int outerLayer = pCluster->GetOuterPseudoLayer();

		unsigned int nConnectors = ClusterHelper::GetClusterConnectorNumber(pCluster);
		float connectorHitRatio = (float)nConnectors/nMainHits;
	    
		std::vector<april_content::APRILCluster*> nearbyClusters;
		std::vector<float> distances;

		try
		{
			SearchProperClusters(pCluster, clusterVector, nearbyClusters, distances);
		}
		catch(...)
		{
			std::cout << " GetNearbyClusters error!" << std::endl;
		}

		/////////////////////////////////////////////////////////////////
		bool nearClusterHasTrack = false;

	    for(int iClu = 0; iClu < nearbyClusters.size(); ++iClu)
	    {
	    	//std::cout << "       ---> cluster: " << nearbyClusters.at(iClu) << ", E: " << nearbyClusters.at(iClu)->GetHadronicEnergy() 
	    	//	<< ", associatedTrack: " << nearbyClusters.at(iClu)->GetAssociatedTrackList().size() << std::endl;

			if(nearbyClusters.at(iClu)->GetAssociatedTrackList().size() > 0)
			{
				nearClusterHasTrack = true;
			}
	    }

		if(nearClusterHasTrack)
		{
			clustersForMergingByMC.push_back(pCluster);
			continue;
		}
		/////////////////////////////////////////////////////////////////

		if(m_debugOutput)
		{
			std::cout << "    === cluster === " << std::endl
	        	      << "    cluster: " << pCluster << ", E: " << pCluster->GetHadronicEnergy()  << ", nhit: " 
					  << pCluster->GetNCaloHits() << std::endl
	        		  << "    nPossibleMipHits: " << pCluster->GetNPossibleMipHits() << ", mipFraction: " << pCluster->GetMipFraction() << std::endl
	        		  << "    isPhoton: " << isPhoton << std::endl
	        		  << "    clusterRegion: " << clusterRegion << " clusterIPAngle: " << clusterIPAngle << " clusterTime: " 
					  << clusterTime << " clusterTimeECal: " << clusterTimeECal << std::endl
	        		  << "    hadEnergyInEcal: " << hadEnergyInEcal << " energyRatio: " << energyRatio << std::endl
	        		  << "    density: " << density << ", connectorHitRatio: " << connectorHitRatio << std::endl
	        		  << "    innerLayer: " << innerLayer << " outerLayer: " << outerLayer << std::endl
	        		  << "    nearby cluster: " << nearbyClusters.size() << std::endl;

	            for(int iClu = 0; iClu < nearbyClusters.size(); ++iClu)
	            {
	            	std::cout << "       ---> cluster: " << nearbyClusters.at(iClu) << ", E: " << nearbyClusters.at(iClu)->GetHadronicEnergy() 
	            		<< ", associatedTrack: " << nearbyClusters.at(iClu)->GetAssociatedTrackList().size() << std::endl;
	            }

	        	std::cout << "    clusterMCPID: " << clusterPID << ", clusterMCCharge: " << clusterCharge << std::endl;
		}

		if(innerLayer > 5.)
		{
			//std::cout << "    \033[1;31m ---> innerLayer: " << innerLayer << ", energyRatio: " << energyRatio << " \033[0m " << std::endl;
			clustersForMergingByMC.push_back(pCluster);
			continue;
		}
	}

	std::map<const pandora::Cluster*, pandora::ClusterList> clustersMergingMap;
	MakeMergingMap(clustersToMerge, clusterVector, clustersMergingMap);

	MergeClusters(clustersMergingMap);

	//MCClusterMerging(clustersForMergingByMC);

    return pandora::STATUS_CODE_SUCCESS;
  }


  void ChargedFragmentsMergingAlgorithm3::MakeMergingMap(std::vector<APRILCluster*>& clustersToMerge,
		  std::vector<APRILCluster*>& clusterVector, std::map<const pandora::Cluster*, pandora::ClusterList>& clustersMergingMap)
  {
	//std::cout << " clusters to merge: " << clustersToMerge.size() << std::endl;
	clustersMergingMap.clear();
	
	for(auto& pCluster : clustersToMerge)
	{
		std::vector<april_content::APRILCluster*> nearbyClusters;
		std::vector<float> distances;

		try
		{
			SearchProperClusters(pCluster, clusterVector, nearbyClusters, distances);
		}
		catch(...)
		{
			std::cout << " GetNearbyClusters error!" << std::endl;
		}

#if 0
		std::cout << " === cluster: " << pCluster << ", E: " << pCluster->GetHadronicEnergy() 
			<< ", layer: " << pCluster->GetInnerPseudoLayer() << std::endl;
#endif

		float maxDistance = 200.; // TODO: diffent value for diffrent region
		std::vector<april_content::APRILCluster*> veryCloseClusters;

		for(int i = 0; i < nearbyClusters.size(); ++i)
		{
			auto& nearbyCluster = nearbyClusters.at(i);
			float distance = distances.at(i);

#if 0
			std::cout << "     -> nearby cluster " << i << ": " << nearbyCluster
				<< ", E: " << nearbyCluster->GetHadronicEnergy() 
				<< ", track: " << nearbyCluster->GetAssociatedTrackList().size()
				<< ", distance: " << distance << std::endl;
#endif

			if(distance < maxDistance)
			{
				veryCloseClusters.push_back(nearbyCluster);
			}
		}

		int chargedCluster = 0;

		for(int i = 0; i < veryCloseClusters.size(); ++i)
		{
			if(veryCloseClusters.at(i)->GetAssociatedTrackList().size() > 0) 
			{
				++chargedCluster;
			}
		}

		if(veryCloseClusters.size() > 0 && chargedCluster == veryCloseClusters.size()) // if all the close clusters are charged
		{
			auto cluster = veryCloseClusters.at(0);

#if 0
			std::cout << "     \033[1;32m ======> merge charged clusters: " << pCluster << ", E: " << pCluster->GetHadronicEnergy() 
				<< " --- " << cluster << ", E: " << cluster->GetHadronicEnergy() << "\033[0m" << std::endl;
#endif

			FillClusters(clustersMergingMap, cluster, pCluster);

			// further check ?
		}
		else if(veryCloseClusters.size() > 0 && chargedCluster == 0) // if all the close clusters are neutral
		{
			// we can merge the cluster to closest neutral cluster, or just do nothing.
		}
		else
		{
			pandora::Cluster* cluster = nullptr;

			for(int i = 0; i < veryCloseClusters.size(); ++i)
			{
				if(veryCloseClusters.at(i)->GetAssociatedTrackList().size() > 0)
				{
					cluster = veryCloseClusters.at(i);
					break;
				}
			}

			if(cluster!=nullptr) FillClusters(clustersMergingMap, cluster, pCluster);
		}
	}
  }
		


  void ChargedFragmentsMergingAlgorithm3::MCClusterMerging(const pandora::ClusterList& clustersForMerging)
  {
	// Cluster merging test based on MC truth
	std::map<const pandora::MCParticle* const, pandora::ClusterList> mcpClusterListMap;
	
	for(auto it = clustersForMerging.begin(); it != clustersForMerging.end(); ++it)
	{
		const pandora::Cluster* const clu = *it;

		const pandora::MCParticle* pClusterMCParticle  = nullptr;

        try
        {
        	 pClusterMCParticle = pandora::MCParticleHelper::GetMainMCParticle( clu );
        }
        catch (pandora::StatusCodeException &)
        {
		    continue;
		}

		if(pClusterMCParticle != nullptr && mcpClusterListMap.find( pClusterMCParticle ) == mcpClusterListMap.end())
		{
		    pandora::ClusterList clusterList;
		    clusterList.push_back( clu );
		    mcpClusterListMap[pClusterMCParticle] = clusterList;
		}
		else
		{
		    mcpClusterListMap[pClusterMCParticle].push_back( clu );
		}
	}

	for(auto it = mcpClusterListMap.begin(); it != mcpClusterListMap.end(); ++it)
	{
		// merge charged clusters
		auto mcp = it->first;
		int clusterMCPCharge = pandora::PdgTable::GetParticleCharge(mcp->GetParticleId());

		auto clusterList = it->second;
		pandora::ClusterVector clusterVectorForMerging;
		clusterVectorForMerging.insert(clusterVectorForMerging.begin(), clusterList.begin(), clusterList.end());

		bool onlyMergeChargedClusters = true;

		if(clusterMCPCharge == 0) 
		{
			if(m_debugOutput)
			{
				std::cout << "      \033[1;32m Neutral cluster(s): \033[0m" << std::endl;
			}

			for(int i = 0; i < clusterVectorForMerging.size(); ++i)
			{
				auto& cluster = clusterVectorForMerging.at(i);
		
				if(m_debugOutput)
				{
					std::cout << "             ---> cluster: " << cluster << ", E: " << cluster->GetHadronicEnergy() << std::endl;
				}
			}

			if(onlyMergeChargedClusters) continue;
		}
		else
		{
			if(m_debugOutput)
			{
				std::cout << "      \033[1;31m Charged cluster(s): \033[0m" << std::endl;
			}

			for(int i = 0; i < clusterVectorForMerging.size(); ++i)
			{
				auto& cluster = clusterVectorForMerging.at(i);
			
				if(m_debugOutput)
				{
					std::cout << "             ---> cluster: " << cluster << ", E: " << cluster->GetHadronicEnergy() << std::endl;
				}
			}
		}
	
		std::sort(clusterVectorForMerging.begin(), clusterVectorForMerging.end(), pandora_monitoring::PandoraMonitoring::SortClustersByHadronicEnergy);

	    if(clusterVectorForMerging.size()>1) 
		{
			// merge clusters
			auto firstCluster = clusterVectorForMerging.at(0);

			for(int i = 1; i < clusterVectorForMerging.size(); ++i)
			{
		        const pandora::Cluster* cluToMerge = clusterVectorForMerging.at(i);
				APRILContentApi::MergeAndDeleteClusters(*this, firstCluster, cluToMerge);
			}

		}// end if
	} // end for
  }

  void ChargedFragmentsMergingAlgorithm3::MergeClusters(std::map<const pandora::Cluster*, pandora::ClusterList>& clustersMergingMap)
  {
	  for(auto& iter : clustersMergingMap)
	  {
		  auto mainCluster = iter.first;
		  auto clustersToMerge = iter.second;

		  for(auto& cluster : clustersToMerge)
		  {
			 bool isRight = true;
			 bool isChargeRight = true;

		     try
		     {
		     	auto mainClusterPID = pandora::MCParticleHelper::GetMainMCParticle(mainCluster)->GetParticleId();
		     	auto mainClusterCharge = pandora::PdgTable::GetParticleCharge(mainClusterPID);

		     	auto clusterPID = pandora::MCParticleHelper::GetMainMCParticle(cluster)->GetParticleId();
		     	auto clusterCharge = pandora::PdgTable::GetParticleCharge(clusterPID);

				if(clusterPID != mainClusterPID) isRight = false;
				if(abs(mainClusterCharge) != abs(clusterCharge)) isChargeRight = false;

				const float minClusterEnergyToMerge = 0.55;
				const float maxClusterEnergyToMerge = 6.0;
				const int maxClusterMergingLayer = 1;


				bool toMerge = true;

				if(cluster->GetInnerPseudoLayer() < maxClusterMergingLayer)
				{
					toMerge = false;
				}

				if(cluster->GetHadronicEnergy() > maxClusterEnergyToMerge)
				{
					toMerge = false;
				}

				if(!CheckStartingPoints(mainCluster, cluster))
				{
					toMerge = false;
				}

				if(cluster->GetHadronicEnergy() < minClusterEnergyToMerge)
				{
					toMerge = true;
				}
			 
				////////////////////////////////////////////////////
				float oldChi = 1.e6;
			    float newChi = 1.e6;
			    float trackEnergy = 0.;

			    bool m_useEnergyChi = true;

			    if(m_useEnergyChi &&
			       pandora::STATUS_CODE_SUCCESS != 
			            ClusterHelper::GetChiClusterMerging(this->GetPandora(), mainCluster, cluster, trackEnergy, oldChi, newChi))
			    {
			    	std::cout << "      ===> GetChiClusterMerging issue..." << std::endl;
			    }

			    float m_maxChi = 4.5;

			    if(m_useEnergyChi && newChi > m_maxChi) 
			    {
					std::cout << "     --- newChi: " << newChi << ", maxChi: " << m_maxChi << std::endl;
			    	toMerge = false;
			    }

				// mc test
#if 0
				if(toMerge == false && isRight && cluster->GetHadronicEnergy() > 0.55 && cluster->GetHadronicEnergy() < 6.)
					toMerge = true;
#endif
				////////////////////////////////////////////////////
				

				//////////////////////////////////////////////////// reject photon which is identified as that, or neutral hadronic cluster


				/////////////////////////////////////////////////////////////////////////
				if(!toMerge)
				{
	                std::vector<float> vars;
	                vars.push_back( float(EventPreparationAlgorithm::GetEventNumber()) );
	                vars.push_back( float(mainCluster->GetHadronicEnergy()) );
	                vars.push_back( float(cluster->GetHadronicEnergy()) );
	                vars.push_back( float(cluster->GetInnerPseudoLayer()) );
	                vars.push_back( float(mainClusterPID) );
	                vars.push_back( float(clusterPID) );
				    vars.push_back( float(mainClusterCharge));
				    vars.push_back( float(clusterCharge) );
				    vars.push_back( float(isRight) );
				    vars.push_back( float(isChargeRight) );

				    //std::cout << "  -> cluster energy to merge: " << cluToMerge->GetHadronicEnergy() << std::endl;

		            HistogramManager::CreateFill("ChargedFragmentsMergingAlgorithm3_nonMerging", 
						"evtNum:mainClusterEnergy:clusterEnergy:innerPseudoLayer:mainPID:PID:mainCharge:charge:isRight:isChargeRight", vars);

					if(isRight)
					{
						std::cout << "      \033[1;31m Miss to merge clusters: " << mainCluster << ", E: " << mainCluster->GetHadronicEnergy()
			       	    << " --- " << cluster << ", E: " << cluster->GetHadronicEnergy() << ", isRight: " << isRight << "\033[0m" << std::endl;
					}

					continue;
				}
				else
				{
					std::vector<float> vars;
	                vars.push_back( float(EventPreparationAlgorithm::GetEventNumber()) );
	                vars.push_back( float(mainCluster->GetHadronicEnergy()) );
	                vars.push_back( float(cluster->GetHadronicEnergy()) );
	                vars.push_back( float(cluster->GetInnerPseudoLayer()) );
	                vars.push_back( float(mainClusterPID) );
	                vars.push_back( float(clusterPID) );
				    vars.push_back( float(mainClusterCharge));
				    vars.push_back( float(clusterCharge) );
				    vars.push_back( float(isRight) );
				    vars.push_back( float(isChargeRight) );

				    //std::cout << "  -> cluster energy to merge: " << cluToMerge->GetHadronicEnergy() << std::endl;

		            HistogramManager::CreateFill("ChargedFragmentsMergingAlgorithm3_merging", 
				    		"evtNum:mainClusterEnergy:clusterEnergy:innerPseudoLayer:mainPID:PID:mainCharge:charge:isRight:isChargeRight", vars);

					if(!isRight && !isChargeRight)
					{
						std::cout << "      \033[1;31m It's false to merge clusters: " << mainCluster << ", E: " << mainCluster->GetHadronicEnergy()
			       	    << " --- " << cluster << ", E: " << cluster->GetHadronicEnergy() << ", isRight: " << isRight << "\033[0m" << std::endl;
					}

					if(!isRight && isChargeRight)
					{
						std::cout << "      \033[1;33m It's issue to merge clusters: " << mainCluster << ", E: " << mainCluster->GetHadronicEnergy()
			       	    << " --- " << cluster << ", E: " << cluster->GetHadronicEnergy() << ", isRight: " << isRight << "\033[0m" << std::endl;
					}
				}
		     }
		     catch(pandora::StatusCodeException &)
		     {
				 std::cout << "MCP issue" <<  std::endl;
		     }


			 std::cout << "      \033[1;32m Merge clusters: " << mainCluster << ", E: " << mainCluster->GetHadronicEnergy()
			       	   << " --- " << cluster << ", E: " << cluster->GetHadronicEnergy() 
					   << ", isRight: " << isRight << ", isChargeRight: " << isChargeRight << "\033[0m" << std::endl;

			 APRILContentApi::MergeAndDeleteClusters(*this, mainCluster, cluster);
		  }
	  }
  }

  void ChargedFragmentsMergingAlgorithm3::FillClusters(std::map<const pandora::Cluster*, pandora::ClusterList>& clustersMergingMap, 
		  pandora::Cluster* cluster, pandora::Cluster* clusterToMerge)
  {
	  auto mapIter = clustersMergingMap.find(cluster);
	
	  if(mapIter == clustersMergingMap.end())
	  {
		  pandora::ClusterList clusterList;
		  clusterList.push_back(clusterToMerge);

		  clustersMergingMap.insert(std::pair<const pandora::Cluster*, pandora::ClusterList>(cluster, clusterList));
	  }
	  else
	  {
		  mapIter->second.push_back(clusterToMerge);
	  }
  }
				
  bool ChargedFragmentsMergingAlgorithm3::CheckStartingPoints(const pandora::Cluster* chargedCluster, const pandora::Cluster* fragment)
  {
	  auto chClu = dynamic_cast<const april_content::APRILCluster*>(chargedCluster);
	  auto frg = dynamic_cast<const april_content::APRILCluster*>(fragment);

	  pandora::CartesianVector showerStartingPoint(0., 0., 0.);
	  ClusterHelper::GetShowerStartingPoint(chargedCluster, showerStartingPoint);

	  pandora::CartesianVector frgStartingPoint = frg->GetStartingPoint();
	  float clusterIPAngle = ClusterHelper::GetClusterAxisStartingPointAngle(frg);

#ifdef __DEBUG__
	  std::cout << "   --- CheckStartingPoints --- " << endl
		        << "   - chCluster: " << chargedCluster << ", E: " << chargedCluster->GetHadronicEnergy() << ", start: " 
				<< showerStartingPoint.GetX() << ", " << showerStartingPoint.GetY() << ", " << showerStartingPoint.GetZ() << endl
		        << "   - fragment: " << fragment << ", E: " << fragment->GetHadronicEnergy() << ", start: " 
				<< frgStartingPoint.GetX() << ", " << frgStartingPoint.GetY() << ", " << frgStartingPoint.GetZ() << std::endl;
#endif

	  bool passCheck = false;

	  if(showerStartingPoint.GetMagnitude() < 1.e-6) // no shower
	  {
		  // FIXME
		  //passCheck = false;
		  auto chEndPoint = chClu->GetEndpoint();
		  auto cluterEndStartDistance = frgStartingPoint - chEndPoint;

#ifdef __DEBUG__
	          std::cout <<  "   - charged cluster : " << chClu << ", E: " << chClu->GetHadronicEnergy() << ", end: " 
				        << chEndPoint.GetX() << ", " << chEndPoint.GetY() << ", " << chEndPoint.GetZ() << std::endl;
#endif
		  // FIXME: foward
		  if(cluterEndStartDistance.GetMagnitude() < 50. && fragment->GetHadronicEnergy() < 3.)
		  {
			  std::cout << "    - distance: " << cluterEndStartDistance.GetMagnitude() << std::endl;
			  passCheck = true;
		  }
		  else
		  {
			  std::cout << "    - distance: " << cluterEndStartDistance.GetMagnitude() << std::endl;
		  }
		    
		  if(clusterIPAngle > 0.8) 
		  {
			  std::cout << "    - angle: " << clusterIPAngle << std::endl;
			  passCheck = true;
		  }
		  else
		  {
			  std::cout << "    - angle: " << clusterIPAngle << std::endl;
		  }

		  if(passCheck == false)
		  {
			  float closestDistance = 1.e6;

	          ClusterHelper::GetClosestDistanceApproach(chClu, frg, closestDistance, m_onlyUseConnectedHits);

			  // TODO: check R
			  if(closestDistance < 30. &&  fragment->GetHadronicEnergy() < 3.) 
			  {
				  passCheck = true;
			  }
		  }
	  }
	  else
	  {
		  auto startingPointDiff = frgStartingPoint - showerStartingPoint;

		  if(startingPointDiff.GetMagnitude() < 30.)
		  {
			  passCheck = true;
		  }

		  if(passCheck == false)
		  {
#ifdef __DEBUG__
	      std::cout <<  "   - fragment: " << fragment << ", E: " << fragment->GetHadronicEnergy() << ", clusterIPAngle: " 
				    << clusterIPAngle << std::endl;
#endif
		      if(clusterIPAngle > 0.8) passCheck = true;
		  }

		  if(passCheck == false)
		  {
			  float closestDistance = 1.e6;

	          ClusterHelper::GetClosestDistanceApproach(chClu, frg, closestDistance, m_onlyUseConnectedHits);

			  // TODO: check R
			  if(closestDistance < 10. &&  fragment->GetHadronicEnergy() < 2.5) 
			  {
				  passCheck = true;
			  }
		  }
	  }

	  return passCheck;
  }

  bool ChargedFragmentsMergingAlgorithm3::CheckNearbyClusterWithCharge(const april_content::APRILCluster* pCluster, std::vector<april_content::APRILCluster*>& nearbyClusters, int charge)
  {
	  bool isValidated = true;

	  for(int iClu = 0; iClu < nearbyClusters.size(); ++iClu)
	  {
		  float closestDistance = 1.e6;

	  	  auto nearbyCluster = nearbyClusters.at(iClu);

	      try
	      {
	          ClusterHelper::GetClosestDistanceApproach(pCluster, nearbyCluster, closestDistance, m_onlyUseConnectedHits);
	      }
          catch(pandora::StatusCodeException &)
	      {
	          std::cout << "GetClosestDistanceApproach failed" << std::endl;
	      }

		  if(charge == 1)
		  {
			  if(nearbyCluster->GetAssociatedTrackList().size() > 0)
	  	      {
				std::cout << "  near a charged cluster, closestDistance: "  << closestDistance << std::endl;

				unsigned int innerLayer = pCluster->GetInnerPseudoLayer();
				unsigned int outerLayer = pCluster->GetOuterPseudoLayer();

				bool passCheck = true;

				// check hit on the 1st layer
				if(innerLayer==1 && outerLayer < 40) 
				{
	                const pandora::OrderedCaloHitList& orderedCaloHitList = pCluster->GetMainOrderedClusterHits();
					auto& hitsAtFirstLayer = *(orderedCaloHitList.begin()->second);

					if(hitsAtFirstLayer.size() > 5) passCheck = false;

					if(passCheck)
					{
						pandora::CaloHitVector seedVec;

					    for(auto& hit : hitsAtFirstLayer)
					    {
					    	const april_content::CaloHit *const pAPRILCaloHit(dynamic_cast<const april_content::CaloHit *const>(hit));
							const april_content::ConnectorList& backwardConnectorList = 
								APRILContentApi::GetConnectorList(pAPRILCaloHit, april_content::BACKWARD_DIRECTION);
							const april_content::ConnectorList& forwardConnectorList = 
								APRILContentApi::GetConnectorList(pAPRILCaloHit, april_content::FORWARD_DIRECTION);

							std::cout << "  hit on 1st layer: " << pAPRILCaloHit << ", bakConnector: " << backwardConnectorList.size() 
								<< ", fwdConnector: " << forwardConnectorList.size() << std::endl;

							bool isSeed = (backwardConnectorList.size() == 0) && (forwardConnectorList.size() > 0);

					    	if(isSeed) 
					    	{
							    seedVec.push_back(hit);
					    	}

					    }

						float seedsDistance = 0;
						const float maxSeedDistance = 15.; // ECAL cell size 10 mm

						// if cluster has more than one seed on 1st layer, get the maximum seed distance
						if(seedVec.size() > 1)
						{
							for(int iSeed = 0; iSeed < seedVec.size(); ++iSeed)
							{
								for(int jSeed = iSeed + 1; jSeed < seedVec.size(); ++jSeed)
								{
									float distance = 
										(seedVec.at(iSeed)->GetPositionVector() - seedVec.at(jSeed)->GetPositionVector()).GetMagnitude();

									if(seedsDistance < distance)
									{
										seedsDistance = distance;
									}
								}
							}
						}

						if(seedVec.empty() || seedsDistance > maxSeedDistance) 
						{
							std::cout << "     seed size: " << seedVec.size() << ", seedsDistance: " << seedsDistance << std::endl;
							passCheck = false;
						}
					}
				}

				if(passCheck)
				{
					unsigned int nConnectors = ClusterHelper::GetClusterConnectorNumber(pCluster);

					const pandora::OrderedCaloHitList& mainClusterHits = pCluster->GetMainOrderedClusterHits();
					pandora::CaloHitList caloHitList;
					mainClusterHits.FillCaloHitList(caloHitList);

					if(caloHitList.size() > 8 && (float)nConnectors/caloHitList.size() < 0.55) 
					{
						passCheck = false;
					    std::cout << "     nConnectors : " << nConnectors << std::endl;
					}
				}

				// TODO::
				// check axes distance, track positon on ECAL (if between two seeds ?)
				 
				if(passCheck) 
				{
					std::cout << "     OK." << std::endl;
				}
				else
				{
					isValidated = false;
				}

				break;
	  	      }
		  }
		  else
		  {
			  if( (nearbyCluster->IsPhoton() || nearbyCluster->GetAssociatedTrackList().size() == 0) &&
				  closestDistance < 50. ) 
		      {
				  //std::cout << "  \033[1;31m near neutral cluster, it maye be a neutral fragment. \033[0m"  << std::endl;

				  break;
		      }
			  else
			  {
				  isValidated = false;
			  }
		  }

	  	  if(closestDistance != 1.e6 && closestDistance > 100.) break;
	  }

	  return isValidated;
  }

  void ChargedFragmentsMergingAlgorithm3::SearchProperClusters(APRILCluster* startingCluster, 
		  std::vector<april_content::APRILCluster*>& allClusters,
		  std::vector<april_content::APRILCluster*>& properClusters,
		  std::vector<float>& distances)
  {
	  if(m_debugOutput)
	  {
		  const pandora::Cluster* const pandoraTrackStartClu = dynamic_cast<const pandora::Cluster* const>(startingCluster);
	      float startCluEnergy = startingCluster->GetHadronicEnergy();

	      auto pClusterMCParticle = pandora::MCParticleHelper::GetMainMCParticle(pandoraTrackStartClu);
	      std::cout << " SearchProperClusters for charged cluster: " << startingCluster << ", Ehad: " << startCluEnergy << ", MCP: " << pClusterMCParticle << std::endl;
	  }

	  std::vector<april_content::APRILCluster*> nearbyClusters;
	  GetNearbyClusters(startingCluster, allClusters, nearbyClusters);

	  // map for sorting all nearby clusters by closest distance
	  std::multimap<float, APRILCluster*> clusterDistanceMap;

	  for(int i = 0; i < nearbyClusters.size(); ++i)
	  {
		  auto nearbyCluster = nearbyClusters.at(i);

		  if(nearbyCluster == startingCluster || nearbyCluster->IsPhoton()) 
		  {
			  continue;
		  }

		  // GetClustersDistance
		  float closestDistance = 1.e6;

		  try
		  {
			  ClusterHelper::GetClosestDistanceApproach(startingCluster, nearbyCluster, closestDistance, m_onlyUseConnectedHits);
		  }
          catch(pandora::StatusCodeException &)
		  {
			  std::cout << "GetClosestDistanceApproach failed" << std::endl;
		  }

		  bool isMergingCandidate = closestDistance < m_maxClosestClusterDistance;

	      if(m_debugOutput)
		  {
			  std::cout << "  nearbyCluster: " << nearbyCluster << ", E: " << nearbyCluster->GetHadronicEnergy() 
				  << ", closestDistance: " << closestDistance << std::endl;
		  }

		  if(isMergingCandidate) 
		  {
		      clusterDistanceMap.insert( std::pair<float, APRILCluster*>(closestDistance, nearbyCluster) );
		  }
		  else
		  {
	          if(m_debugOutput2) 
			  {
				  std::cout << "    --- Not a merging cadidate" << std::endl;
			  }
		  }

	      if(m_debugOutput2)
		  {
			  std::cout << "-----------------------------------------------------------------------------------------" << std::endl;
		  }
      }

	  distances.clear();
	  properClusters.clear();
		  
	  for(auto it = clusterDistanceMap.begin(); it != clusterDistanceMap.end(); ++it)
	  {
		  distances.push_back(it->first);
		  properClusters.push_back(it->second);
	  }

	  if(m_debugOutput)
	  {
		  std::cout << "-----------------------------------------------------------------------------------------------------------" << std::endl;
	  }
  }

  void ChargedFragmentsMergingAlgorithm3::GetNearbyClusters(pandora::Cluster* cluster, 
		  const std::vector<april_content::APRILCluster*>& clusterVector, std::vector<april_content::APRILCluster*>& clustersInRange)
  {
      pandora::CartesianVector centroid(0., 0., 0.);
	  ClusterHelper::GetCentroid(cluster, centroid);

	  const float distance = m_maxStartingClusterDistance;
	  const mlpack::math::Range range(0., distance);

      arma::mat testPoint(3, 1);
	  testPoint.col(0)[0] = centroid.GetX();
	  testPoint.col(0)[1] = centroid.GetY();
	  testPoint.col(0)[2] = centroid.GetZ();
	  
	  if(m_clusterCentroidsMatrix.size() == 0) 
	  {
		  std::cout << " Error: clusterCentroidsMatrix is null. " << std::endl;
		  return;
	  }

	  mlpack::range::RangeSearch<> rangeSearch(m_clusterCentroidsMatrix);
      std::vector<std::vector<size_t> > resultingNeighbors;
      std::vector<std::vector<double> > resultingDistances;
      rangeSearch.Search(testPoint, range, resultingNeighbors, resultingDistances);

      std::vector<size_t>& neighbors = resultingNeighbors.at(0);
      std::vector<double>& distances = resultingDistances.at(0);
	  
      for(size_t j=0; j < neighbors.size(); ++j)
      {
      	size_t neighbor = neighbors.at(j);
      	//double hitsDist = distances.at(j);

		clustersInRange.push_back( clusterVector.at(neighbor) );
	  }


	  // sort cluster by distance
	  std::multimap<float, APRILCluster*> clusterDistanceMap;

	  for(int i = 0; i < clustersInRange.size(); ++i)
	  {
		  auto clusterInRange = clustersInRange.at(i);

		  clusterDistanceMap.insert( std::pair<float, APRILCluster*>(distances.at(i), clusterInRange) );
	  }

	  clustersInRange.clear();

	  for(auto& mapIter : clusterDistanceMap)
	  {
		  auto clu = mapIter.second;
		  clustersInRange.push_back(clu);
	  }
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ChargedFragmentsMergingAlgorithm3::GetEligibleClusters(std::vector<APRILCluster*>& clusterVector) const
  {
	clusterVector.clear();

    const pandora::ClusterList *pClusterList = NULL;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));

	//std::cout << ">>>cluster number: " << pClusterList->size() << std::endl;

    if(pClusterList->empty())
      return pandora::STATUS_CODE_SUCCESS;

    for(pandora::ClusterList::const_iterator clusterIter = pClusterList->begin(), clusterEndIter = pClusterList->end() ;
        clusterEndIter != clusterIter ; ++clusterIter)
    {
      const pandora::Cluster *const pCluster = *clusterIter;

      //if(!this->CanMergeCluster(pCluster))
      //  continue;

	  auto aprilCluster = APRILContentApi::Modifiable(dynamic_cast<const april_content::APRILCluster*>(pCluster));
      clusterVector.push_back(aprilCluster);
    }

	//std::sort(clusterVector.begin(), clusterVector.end(), pandora_monitoring::PandoraMonitoring::SortClustersByHadronicEnergy);
    std::sort(clusterVector.begin(), clusterVector.end(), SortingHelper::SortClustersByInnerLayer);
	std::reverse(std::begin(clusterVector), std::end(clusterVector));

#if 0
	for(auto& cluster : clusterVector)
	{
		std::cout << " cluster: " << cluster << ", E: " << cluster->GetHadronicEnergy() 
			<< ", layer: " << cluster->GetInnerPseudoLayer() << std::endl;
	}
#endif

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ChargedFragmentsMergingAlgorithm3::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    m_maxStartingClusterDistance = 1000.;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxStartingClusterDistance", m_maxStartingClusterDistance));

	m_maxClosestClusterDistance = 450.;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxClosestClusterDistance", m_maxClosestClusterDistance));

	m_debugOutput = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "DebugOutput", m_debugOutput));

	m_debugOutput2 = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "DebugOutput2", m_debugOutput2));

	m_onlyUseConnectedHits = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "OnlyUseConnectedHits", m_onlyUseConnectedHits));

	m_useMCPForPID = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "UseMCPForPID", m_useMCPForPID));

	m_makeRecord = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MakeRecord", m_makeRecord));

    return pandora::STATUS_CODE_SUCCESS;
  }

} 

