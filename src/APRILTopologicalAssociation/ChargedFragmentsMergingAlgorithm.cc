/// \file ChargedFragmentsMergingAlgorithm.cc
/*
 *
 * ChargedFragmentsMergingAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. avr. 9 2015
 *
 * This file is part of APRILContent libraries.
 * 
 * APRILContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * APRILContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with APRILContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

#include "Pandora/AlgorithmHeaders.h"
#include "PandoraMonitoringApi.h"
#include "PandoraMonitoring.h"

#include "APRILTopologicalAssociation/ChargedFragmentsMergingAlgorithm.h"

#include "APRILHelpers/SortingHelper.h"
#include "APRILHelpers/GeometryHelper.h"
#include "APRILHelpers/ReclusterHelper.h"
#include "APRILHelpers/ClusterHelper.h"
#include "APRILHelpers/HistogramHelper.h"
#include "APRILHelpers/ClusterPropertiesHelper.h"

#include "APRILApi/APRILContentApi.h"

#include "APRILUtility/EventPreparationAlgorithm.h"

#include "APRILTools/TrackDrivenSeedingTool.h"
#include "APRILObjects/CaloHit.h"

#include "TMath.h"

#include <algorithm>

namespace april_content
{
  pandora::StatusCode ChargedFragmentsMergingAlgorithm::Run()
  {
    // get candidate clusters for association
	std::vector<APRILCluster*> clusterVector;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->GetEligibleClusters(clusterVector));

	// get cluster properties
	for(int i = 0; i < clusterVector.size(); ++i)
	{
		auto pCluster = clusterVector.at(i);
		
		pCluster->Reset();

		pandora::CartesianVector centroid(0., 0., 0);
		ClusterHelper::GetCentroid(pCluster, centroid);
		pCluster->SetCentroid(centroid);
		
		const pandora::Cluster* const pandoraClu = dynamic_cast<const pandora::Cluster* const>(pCluster);
		bool isPhoton = PandoraContentApi::GetPlugins(*this)->GetParticleId()->IsPhoton(pandoraClu);

		if(m_useMCPForPID)
		{
			try
		    {
		    	isPhoton = pandora::MCParticleHelper::GetMainMCParticle(pandoraClu)->GetParticleId() == 22;
		    }
		    catch(pandora::StatusCodeException &)
		    {
		    	std::cout << "MCP issue: " << pandoraClu << std::endl;
		    }
		}

		pCluster->SetPhoton(isPhoton);

		if(m_debugOutput)
		{
			std::cout << " --- cluster : " << pCluster << ", energy: " << pCluster->GetHadronicEnergy() 
			      << ", COG: " << centroid.GetX() << ", " << centroid.GetY() << ", " << centroid.GetZ() << ", isPoton: " << isPhoton 
				  << ", associatedTrackList size: " << pCluster->GetAssociatedTrackList().size() << std::endl;
		}

		try
		{
		    pandora::ClusterFitResult clusterFitResult;

			// fit with only connected calo hits; if not successful, with all calo hits.
			pandora::StatusCode fitStatus;

			if(isPhoton)
			{
				// fit all connected calo hits
				fitStatus = ClusterHelper::FitFullCluster(pCluster, clusterFitResult);
			}
			else
			{
				// fit the main connected calo hits
				fitStatus = ClusterHelper::FitFullCluster(pCluster, clusterFitResult, true);
			}

			if(fitStatus)
			{
	            if(m_debugOutput2)
				{
					std::cout << " ---> fit all hits for cluster " << pCluster << ", E: " << pCluster->GetHadronicEnergy() << std::endl;
				}
				pandora::ClusterFitHelper::FitFullCluster(pCluster, clusterFitResult);
			}

		    const pandora::CartesianVector& cluDirection = clusterFitResult.GetDirection();
		    const pandora::CartesianVector& cluIntercept = clusterFitResult.GetIntercept();
			
			pCluster->SetAxis(cluDirection);
			pCluster->SetIntercept(cluIntercept);
		}
		catch(pandora::StatusCodeException &)
		{
	        if(m_debugOutput2)
			{
				std::cout << " ---> fitting cluster " << pCluster << ", E: " << pCluster->GetHadronicEnergy() << " failed." << std::endl;
			}
		}

		try
		{
		    pandora::ClusterFitResult clusterFitResult;

			if(ClusterHelper::FitStart(pCluster, 3, clusterFitResult) != pandora::STATUS_CODE_SUCCESS)
			{
				pandora::ClusterFitHelper::FitStart(pCluster, 3, clusterFitResult);
			}
			
			const pandora::CartesianVector& startingPoint = clusterFitResult.GetIntercept();

			pCluster->SetStartingPoint(startingPoint);


			// if cluster has connected with track, the intercept is taken as starting point and
			// the direction is computed from the hits in first 6 layers.
			const pandora::TrackList& associatedTrackList = pCluster->GetAssociatedTrackList();
		    int nAssociatedTracks = associatedTrackList.size();

			// re-compute axis and starting point for charged cluster
			if(nAssociatedTracks > 0)
			{
				pCluster->SetIntercept(startingPoint);

				if(nAssociatedTracks == 1)
				{
					const pandora::Track* associatedTrack = *( associatedTrackList.begin() );
					const pandora::CartesianVector trackDirectionAtCalo = 
						                           associatedTrack->GetTrackStateAtCalorimeter().GetMomentum().GetUnitVector();

					pCluster->SetAxis(trackDirectionAtCalo);
				}
				else
				{
				    if(pCluster->GetOrderedCaloHitList().size()>6)
				    {
				    	pandora::ClusterFitResult clusterFitResultChg;

				    	if(pandora::ClusterFitHelper::FitStart(pCluster, 6, clusterFitResultChg) != pandora::STATUS_CODE_SUCCESS)
				    	{
				    		pandora::ClusterFitHelper::FitStart(pCluster, 6, clusterFitResultChg);
				    	}

		                const pandora::CartesianVector& axis = clusterFitResultChg.GetDirection();
			
				    	pCluster->SetAxis(axis);
				    }
				}
			}
		}
		catch(pandora::StatusCodeException &)
		{
		}

		try
		{
		    pandora::ClusterFitResult clusterFitResult;
			pandora::ClusterFitHelper::FitEnd(pCluster, 3, clusterFitResult);
		    const pandora::CartesianVector& endpoint = clusterFitResult.GetIntercept();

			pCluster->SetEndpoint(endpoint);
		}
		catch(pandora::StatusCodeException &)
		{
		}
	}

	m_clustersToMerge.clear();

	for(int i = 0; i < clusterVector.size(); ++i)
	{
		auto cluster = clusterVector.at(i);

		// include a cluster in the vector even if it is identified as photon
		if( (cluster->GetAssociatedTrackList().size() == 0) )
		{
			m_clustersToMerge.push_back(cluster);
		}
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////

	std::vector<pandora::CartesianVector> m_clusterCentroids;

	for(auto clu : m_clustersToMerge)
	{
		auto& centroid = clu->GetCentroid();
		m_clusterCentroids.push_back(centroid);
	}

	CaloHitRangeSearchHelper::FillMatixByPoints(m_clusterCentroids, m_clusterCentroidsMatrix);

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// search nearby clusters along track
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////

    const pandora::TrackList *pTrackList = nullptr;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pTrackList));

	// set the cluster with track as root cluster
	for(auto track : *pTrackList)
	{
		if( !(track->HasAssociatedCluster()) ) continue;

		auto clu = track->GetAssociatedCluster();
		auto associatedCluster = APRILContentApi::Modifiable(dynamic_cast<const april_content::APRILCluster*>(clu));
		associatedCluster->SetRoot();
	}

	//
    if(m_mergeChargedClusters)
	{
		for(auto track : *pTrackList)
	    {
	    	// Reset the cluster for search
	        for(int i = 0; i < clusterVector.size(); ++i)
	    	{
	    		auto clu = clusterVector.at(i);
	    		clu->SetHasMotherAtSearch(false);
	    	}

	    	if( !(track->HasAssociatedCluster()) ) continue;

	    	auto clu = track->GetAssociatedCluster();
	    	auto associatedCluster = APRILContentApi::Modifiable(dynamic_cast<const april_content::APRILCluster*>(clu));

		    if(m_debugOutput)
			{
				std::cout << "     ---> SearchProperClusters from starting cluster: " << clu 
	    		          << ", track E: " << track->GetEnergyAtDca() << std::endl;
			}

	    	std::vector<APRILCluster*> properClusters;
	    	SearchProperClusters(track, associatedCluster, properClusters);
	    }
	}

	// clean clusters
	CleanClusterForMerging(clusterVector);
	
    return pandora::STATUS_CODE_SUCCESS;
  }

  void ChargedFragmentsMergingAlgorithm::SearchProperClusters(const pandora::Track* /* pTrack */, APRILCluster* startingCluster, 
		  std::vector<april_content::APRILCluster*>& properClusters)
  {
	  if(m_debugOutput)
	  {
		  const pandora::Cluster* const pandoraTrackStartClu = dynamic_cast<const pandora::Cluster* const>(startingCluster);
	      float startCluEnergy = startingCluster->GetHadronicEnergy();

	      auto pClusterMCParticle = pandora::MCParticleHelper::GetMainMCParticle(pandoraTrackStartClu);
	      std::cout << " SearchProperClusters for charged cluster: " << startingCluster << ", Ehad: " << startCluEnergy << ", MCP: " << pClusterMCParticle << std::endl;
	  }

	  std::vector<april_content::APRILCluster*> nearbyClusters;
	  GetNearbyClusters(startingCluster, m_clustersToMerge, nearbyClusters);

	  // map for sorting all nearby clusters by closest distance
	  std::multimap<float, APRILCluster*> clusterDistanceMap;

	  for(int i = 0; i < nearbyClusters.size(); ++i)
	  {
		  auto nearbyCluster = nearbyClusters.at(i);

		  if(nearbyCluster->HasMotherAtSearch() || nearbyCluster == startingCluster || nearbyCluster->IsRoot() || nearbyCluster->IsPhoton()) 
		  {
			  continue;
		  }

		  if(m_debugOutput)
		  {
			  std::cout << "nearbyClusters " << i << " : " << nearbyCluster << ", E: " << nearbyCluster->GetHadronicEnergy() << std::endl;
		  }

		  // GetClustersDistance
		  float closestDistance = 1.e6;

		  try
		  {
			  ClusterHelper::GetClosestDistanceApproach(startingCluster, nearbyCluster, closestDistance, m_onlyUseConnectedHits);
		  }
          catch(pandora::StatusCodeException &)
		  {
			  std::cout << "GetClosestDistanceApproach failed" << std::endl;
		  }

		  if(m_useMCPToRejectNeutralCluster)
		  {
			  try
		      {
		          const pandora::Cluster* const pandoraClu = dynamic_cast<const pandora::Cluster* const>(nearbyCluster);
		          auto pandoraCluMCP = pandora::MCParticleHelper::GetMainMCParticle(pandoraClu);

		          if( pandora::PdgTable::GetParticleCharge(pandoraCluMCP->GetParticleId()) == 0. && 
		              nearbyCluster->GetHadronicEnergy() > 0. )
		          {
		            		continue;
		          }
		      }
		      catch(pandora::StatusCodeException &)
		      {
		      }
		  }

		  float angle = 1.e6;
		  float axesDistance = 1.e6;
		  bool isAxesCompatible = false;

		  try
		  {
			  angle = ClusterHelper::GetClusterAxisStartingPointAngle(nearbyCluster);
			  isAxesCompatible = IsClusterAxesCompatible(startingCluster, nearbyCluster, axesDistance); 
		  }
		  catch(...)
		  {
			  if(m_debugOutput2)
			  {
				  std::cout << "    === Axis error, cluster " << nearbyCluster << ", E: " << nearbyCluster->GetHadronicEnergy() << std::endl;
			  }
		  }

		  // FIXME
		  bool isMergingCandidate = 
//				  closestDistance < m_maxClosestClusterDistance ||  // very close cluster
			      ( angle > m_maxClusterPosAxisAngle && isAxesCompatible );           // clusters with compatible axes

	      if(m_debugOutput2)
		  {
			  std::cout << " @_@ Check clusters @_@: " << std::endl
		      << "  startingCluster: " << startingCluster << ", E: " << startingCluster->GetHadronicEnergy() << std::endl
		      << "  nearbyCluster: " << nearbyCluster << ", E: " << nearbyCluster->GetHadronicEnergy() << std::endl
		      << "  closestDistance: " << closestDistance << ", angle: " << angle 
			  << ", axesDistance: " << axesDistance << ", isAxesCompatible: " << isAxesCompatible << std::endl;
		  }

		  if(isMergingCandidate) 
		  {
		      std::vector<float> clusterParameters;

		      clusterParameters.push_back(closestDistance);
		      clusterParameters.push_back(angle); // axis angle
		      clusterParameters.push_back(axesDistance);

		      std::vector<float> parameterPowers;
		      parameterPowers.push_back(5.);
		      parameterPowers.push_back(3.);
		      parameterPowers.push_back(1.);

		      ClustersOrderParameter orderParameter(clusterParameters, parameterPowers);
		      nearbyCluster->SetOrderParameterWithMother(startingCluster, orderParameter);

		      clusterDistanceMap.insert( std::pair<float, APRILCluster*>(closestDistance, nearbyCluster) );
		  }
		  else
		  {
	          if(m_debugOutput2) 
			  {
				  std::cout << "    --- Not a merging cadidate" << std::endl;
			  }
		  }

	      if(m_debugOutput2)
		  {
			  std::cout << "-----------------------------------------------------------------------------------------" << std::endl;
		  }
      }
		  
	  for(auto it = clusterDistanceMap.begin(); it != clusterDistanceMap.end(); ++it)
	  {
		  auto nearbyCluster = it->second;

		  properClusters.push_back(nearbyCluster);
		  nearbyCluster->SetHasMotherAtSearch();
	  }

	  startingCluster->SetClustersToMerge(properClusters);
		
	  if(m_debugOutput)
	  {
		  std::cout << "-----------------------------------------------------------------------------------------------------------" << std::endl;
	  }
  }

  bool ChargedFragmentsMergingAlgorithm::IsClusterAxesCompatible(const APRILCluster* startingCluster, const APRILCluster* nearbyCluster, float& axesDistance)
  {
	  bool isAxesCompatible = true;

	  auto& cluster1Axis = startingCluster->GetAxis();
	  auto& cluster2Axis = nearbyCluster->GetAxis();

	  // FIXME: intercept or starting point ?
	  auto& cog1 = startingCluster->GetCentroid();
	  auto& cog2 = nearbyCluster->GetCentroid();
	  auto directionOfCentroids = cog1 - cog2;

	  // redefition
	  auto d1 = cluster1Axis;
	  auto d2 = cluster2Axis;

	  auto x1 = cog1;
	  auto x2 = cog2;
	
	  // 
	  auto n1 = d1.GetCrossProduct(d2.GetCrossProduct(d1));
	  auto n2 = d2.GetCrossProduct(d1.GetCrossProduct(d2));

	  // the nearest points
	  auto Np1 = d1;
	  Np1 *= (x2-x1).GetDotProduct(n2)/(d1.GetDotProduct(n2));
	  Np1 += x1;

	  auto Np2 = d2;
	  Np2 *= (x1-x2).GetDotProduct(n1)/(d2.GetDotProduct(n1));
	  Np2 += x2;

	  float distCOGNp1 = (x1 - Np1).GetMagnitude();
	  float distCOGNp2 = (x2 - Np2).GetMagnitude();

	  auto cluster1StartingPoint = startingCluster->GetStartingPoint();
	  auto cluster2StartingPoint = nearbyCluster->GetStartingPoint();

	  auto pStart = cluster2StartingPoint - Np2;

	  int pSign = TMath::Sign(1, pStart.GetDotProduct(d2));

	  if(m_debugOutput2)
	  {
		  std::cout << "       === ClusterAxesDistance === " << std::endl
		        << " E1: " << startingCluster->GetHadronicEnergy() << ", E2: " << nearbyCluster->GetHadronicEnergy() << std::endl
		        << " cluster1Axis: " << cluster1Axis.GetX() << ", " << cluster1Axis.GetY() << ", " << cluster1Axis.GetZ() << std::endl
		        << " cluster2Axis: " << cluster2Axis.GetX() << ", " << cluster2Axis.GetY() << ", " << cluster2Axis.GetZ() << std::endl
				<< " COG1: " << cog1.GetX() << ", " << cog1.GetY() << ", " << cog1.GetZ() << std::endl
				<< " COG2: " << cog2.GetX() << ", " << cog2.GetY() << ", " << cog2.GetZ() << std::endl
				<< " d_cog: " << directionOfCentroids.GetMagnitude() << std::endl
				<< " Np1: " << Np1.GetX() << ", " << Np1.GetY() << ", " << Np1.GetZ() << ", distToCOG: " << distCOGNp1 << std::endl
				<< " Np2: " << Np2.GetX() << ", " << Np2.GetY() << ", " << Np2.GetZ() << ", distToCOG: " << distCOGNp2 << std::endl
				<< " Cluster1 starting point: " << cluster1StartingPoint.GetX() << ", " << cluster1StartingPoint.GetY() << ", " << cluster1StartingPoint.GetZ() << std::endl
				<< " Cluster2 starting point: " << cluster2StartingPoint.GetX() << ", " << cluster2StartingPoint.GetY() << ", " << cluster2StartingPoint.GetZ() << std::endl
				<< " Angle sign: " << pSign 
				<< std::endl;
	  }

	  auto directionsCrossProd = cluster2Axis.GetCrossProduct(cluster1Axis);
	  axesDistance = fabs(directionsCrossProd.GetDotProduct(directionOfCentroids)) / directionsCrossProd.GetMagnitude();

	  // 
	  if(std::isnan(axesDistance))
	  {
		  isAxesCompatible = false;
	      return isAxesCompatible;
	  }

	  if( axesDistance > m_maxClusterAxesDistance)
	  {
		  isAxesCompatible = false;
	      return isAxesCompatible;
	  }

	  if( pSign == -1)
	  {
		  isAxesCompatible = false;
	      return isAxesCompatible;
	  }

	  if(distCOGNp1 > 400. && distCOGNp2 > 400.) // nearest points maybe outside the clusters
	  {
		  isAxesCompatible = false;
	      return isAxesCompatible;
	  }

	  pandora::HitRegion startingClusterRegion = ClusterHelper::GetRegion(startingCluster);
	  pandora::HitRegion nearbyClusterRegion = ClusterHelper::GetRegion(nearbyCluster);

	  if(startingClusterRegion == pandora::BARREL && nearbyClusterRegion == pandora::BARREL)
	  {
		  pandora::CartesianVector startingClusterPoint = startingCluster->GetStartingPoint();

		  float startingPointRadius;
		  float startingPointPhi;
		  float startingPointZ;
		  startingClusterPoint.GetCylindricalCoordinates(startingPointRadius, startingPointPhi, startingPointZ);

		  float nearestPointRadius;
		  float nearestPointPhi;
		  float nearestPointZ;
		  Np1.GetCylindricalCoordinates(nearestPointRadius, nearestPointPhi, nearestPointZ);
		  //std::cout << "         ----startingClusterPoint: " << startingClusterPoint.GetX() << ", " << startingClusterPoint.GetY() << ", " << ", " << startingClusterPoint.GetZ() << ", R: " << startingPointRadius << std::endl;
		  //std::cout << "         ----Np1: " << Np1.GetX() << ", " << Np1.GetY() << ", " << ", " << Np1.GetZ() << ", R: " << nearestPointRadius << std::endl;

		  if(nearestPointRadius < startingPointRadius - 10.) isAxesCompatible = false;

		  // TODO
		  // get the maximum radius of connected hits
		  //if(nearestPointRadius > startingPointRadius + 100.) isAxesCompatible = false;
	  }

	  return isAxesCompatible;
  }

  void ChargedFragmentsMergingAlgorithm::GetNearbyClusters(pandora::Cluster* cluster, 
		  const std::vector<april_content::APRILCluster*>& clusterVector, std::vector<april_content::APRILCluster*>& clustersInRange)
  {
      pandora::CartesianVector centroid(0., 0., 0.);
	  ClusterHelper::GetCentroid(cluster, centroid);

	  const float distance = m_maxStartingClusterDistance;
	  const mlpack::math::Range range(0., distance);

      arma::mat testPoint(3, 1);
	  testPoint.col(0)[0] = centroid.GetX();
	  testPoint.col(0)[1] = centroid.GetY();
	  testPoint.col(0)[2] = centroid.GetZ();
	  
	  mlpack::range::RangeSearch<> rangeSearch(m_clusterCentroidsMatrix);
      std::vector<std::vector<size_t> > resultingNeighbors;
      std::vector<std::vector<double> > resultingDistances;
      rangeSearch.Search(testPoint, range, resultingNeighbors, resultingDistances);

      std::vector<size_t>& neighbors = resultingNeighbors.at(0);
      std::vector<double>& distances = resultingDistances.at(0);
	  
      for(size_t j=0; j < neighbors.size(); ++j)
      {
      	size_t neighbor = neighbors.at(j);
      	//double hitsDist = distances.at(j);

		clustersInRange.push_back( clusterVector.at(neighbor) );
	  }

	  // sort cluster by distance
	  std::multimap<float, APRILCluster*> clusterDistanceMap;

	  for(int i = 0; i < clustersInRange.size(); ++i)
	  {
		  auto clusterInRange = clustersInRange.at(i);

		  clusterDistanceMap.insert( std::pair<float, APRILCluster*>(distances.at(i), clusterInRange) );
	  }

	  clustersInRange.clear();

	  for(auto& mapIter : clusterDistanceMap)
	  {
		  auto clu = mapIter.second;
		  clustersInRange.push_back(clu);
	  }
  }

  pandora::StatusCode ChargedFragmentsMergingAlgorithm::CleanClusterForMerging(std::vector<APRILCluster*>& clusterVector)
  {
	for(int i = 0; i < clusterVector.size(); ++i)
	{
		auto& cluster = clusterVector.at(i);

		auto& mothers = cluster->GetMotherCluster();

		if(m_debugOutput)
		{
			std::cout << " --- cluster " << cluster << " mothers: " << mothers.size() << ", root?: " << cluster->IsRoot() << std::endl;
		}

		// find the best one
		ClustersOrderParameter bestOrderParameter;
		APRILCluster* bestCluster;

		for(int iMother = 0; iMother < mothers.size(); ++iMother)
		{
			auto mother = mothers.at(iMother);
			ClustersOrderParameter orderParameter = cluster->GetOrderParameterWithMother(mother);

			if(orderParameter < bestOrderParameter)
			{
				bestOrderParameter = orderParameter;
				bestCluster = mother;
			}
		}

		// take the best one
		if(mothers.size() > 1)
		{
			for(int iMother = 0; iMother < mothers.size(); ++iMother)
			{
				auto mother = mothers.at(iMother);

				if(mother != bestCluster)
				{
					if(m_debugOutput)
					{
						std::cout << " !!! cluster: " << mother << " remove cluster to merge: " << cluster << std::endl;
					}

					mother->RemoveFromClustersToMerge(cluster);
				}
			}

			mothers.clear();
			mothers.push_back(bestCluster);
		}
	}

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ChargedFragmentsMergingAlgorithm::GetEligibleClusters(std::vector<APRILCluster*>& clusterVector) const
  {
	clusterVector.clear();

    const pandora::ClusterList *pClusterList = NULL;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));

	//std::cout << ">>>cluster number: " << pClusterList->size() << std::endl;

    if(pClusterList->empty())
      return pandora::STATUS_CODE_SUCCESS;

    for(pandora::ClusterList::const_iterator clusterIter = pClusterList->begin(), clusterEndIter = pClusterList->end() ;
        clusterEndIter != clusterIter ; ++clusterIter)
    {
      const pandora::Cluster *const pCluster = *clusterIter;

      //if(!this->CanMergeCluster(pCluster))
      //  continue;

	  auto aprilCluster = APRILContentApi::Modifiable(dynamic_cast<const april_content::APRILCluster*>(pCluster));
      clusterVector.push_back(aprilCluster);
    }

    // sort them by inner layer
    std::sort(clusterVector.begin(), clusterVector.end(), SortingHelper::SortClustersByInnerLayer);

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ChargedFragmentsMergingAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    m_maxStartingClusterDistance = 1000.;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxStartingClusterDistance", m_maxStartingClusterDistance));

	m_maxClosestClusterDistance = 500.;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxClosestClusterDistance", m_maxClosestClusterDistance));

	m_maxClusterPosAxisAngle = 0.4;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxClusterPosAxisAngle", m_maxClusterPosAxisAngle));

	m_maxClusterAxesDistance = 100.;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxClusterAxesDistance", m_maxClusterAxesDistance));

	m_mergeChargedClusters = true;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MergeChargedClusters", m_mergeChargedClusters));

	m_debugOutput = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "DebugOutput", m_debugOutput));

	m_debugOutput2 = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "DebugOutput2", m_debugOutput2));

	m_onlyUseConnectedHits = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "OnlyUseConnectedHits", m_onlyUseConnectedHits));

	m_useMCPForPID = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "UseMCPForPID", m_useMCPForPID));

	m_useMCPToRejectNeutralCluster = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "UseMCPToRejectNeutralCluster", m_useMCPToRejectNeutralCluster));

    return pandora::STATUS_CODE_SUCCESS;
  }

} 

