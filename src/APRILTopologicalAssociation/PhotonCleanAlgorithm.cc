/// \file PhotonCleanAlgorithm.cc
/*
 *
 * PhotonCleanAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. juin 30 2016
 *
 * This file is part of APRILContent libraries.
 * 
 * APRILContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * APRILContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with APRILContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "APRILTopologicalAssociation/PhotonCleanAlgorithm.h"

#include "Pandora/AlgorithmHeaders.h"

#include "APRILHelpers/SortingHelper.h"
#include "APRILHelpers/GeometryHelper.h"
#include "APRILHelpers/ReclusterHelper.h"
#include "APRILHelpers/ClusterHelper.h"
#include "APRILHelpers/CaloHitHelper.h"
#include "APRILTools/CaloHitMergingTool.h"
#include "APRILHelpers/HistogramHelper.h"
#include "APRILPlugins/ParticleIdPlugins.h"

namespace april_content
{

  pandora::StatusCode PhotonCleanAlgorithm::Run()
  {
	std::cout << "======= PhotonCleanAlgorithm ====== " << std::endl;

    const pandora::ClusterList *pClusterList = NULL;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));

    if(pClusterList->empty())
      return pandora::STATUS_CODE_SUCCESS;

	APRILParticleIdPlugins::APRILPhotonId::SetRecord(m_recordPhotonIDInfo);

    // loop over clusters
    for(auto clusterIter = pClusterList->begin(), clusterEndIter = pClusterList->end();
        clusterEndIter != clusterIter ; ++clusterIter)
    {
      const pandora::Cluster *const pCluster(*clusterIter);

	  try
	  {
		 bool isPhoton = PandoraContentApi::GetPlugins(*this)->GetParticleId()->IsPhoton(pCluster);

		 if(m_recordPhotonIDResult)
		 {
			 auto pClusterMCParticle = pandora::MCParticleHelper::GetMainMCParticle(pCluster);
	         int clusterPID = pClusterMCParticle->GetParticleId();
	         int clusterMCPCharge = pandora::PdgTable::GetParticleCharge(clusterPID);
		     float clusterEnergy = pCluster->GetElectromagneticEnergy();
		     int clusterSize = pCluster->GetNCaloHits();


	         std::vector<float> vars;
	         vars.push_back( float(clusterPID) );
	         vars.push_back( float(clusterMCPCharge) );
	         vars.push_back( float(isPhoton) );
	         vars.push_back( clusterEnergy );
	         vars.push_back( float(clusterSize) );
	         vars.push_back( float(pCluster->GetAssociatedTrackList().empty()) );
		
		     HistogramManager::CreateFill("PhotonID_PhotonCleanAlgorithm", "PID_MC:clusterChg_MC:isPhoton:clusterEnergy:clusterSize:noTrack", vars);
		 }

#if 0
         bool isPhoton1 = pCluster->PassPhotonId(this->GetPandora()) && pCluster->GetAssociatedTrackList().empty();
		 if(isPhoton != isPhoton1) 
		 {
			 std::cout << " --- cluster: " << pCluster << ", Ehad: " << pCluster->GetHadronicEnergy() 
				       << ", isPhoton: " << isPhoton << ", isPhoton1: " << isPhoton1 << std::endl;
		 }
#endif
	  
		 if(isPhoton)
		 {
#if 0
			 std::cout << " --- cluster: " << pCluster << ", Ehad: " << pCluster->GetHadronicEnergy() 
				       << ", clusterPID: " << clusterPID << ", chg: " << clusterMCPCharge 
			           << ", isPhoton :" <<  pCluster->PassPhotonId(this->GetPandora()) 
					   << ", averageTime: " << ClusterHelper::GetAverageTime(pCluster) << std::endl;
#endif

	         pandora::CaloHitList clusterCaloHitList;
	         pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

		     pandora::CartesianVector centroid(0., 0., 0);
		     ClusterHelper::GetCentroid(pCluster, centroid);

	         for(auto hitIter = clusterCaloHitList.begin(); hitIter != clusterCaloHitList.end(); ++hitIter)
	         {
	         	auto pCaloHit = *hitIter;

				//pandora::CartesianVector hitPos = pCaloHit->GetPositionVector();
				//pandora::CartesianVector posDiff = hitPos - centroid;
	            //std::cout << "hit time: " << pCaloHit->GetTime() << ", ditanct to COG: " << posDiff.GetMagnitude() << std::endl;
				float hitTime = pCaloHit->GetTime();

				if(hitTime > m_maxHitTimeForClean)
				{
					APRILContentApi::RemoveFromCluster(*this, pCluster, pCaloHit);
				}
	         }
		 }
	  }
	  catch (pandora::StatusCodeException &)
	  {
	  }
	}

	APRILParticleIdPlugins::APRILPhotonId::SetRecord(false);

    return pandora::STATUS_CODE_SUCCESS;

  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode PhotonCleanAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    m_maxHitTimeForClean = 11.;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxHitTimeForClean", m_maxHitTimeForClean));

	m_recordPhotonIDInfo = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "RecordPhotonIDInfo", m_recordPhotonIDInfo));

	m_recordPhotonIDResult = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "RecordPhotonIDResult", m_recordPhotonIDResult));

    return pandora::STATUS_CODE_SUCCESS;
  }

}
