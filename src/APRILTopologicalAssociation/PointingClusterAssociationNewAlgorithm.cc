/// \file PointingClusterAssociationNewAlgorithm.cc
/*
 *
 * PointingClusterAssociationNewAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. avr. 9 2015
 *
 * This file is part of APRILContent libraries.
 * 
 * APRILContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * APRILContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with APRILContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

#include "Pandora/AlgorithmHeaders.h"

#include "APRILTopologicalAssociation/PointingClusterAssociationNewAlgorithm.h"

#include "APRILHelpers/SortingHelper.h"
#include "APRILHelpers/GeometryHelper.h"
#include "APRILHelpers/ReclusterHelper.h"
#include "APRILHelpers/ClusterHelper.h"
#include "APRILHelpers/HistogramHelper.h"
#include "APRILHelpers/ClusterPropertiesHelper.h"

#include "APRILApi/APRILContentApi.h"

#include "APRILUtility/EventPreparationAlgorithm.h"

#include "APRILTools/TrackDrivenSeedingTool.h"
#include "APRILObjects/CaloHit.h"

#include <algorithm>

namespace april_content
{
  pandora::StatusCode PointingClusterAssociationNewAlgorithm::Run()
  {
    // get candidate clusters for association
	std::vector<APRILCluster*> clusterVector;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->GetEligibleClusters(clusterVector));

	// get cluster properties
	for(int i = 0; i < clusterVector.size(); ++i)
	{
		auto pCluster = clusterVector.at(i);

		//std::cout << " --- cluster : " << pCluster << ", energy: " << pCluster->GetHadronicEnergy() << std::endl;
		pandora::CartesianVector centroid(0., 0., 0);
		ClusterHelper::GetCentroid(pCluster, centroid);
		pCluster->SetCentroid(centroid);
		
		const pandora::Cluster* const pandoraClu = dynamic_cast<const pandora::Cluster* const>(pCluster);
		bool isPhoton = PandoraContentApi::GetPlugins(*this)->GetParticleId()->IsPhoton(pandoraClu);
		pCluster->SetPhoton(isPhoton);

		try
		{
		    pandora::ClusterFitResult clusterFitResult;
		    pandora::ClusterFitHelper::FitFullCluster(pCluster, clusterFitResult);
		    const pandora::CartesianVector& cluDirection = clusterFitResult.GetDirection();
		    const pandora::CartesianVector& cluIntercept = clusterFitResult.GetIntercept();
		    //std::cout << "  *** direction_f: " << cluDirection.GetX() << ", " << cluDirection.GetY() << ", " << cluDirection.GetZ() << std::endl;
		    //std::cout << "  *** intercept_f: " << cluIntercept.GetX() << ", " << cluIntercept.GetY() << ", " << cluIntercept.GetZ() << std::endl;
			
			pCluster->SetAxis(cluDirection);
			pCluster->SetIntercept(cluIntercept);
		}
		catch(pandora::StatusCodeException &)
		{
			//std::cout << "Fit failed, cluster: " << pCluster << ", E: " << pCluster->GetHadronicEnergy() << std::endl;
			//continue;
		}

		try
		{
		    pandora::ClusterFitResult clusterFitResult;
			pandora::ClusterFitHelper::FitStart(pCluster, 3, clusterFitResult);
		    const pandora::CartesianVector& startingPoint = clusterFitResult.GetIntercept();

		    //std::cout << "  *** startingPoint: " << startingPoint.GetX() << ", " << startingPoint.GetY() << ", " << startingPoint.GetZ() << std::endl;

			pCluster->SetStartingPoint(startingPoint);
		}
		catch(pandora::StatusCodeException &)
		{
			//std::cout << "Fit failed, cluster: " << pCluster << ", E: " << pCluster->GetHadronicEnergy() << std::endl;
			//continue;
		}

		try
		{
		    pandora::ClusterFitResult clusterFitResult;
			pandora::ClusterFitHelper::FitEnd(pCluster, 3, clusterFitResult);
		    const pandora::CartesianVector& endpoint = clusterFitResult.GetIntercept();

		    //std::cout << "  *** endpoint: " << endpoint.GetX() << ", " << endpoint.GetY() << ", " << endpoint.GetZ() << std::endl;

			pCluster->SetEndpoint(endpoint);
		}
		catch(pandora::StatusCodeException &)
		{
			//std::cout << "Fit failed, cluster: " << pCluster << ", E: " << pCluster->GetHadronicEnergy() << std::endl;
			continue;
		}
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	TrackCaloHitVector& trackCaloHits = TrackDrivenSeedingTool::GetTrackAndInitCaloHits();

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	pandora::TrackVector trackWithCaloHitsVector;
	pandora::TrackVector trackWithoutCaloHitsVector;

	for(auto trackCaloHitsIter = trackCaloHits.begin(); trackCaloHitsIter != trackCaloHits.end(); ++trackCaloHitsIter)
	{
		auto pTrack = trackCaloHitsIter->first;
		auto& caloHits = trackCaloHitsIter->second;

		if(caloHits.size() > 0)
		{
			trackWithCaloHitsVector.push_back(pTrack);
		}
		else
		{
			trackWithoutCaloHitsVector.push_back(pTrack);
		}
	}

	//
    std::sort(trackWithCaloHitsVector.begin(), trackWithCaloHitsVector.end(), SortingHelper::SortTracksByMomentum);

	int nClusterWithTrack = 0;

	std::vector<APRILCluster*> trackStartingClusters;

	for(int iTrack = trackWithCaloHitsVector.size() - 1; iTrack >= 0; --iTrack)
	{
		auto pTrack = trackWithCaloHitsVector.at(iTrack);
		pandora::CaloHitVector& caloHits = trackCaloHits.find(pTrack)->second;

		//std::cout << " **************************** track p: " << pTrack->GetMomentumAtDca().GetMagnitude() << std::endl;

		auto mainCluster = GetMainCluster(caloHits);
		if(mainCluster == nullptr) continue;
		//std::cout << "main cluster: " << mainCluster << std::endl;
		
		// make track-cluster association
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::AddTrackClusterAssociation(*this, pTrack, mainCluster));

		trackStartingClusters.push_back(mainCluster);

		++nClusterWithTrack;

		// ---------- make the record of track-cluster association
		bool makeRecord = true;

		if(makeRecord)
		{
			const pandora::MCParticle *pTrackMCParticle = nullptr;
            const pandora::MCParticle *pClusterMCParticle = nullptr;

            try
            {
		        pTrackMCParticle = pandora::MCParticleHelper::GetMainMCParticle( pTrack );
            }
            catch (pandora::StatusCodeException &)
            {
		    	continue;
            }

            try
            {
				const pandora::Cluster* const pCluster = dynamic_cast<const pandora::Cluster* const>(mainCluster);
		        pClusterMCParticle = pandora::MCParticleHelper::GetMainMCParticle( pCluster );
            }
            catch (pandora::StatusCodeException &)
            {
		    	continue;
            }

		    if(pTrackMCParticle == nullptr || pClusterMCParticle == nullptr) continue;

		    ///
	        std::vector<float> vars;
	        vars.push_back( float(EventPreparationAlgorithm::GetEventNumber()) );
	        vars.push_back( pTrack->GetMomentumAtDca().GetMagnitude() );
		    vars.push_back( float(pTrack->IsProjectedToEndCap()) );
		    vars.push_back( float(caloHits.size()) );
		    vars.push_back( float(pTrackMCParticle == pClusterMCParticle) );
	
		    HistogramManager::CreateFill("PointingClusterAssociation_TrackCheck", "evtNum:trackMomentum:reachEndcap:nCaloHit:isRightMatch", vars);
		}

	}

	//std::cout << "nClusterWithTrack : " << nClusterWithTrack << std::endl;

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////

	m_clustersToMerge.clear();
	
	for(int i = 0; i < clusterVector.size(); ++i)
	{
		auto cluster = clusterVector.at(i);

		if(cluster->GetAssociatedTrackList().size() == 0)
		{
			m_clustersToMerge.push_back(cluster);
		}
	}

	std::vector<pandora::CartesianVector> m_clusterCentroids;

	for(auto clu : m_clustersToMerge)
	{
		auto& centroid = clu->GetCentroid();
		m_clusterCentroids.push_back(centroid);
	}

	CaloHitRangeSearchHelper::FillMatixByPoints(m_clusterCentroids, m_clusterCentroidsMatrix);

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// get nearby clusters for each starting charged cluster
	
	for(int i = 0; i < trackStartingClusters.size(); ++i)
	{
		auto trackStartCluster = trackStartingClusters.at(i);

		//std::cout << "     ---> cluster's nearby clusters: " << nearbyClusters.size() << std::endl;
		std::vector<APRILCluster*> properClusters;
		SearchProperClusters(trackStartCluster, properClusters);
	}

	for(int i = 0; i < trackStartingClusters.size(); ++i)
	{
		auto& trackStartCluster = trackStartingClusters.at(i);

		std::set<APRILCluster*> allClustersToMerge;
		trackStartCluster->GetAllClustersToMerge(allClustersToMerge);

		//for(int iClu = 0; iClu < allClustersToMerge.size(); ++iClu)
		for(auto& cluToMerge : allClustersToMerge)
		{
			//auto& cluToMerge = allClustersToMerge.at(iClu);

			if(cluToMerge != nullptr)
			{
	            const pandora::Cluster* const pandoraTrackStartClu = dynamic_cast<const pandora::Cluster* const>(trackStartCluster);
	            auto pClusterMCParticle = pandora::MCParticleHelper::GetMainMCParticle(pandoraTrackStartClu);

	            const pandora::Cluster* const pandoraClusterToMerge = dynamic_cast<const pandora::Cluster* const>(cluToMerge);
	            auto pClusterToMergeMCParticle = pandora::MCParticleHelper::GetMainMCParticle(pandoraClusterToMerge);

				//std::cout << "   ---> cluster: " << trackStartCluster << " merging cluster: " << cluToMerge << std::endl;
	            std::vector<float> vars;
	            vars.push_back( float(EventPreparationAlgorithm::GetEventNumber()) );
	            vars.push_back( trackStartCluster->GetHadronicEnergy() );
	            vars.push_back( cluToMerge->GetHadronicEnergy() );
	            vars.push_back( float(pClusterMCParticle == pClusterToMergeMCParticle) );

		        HistogramManager::CreateFill("PointingClusterAssociation_Merging", "evtNum:clusterEnergy:mergeEnergy:isRight", vars);

				if(pClusterMCParticle != pClusterToMergeMCParticle)
				{
					std::cout << "merging error!!! main cluster: " << trackStartCluster << ", E: " << trackStartCluster->GetHadronicEnergy()
						      << " merging cluster: " << cluToMerge << ", E: " << cluToMerge->GetHadronicEnergy() << std::endl;
				}

				APRILContentApi::MergeAndDeleteClusters(*this, trackStartCluster, cluToMerge);
			}
		}
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////
    std::sort(trackWithoutCaloHitsVector.begin(), trackWithoutCaloHitsVector.end(), SortingHelper::SortTracksByMomentum);
	// search nearby cluster around these tracks
		
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////
		

#if 0
	// For Test
	
	// divide the vector of cluster into two
	pandora::ClusterVector startingClusters;
	pandora::ClusterVector subsequentClusters;

	for(int i = 0; i < clustersToMerge.size(); ++i)
	{
		auto cluster = clustersToMerge.at(i);

		if(cluster->GetAssociatedTrackList().size() > 0)
		{
		   std::cout << "cluster which should not here: " << cluster << std::endl;
		}

	    unsigned int innerLayer = cluster->GetInnerPseudoLayer();
		//std::cout << "cluster inner layer: " << innerLayer << std::endl;

		if(innerLayer <= 10)
		{
			startingClusters.push_back(cluster);
		}
		else
		{
			subsequentClusters.push_back(cluster);
		}
	}

	for(int i = 0; i < startingClusters.size(); ++i)
	{
		auto cluster = startingClusters.at(i);
	    unsigned int innerLayer = cluster->GetInnerPseudoLayer();

		std::cout << "*cluster  " << i << " : " << cluster << ", Ehad: " << cluster->GetHadronicEnergy() 
			<< ", inner layer: " << innerLayer << std::endl;
	}

	for(int i = 0; i < subsequentClusters.size(); ++i)
	{
		auto cluster = subsequentClusters.at(i);
	    unsigned int innerLayer = cluster->GetInnerPseudoLayer();

		std::cout << "cluster  " << i << " : " << cluster << ", Ehad: " << cluster->GetHadronicEnergy() 
			<< ", inner layer: " << innerLayer << std::endl;
	}
#endif

	

	// ----------------------------------------------------------------
#if 0
    const pandora::ClusterList *pClusterList = NULL;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));

	for(auto cluster : *pClusterList)
	{
		const pandora::MCParticle *pClusterMCParticle = nullptr;

        try
        {
		    pClusterMCParticle = pandora::MCParticleHelper::GetMainMCParticle(cluster);
        }
        catch (pandora::StatusCodeException &)
        {
			continue;
        }

		bool isPhotonMC = (pClusterMCParticle->GetParticleId() == 22);
		bool isPhoton = PandoraContentApi::GetPlugins(*this)->GetParticleId()->IsPhoton(cluster);

#if 1
		if(isPhotonMC!=isPhoton)
		{
			//std::cout << "cluster: " << cluster << ", energy: " << cluster->GetHadronicEnergy() << ", isPhotonMC: " 
			//	      << isPhotonMC << ", isPhoton: " << isPhoton << std::endl;
		}
#endif

	    std::vector<float> vars;
	    vars.push_back( float(EventPreparationAlgorithm::GetEventNumber()) );
	    vars.push_back( cluster->GetHadronicEnergy() );
		vars.push_back( float(pClusterMCParticle->GetParticleId()) );
		vars.push_back( float(isPhotonMC) );
		vars.push_back( float(isPhoton) );
	
		HistogramManager::CreateFill("PointingClusterAssociation_photonID", "evtNum:clusterHadEnergy:pdg:isPhotonMC:isPhoton", vars);

#if 0
		//-------------
		if(cluster->GetHadronicEnergy() > 1.)
		{
	       float minHitLayer, clusterVol, energyRatio, hitOutsideRatio, axisLengthRatio, shortAxisLengthRatio;
	       TVector3 axis;

           ClusterPropertiesHelper::CalcClusterProperties(cluster, minHitLayer, clusterVol, energyRatio, 
		                                  hitOutsideRatio, axisLengthRatio, shortAxisLengthRatio, axis);

		   if(isPhotonMC)
		   {
		   	std::vector<float> vars;
		   	vars.push_back(minHitLayer);
		   	vars.push_back(clusterVol);
		   	vars.push_back(energyRatio);
		   	vars.push_back(hitOutsideRatio);
		   	vars.push_back(axisLengthRatio);
		   	vars.push_back(shortAxisLengthRatio);
		   	vars.push_back( float(cluster->GetAssociatedTrackList().size()) );

		   	HistogramManager::CreateFill("PointingClusterAssociation_isPhoton", "minHitLayer:clusterVol:energyRatio:hitOutsideRatio:axisLengthRatio:shortAxisLengthRatio:nTracks", vars);
		   }
		   else
		   {
		   	std::vector<float> vars;
		   	vars.push_back(minHitLayer);
		   	vars.push_back(clusterVol);
		   	vars.push_back(energyRatio);
		   	vars.push_back(hitOutsideRatio);
		   	vars.push_back(axisLengthRatio);
		   	vars.push_back(shortAxisLengthRatio);
		   	vars.push_back( float(cluster->GetAssociatedTrackList().size()) );

		   	HistogramManager::CreateFill("PointingClusterAssociation_notPhoton", "minHitLayer:clusterVol:energyRatio:hitOutsideRatio:axisLengthRatio:shortAxisLengthRatio:nTracks", vars);
		   }
		}
#endif
	}
#endif

    return pandora::STATUS_CODE_SUCCESS;
  }

#define __DEBUG__ 0
//#define __DEBUG__ 1

  void PointingClusterAssociationNewAlgorithm::SearchProperClusters(APRILCluster* startingCluster, 
		  std::vector<april_content::APRILCluster*>& properClusters)
  {
#if __DEBUG__
	  const pandora::Cluster* const pandoraTrackStartClu = dynamic_cast<const pandora::Cluster* const>(startingCluster);
	  float startCluEnergy = startingCluster->GetHadronicEnergy();

	  auto pClusterMCParticle = pandora::MCParticleHelper::GetMainMCParticle(pandoraTrackStartClu);
	  std::cout << "cluster: " << startingCluster << ", Ehad: " << startCluEnergy << ", MCP: " << pClusterMCParticle << std::endl;
#endif

	  std::vector<april_content::APRILCluster*> nearbyClusters;
	  GetNearbyClusters(startingCluster, m_clustersToMerge, nearbyClusters);

	  // map for sorting all nearby clusters by closest distance
	  std::multimap<float, APRILCluster*> clusterDistanceMap;

	  for(int i = 0; i < nearbyClusters.size(); ++i)
	  {
		  auto nearbyCluster = nearbyClusters.at(i);

		  if(nearbyCluster == startingCluster) continue;

#if __DEBUG__
		  std::cout << "nearbyClusters " << i << " : " << nearbyCluster 
			  << ", E: " << nearbyCluster->GetHadronicEnergy() 
			  << ", mother: " << nearbyCluster->GetMotherCluster().size() << std::endl;
#endif

		  if(nearbyCluster->GetMotherCluster().size() >=1) continue;

		  try
		  {
			  if(nearbyCluster->IsPhoton()) continue;
		  }
          catch(pandora::StatusCodeException &)
		  {
			  std::cout << "IsPhoton failed" << std::endl;
		  }

		  // GetClustersDistance
		  float closestDistance = 1.e6;

		  try
		  {
			  ClusterHelper::GetClosestDistanceApproach(startingCluster, nearbyCluster, closestDistance);
		  }
          catch(pandora::StatusCodeException &)
		  {
			  std::cout << "GetClosestDistanceApproach failed" << std::endl;
		  }

		  clusterDistanceMap.insert( std::pair<float, APRILCluster*>(closestDistance, nearbyCluster) );
	  }

	  for(auto it = clusterDistanceMap.begin(); it != clusterDistanceMap.end(); ++it)
	  {
		  //auto pCluster = clustersInRange.at(i);
		  auto closestDistance = it->first;
		  auto nearbyCluster = it->second;

		  //startingCluster->GetAxis();

#if 0
		  //GetClustersDirection
		  auto& nearbyClusterAxis = nearbyCluster->GetAxis();
		  auto& startingClusterAxis = startingCluster->GetAxis();
		  auto& nearbyClusterCOG = nearbyCluster->GetCentroid();
		  auto& startingClusterCOG = startingCluster->GetCentroid();
		  auto directionOfCentroids = nearbyClusterCOG - startingClusterCOG;

		  float angle = 1.e6;
		  if( directionOfCentroids.GetMagnitudeSquared() * nearbyClusterAxis.GetMagnitudeSquared() > std::numeric_limits<float>::epsilon() )
		  {
			  try
			  {
				  angle = directionOfCentroids.GetOpeningAngle(nearbyClusterAxis);
			  }
			  catch(pandora::StatusCodeException &)
			  {
				  std::cout << "GetOpeningAngle failed" << std::endl;
			  }
		  }

		  float axisAngle = 1.e6;
		  if( startingClusterAxis.GetMagnitudeSquared() * nearbyClusterAxis.GetMagnitudeSquared() > std::numeric_limits<float>::epsilon() )
		  {
			  try
			  {
				  axisAngle = startingClusterAxis.GetOpeningAngle(nearbyClusterAxis);
			  }
			  catch(pandora::StatusCodeException &)
			  {
				  std::cout << "GetOpeningAngle failed" << std::endl;
			  }
		  }
#endif

		  // get the distance between two directions (skew lines)
		  //auto directionsCrossProd = nearbyClusterAxis.GetCrossProduct(startingClusterAxis);

		  // TODO: add inner layer cut
		  bool isGoodDistance = (closestDistance < m_maxClusterDistanceToMerge);

		  //float axisDistance = fabs(directionsCrossProd.GetDotProduct(directionOfCentroids)) / directionsCrossProd.GetMagnitude();
		  //bool isGoodAxisDistance = (axisDistance < 30.) && (closestDistance < 200.);
		  
		  //bool isGoodAngle = (angle < 0.3) && (closestDistance < 200.);
		  //bool isGoodAxisAngle = (axisAngle < 0.3) && (closestDistance < 200.);

#if __DEBUG__
	          const pandora::Cluster* const pandoraNearbyClu = dynamic_cast<const pandora::Cluster* const>(nearbyCluster);
	          auto nearbyClusterMCParticle = pandora::MCParticleHelper::GetMainMCParticle(pandoraNearbyClu);
			  float nearbyCluEnergy = nearbyCluster->GetHadronicEnergy();

		        std::cout << "-clu: " << nearbyCluster << ", Eh: " << nearbyCluEnergy
		      			<< ", closeDist: " << closestDistance << ", axisDist: " << axisDistance
		      			<< ", angle: " << angle << ", axisAngle: " << axisAngle << ", MCP: " << nearbyClusterMCParticle 
						<< ", gd: " << isGoodDistance << ", gAn: " << isGoodAngle << ", gAx: " << isGoodAxisDistance << std::endl;
#endif

		  if( isGoodDistance ) 
		  //if( isGoodDistance || (isGoodAxisDistance && (isGoodAngle || isGoodAxisAngle)) ) 
		  {
			  properClusters.push_back(nearbyCluster);
		  }
	  }
		
	  startingCluster->SetClustersToMerge(properClusters);

	  // search proper cluster's proper cluster
	  for(int iClu = 0; iClu < properClusters.size(); ++iClu)
	  {
		  auto clu = properClusters.at(iClu);
		  
		  std::vector<APRILCluster*> clusters;
		  SearchProperClusters(clu, clusters);
	  }
		  
	  //std::cout << "-----------------------------------------------------------------------------------------------------------" << std::endl;
  }

  april_content::APRILCluster* PointingClusterAssociationNewAlgorithm::GetMainCluster(const pandora::CaloHitVector& caloHitVector)
  {
      //get the cluster which contains most of calo hits in the vector
      std::map<april_content::APRILCluster*, int> clusterTimes;
      
      for(int iHit = 0; iHit < caloHitVector.size(); ++iHit)
      {
      	const pandora::CaloHit* const pCaloHit = caloHitVector.at(iHit);
      
        const april_content::CaloHit *const pAPRILCaloHit = dynamic_cast<const april_content::CaloHit *const>(pCaloHit);
      	//std::cout << " --- calo hit: " << pAPRILCaloHit << ", cluster: " << pAPRILCaloHit->GetMother() << std::endl;
      
	    auto cluster = APRILContentApi::Modifiable(dynamic_cast<const april_content::APRILCluster*>(pAPRILCaloHit->GetMother()));
      
      	if(cluster != nullptr)
      	{
      	    if(clusterTimes.find(cluster) == clusterTimes.end())
      	    {
      	    	clusterTimes[cluster] = 1;
      	    }
      	    else
      	    {
      	    	clusterTimes[cluster] += 1;
      	    }
      	}
      }
      
	  april_content::APRILCluster* mainCluster = nullptr;
      int mainClusterTimes = 0;
      
      for(auto iter = clusterTimes.begin(); iter != clusterTimes.end(); ++iter)
      {
      	const auto clu = iter->first;
      	int cluTimes = iter->second;
      
      	if(cluTimes > mainClusterTimes)
      	{
      		mainCluster = clu;
      		mainClusterTimes = cluTimes;
      	}
      }
      
      return mainCluster;
  }

  void PointingClusterAssociationNewAlgorithm::GetNearbyClusters(pandora::Cluster* cluster, 
		  const std::vector<april_content::APRILCluster*>& clusterVector, std::vector<april_content::APRILCluster*>& clustersInRange)
  {
      pandora::CartesianVector centroid(0., 0., 0);
	  ClusterHelper::GetCentroid(cluster, centroid);

	  const float distance = m_maxStartingClusterDistance;
	  const mlpack::math::Range range(0., distance);

      arma::mat testPoint(3, 1);
	  testPoint.col(0)[0] = centroid.GetX();
	  testPoint.col(0)[1] = centroid.GetY();
	  testPoint.col(0)[2] = centroid.GetZ();
	  
	  mlpack::range::RangeSearch<> rangeSearch(m_clusterCentroidsMatrix);
      std::vector<std::vector<size_t> > resultingNeighbors;
      std::vector<std::vector<double> > resultingDistances;
      rangeSearch.Search(testPoint, range, resultingNeighbors, resultingDistances);

      std::vector<size_t>& neighbors = resultingNeighbors.at(0);
      std::vector<double>& distances = resultingDistances.at(0);
	  
      for(size_t j=0; j < neighbors.size(); ++j)
      {
      	size_t neighbor = neighbors.at(j);
      	//double hitsDist = distances.at(j);

		clustersInRange.push_back( clusterVector.at(neighbor) );
	  }

	  // sort cluster by distance
	  std::multimap<float, APRILCluster*> clusterDistanceMap;

	  for(int i = 0; i < clustersInRange.size(); ++i)
	  {
		  auto clusterInRange = clustersInRange.at(i);

		  clusterDistanceMap.insert( std::pair<float, APRILCluster*>(distances.at(i), clusterInRange) );
	  }

	  clustersInRange.clear();

	  for(auto& mapIter : clusterDistanceMap)
	  {
		  auto clu = mapIter.second;
		  clustersInRange.push_back(clu);
	  }

	  ///////////////////////////////////////////////////////////////////////////////////////////////
		
#if 0
	  auto pClusterMCP = pandora::MCParticleHelper::GetMainMCParticle(cluster);

	  std::cout << "------------ cluster: " << cluster << ", energy: " << cluster->GetHadronicEnergy() 
		  << ", MCP: " << pClusterMCP << ", nearby clusters: " << clustersInRange.size() << std::endl;

	  for(auto it = clusterDistanceMap.begin(); it != clusterDistanceMap.end(); ++it)
	  {
		  //auto pCluster = clustersInRange.at(i);
		  auto distance = it->first;
		  auto pCluster = it->second;


		  const pandora::Cluster* const clu = dynamic_cast<const pandora::Cluster* const>(pCluster);
		  bool isPhoton = PandoraContentApi::GetPlugins(*this)->GetParticleId()->IsPhoton(clu);
		  auto pClusterMCParticle = pandora::MCParticleHelper::GetMainMCParticle(clu);

		  std::cout << " *clu: " << clu << ", dist: " << distance << ", nhits: " << 
			 pCluster->GetNCaloHits() << ", Ehad: " << pCluster->GetHadronicEnergy() 
			 << ", iL: " << pCluster->GetInnerPseudoLayer() << ": isPhoton: " << pCluster->IsPhoton() 
			 << ": MCP: " << pClusterMCParticle << std::endl;
	  }
#endif
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode PointingClusterAssociationNewAlgorithm::GetEligibleClusters(std::vector<APRILCluster*>& clusterVector) const
  {
	clusterVector.clear();

    const pandora::ClusterList *pClusterList = NULL;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));

	//std::cout << ">>>cluster number: " << pClusterList->size() << std::endl;

    if(pClusterList->empty())
      return pandora::STATUS_CODE_SUCCESS;

    for(pandora::ClusterList::const_iterator clusterIter = pClusterList->begin(), clusterEndIter = pClusterList->end() ;
        clusterEndIter != clusterIter ; ++clusterIter)
    {
      const pandora::Cluster *const pCluster = *clusterIter;

      //if(!this->CanMergeCluster(pCluster))
      //  continue;

	  auto aprilCluster = APRILContentApi::Modifiable(dynamic_cast<const april_content::APRILCluster*>(pCluster));
      clusterVector.push_back(aprilCluster);
    }

    // sort them by inner layer
    std::sort(clusterVector.begin(), clusterVector.end(), SortingHelper::SortClustersByInnerLayer);

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  bool PointingClusterAssociationNewAlgorithm::CanMergeCluster(const pandora::Cluster *const pCluster) const
  {
    if(NULL == pCluster)
      return false;

    if(!PandoraContentApi::IsAvailable(*this, pCluster))
      return false;

    if(pCluster->GetNCaloHits() < m_minNCaloHits || pCluster->GetNCaloHits() > m_maxNCaloHits)
      return false;

    const unsigned int nPseudoLayers(pCluster->GetOrderedCaloHitList().size());

    if(nPseudoLayers < m_minNPseudoLayers || nPseudoLayers >= m_maxNPseudoLayers)
      return false;

    if(m_discriminatePhotonPid && pCluster->PassPhotonId(this->GetPandora()))
      return false;

    return true;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode PointingClusterAssociationNewAlgorithm::FindClustersToMerge(const pandora::ClusterVector &clusterVector, ClusterToClusterMap &clusterToClusterMap) const
  {
    for(pandora::ClusterVector::const_iterator iter = clusterVector.begin(), endIter = clusterVector.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::Cluster *const pDaughterCluster = *iter;

      //if( ! pDaughterCluster->GetAssociatedTrackList().empty() )
      //  continue;

      const pandora::Cluster *pBestParentCluster = NULL;

      if(pandora::STATUS_CODE_SUCCESS != this->FindBestParentCluster(pDaughterCluster, clusterVector, pBestParentCluster))
        continue;

      if(NULL == pBestParentCluster)
        continue;

      clusterToClusterMap[pDaughterCluster] = pBestParentCluster;
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode PointingClusterAssociationNewAlgorithm::FindBestParentCluster(const pandora::Cluster *const pDaughterCluster, const pandora::ClusterVector &clusterVector,
      const pandora::Cluster *&pBestParentCluster) const
  {
    pBestParentCluster = NULL;

    if(NULL == pDaughterCluster)
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    pandora::CartesianVector innerPosition(0.f, 0.f, 0.f), backwardDirection(0.f, 0.f, 0.f);
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->GetClusterBackwardDirection(pDaughterCluster, backwardDirection, innerPosition));
    const unsigned int innerPseudoLayer(PandoraContentApi::GetPlugins(*this)->GetPseudoLayerPlugin()->GetPseudoLayer(innerPosition));

    const pandora::Granularity granularity(this->GetPandora().GetGeometry()->GetHitTypeGranularity(pDaughterCluster->GetInnerLayerHitType()));
    const float maxClusterDistance(granularity <= pandora::FINE ? m_maxBackwardDistanceFine : m_maxBackwardDistanceCoarse);
    const unsigned int maxPseudoLayerDifference(m_maxBackwardPseudoLayer);
    float bestClusterCosineAngle(std::numeric_limits<float>::min());

    for(pandora::ClusterVector::const_reverse_iterator jIter = clusterVector.rbegin(), jEndIter = clusterVector.rend() ;
        jEndIter != jIter ; ++jIter)
    {
      const pandora::Cluster *const pCluster(*jIter);

      if(NULL == pCluster)
        continue;

      if(pCluster == pDaughterCluster)
        continue;

      if(pCluster->GetAssociatedTrackList().empty())
        continue;
	  else
		  std::cout << "---cluster tracks: " << pCluster->GetAssociatedTrackList().size() << std::endl;

      const pandora::Track *pTrack((*pCluster->GetAssociatedTrackList().begin()));
      const pandora::CartesianVector trackMomentum(pTrack->GetTrackStateAtCalorimeter().GetMomentum());
      const pandora::CartesianVector trackProjection(pTrack->GetTrackStateAtCalorimeter().GetPosition());
      const float bField(PandoraContentApi::GetPlugins(*this)->GetBFieldPlugin()->GetBField(pandora::CartesianVector(0.f, 0.f, 0.f)));
      const pandora::Helix helix(trackProjection, trackMomentum, pTrack->GetCharge(), bField);

      // compute parent cluster end point using cluster fit
      pandora::CartesianVector centroid(0.f, 0.f, 0.f);
      PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::GetCentroid(pCluster, centroid));

      const pandora::CartesianVector outerCentroid(pCluster->GetCentroid(pCluster->GetOuterPseudoLayer()));
      const unsigned int outerParentPseudoLayer(pCluster->GetOuterPseudoLayer());
      const unsigned int innerParentPseudoLayer(pCluster->GetInnerPseudoLayer());
      const unsigned int clusterPseudoLayerExtension(outerParentPseudoLayer-innerParentPseudoLayer);
      const unsigned int nFitPseudoLayers(clusterPseudoLayerExtension >= m_nBackwardLayersFit ? m_nBackwardLayersFit : clusterPseudoLayerExtension);

      pandora::ClusterFitResult clusterFitResult;
      PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::ClusterFitHelper::FitEnd(pCluster, nFitPseudoLayers, clusterFitResult));
      const pandora::CartesianVector clusterDirection(clusterFitResult.GetDirection());

      pandora::CartesianVector clusterEndPoint(0.f, 0.f, 0.f);
      PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, GeometryHelper::GetProjectionOnLine(centroid, clusterDirection, outerCentroid, clusterEndPoint));

      pandora::CartesianVector trackEndPointPosition(0.f, 0.f, 0.f), trackEndPointMomentum(0.f, 0.f, 0.f);
      PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, GeometryHelper::GetProjectionOnHelix(helix, clusterEndPoint, trackEndPointPosition));
      trackEndPointMomentum = helix.GetExtrapolatedMomentum(trackEndPointPosition);

      // possible parent if :
      // 1) cluster distance if OK AND angle between fits is ok (cut on cosine)
      // 2) cluster distance if OK AND angle between fits is compatible (cut relaxed) AND dca between fits is OK

      // check pseudo layer cluster separation
      const unsigned int endPseudoLayer(PandoraContentApi::GetPlugins(*this)->GetPseudoLayerPlugin()->GetPseudoLayer(clusterEndPoint));
      const unsigned int pseudoLayerDifference(std::max(innerPseudoLayer, endPseudoLayer) - std::min(innerPseudoLayer, endPseudoLayer));

      if(endPseudoLayer >= innerPseudoLayer || pseudoLayerDifference > maxPseudoLayerDifference)
        continue;

      // distance between clusters
      const pandora::CartesianVector clusterDifferenceDirection(innerPosition-clusterEndPoint);
      const float clusterDistance(clusterDifferenceDirection.GetMagnitude());

      if(clusterDistance > maxClusterDistance)
        continue;

      // compute cluster-to-cluster properties
      const float clusterFitCosineAngle(clusterDirection.GetCosOpeningAngle(backwardDirection * -1.));
      const float clusterCosineAngle(trackEndPointMomentum.GetCosOpeningAngle(clusterDifferenceDirection));

      float clusterFitDca(0.f);
      PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, GeometryHelper::GetClosestDistanceBetweenLines(clusterEndPoint, clusterDirection, innerPosition, backwardDirection, clusterFitDca));

      bool possibleAssociation(false);

      // contained in small angle
      if(clusterFitCosineAngle > m_minClusterFitCosOpeningAngle2 && clusterCosineAngle > m_minClusterCosOpeningAngle)
      {
        possibleAssociation = true;
      }
      // contained in larger angle but short dca
      else if(clusterFitDca < m_maxClusterFitDca && clusterFitCosineAngle > m_minClusterFitCosOpeningAngle && clusterCosineAngle > m_minClusterCosOpeningAngle)
      {
        possibleAssociation = true;
      }

      if(possibleAssociation)
      {
        float oldChi(0.f), newChi(0.f);
		float trackEnergy(0.f);

        if(pandora::STATUS_CODE_SUCCESS != ClusterHelper::GetChiClusterMerging(this->GetPandora(), pCluster, pDaughterCluster, trackEnergy, oldChi, newChi))
          continue;

        const bool angleTightened(clusterCosineAngle > bestClusterCosineAngle);
        const bool chi2Compatible(newChi*newChi < oldChi*oldChi || newChi*newChi < m_chi2AssociationCut);

        if(angleTightened && chi2Compatible)
        {
          bestClusterCosineAngle = clusterCosineAngle;
          pBestParentCluster = pCluster;
        }
      }
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode PointingClusterAssociationNewAlgorithm::GetClusterBackwardDirection(const pandora::Cluster *const pCluster, pandora::CartesianVector &backwardDirection, pandora::CartesianVector &innerPosition) const
  {
    pandora::CartesianVector centroid(0.f, 0.f, 0.f);
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::GetCentroid(pCluster, centroid));

    const pandora::CartesianVector innerCentroid(pCluster->GetCentroid(pCluster->GetInnerPseudoLayer()));

    pandora::ClusterFitResult clusterFitResult;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::ClusterFitHelper::FitStart(pCluster, m_nBackwardLayersFit, clusterFitResult));
    const pandora::CartesianVector clusterDirection(clusterFitResult.GetDirection());

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, GeometryHelper::GetProjectionOnLine(centroid, clusterDirection, innerCentroid, innerPosition));
    backwardDirection = clusterDirection * -1.f;

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode PointingClusterAssociationNewAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {

    m_discriminatePhotonPid = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "DiscriminatePhotonPid", m_discriminatePhotonPid));

    m_allowNeutralParentMerging = true;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "AllowNeutralParentMerging", m_allowNeutralParentMerging));

    m_minNCaloHits = 0;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinNCaloHits", m_minNCaloHits));

    m_maxNCaloHits = std::numeric_limits<unsigned int>::max();
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxNCaloHits", m_maxNCaloHits));

    m_minNPseudoLayers = 2;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinNPseudoLayers", m_minNPseudoLayers));

    m_maxNPseudoLayers = std::numeric_limits<unsigned int>::max();
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxNPseudoLayers", m_maxNPseudoLayers));

    m_chi2AssociationCut = 1.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "Chi2AssociationCut", m_chi2AssociationCut));

    m_nBackwardLayersFit = 6;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "NBackwardLayersFit", m_nBackwardLayersFit));

    m_maxBackwardAngle = 0.4;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxBackwardAngle", m_maxBackwardAngle));

    m_maxBackwardDistanceFine = 300.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxBackwardDistanceFine", m_maxBackwardDistanceFine));

    m_maxBackwardDistanceCoarse = 1000.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxBackwardDistanceCoarse", m_maxBackwardDistanceCoarse));

    m_maxBackwardPseudoLayer = 20;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxBackwardPseudoLayer", m_maxBackwardPseudoLayer));

    m_minParentClusterBackwardNHits = 5;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinParentClusterBackwardNHits", m_minParentClusterBackwardNHits));

    m_maxClusterFitDca = 25.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxClusterFitDca", m_maxClusterFitDca));

    m_minClusterCosOpeningAngle = 0.7;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinClusterCosOpeningAngle", m_minClusterCosOpeningAngle));

    m_minClusterFitCosOpeningAngle = 0.7;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinClusterFitCosOpeningAngle", m_minClusterFitCosOpeningAngle));

    m_minClusterFitCosOpeningAngle2 = 0.8;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinClusterFitCosOpeningAngle2", m_minClusterFitCosOpeningAngle2));

    m_maxStartingClusterDistance = 200.;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxStartingClusterDistance", m_maxStartingClusterDistance));

	m_maxClusterDistanceToMerge = 15.;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinClusterDistanceToMerge", m_maxClusterDistanceToMerge));

    return pandora::STATUS_CODE_SUCCESS;
  }


} 

