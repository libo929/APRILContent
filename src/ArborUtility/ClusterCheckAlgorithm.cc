/// \file ClusterCheckAlgorithm.cc
/*
 *
 * ClusterCheckAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. juin 2 2016
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "ArborUtility/ClusterCheckAlgorithm.h"

#include "Pandora/AlgorithmHeaders.h"
#include "ArborApi/ArborContentApi.h"
#include "ArborObjects/CaloHit.h"
#include "ArborHelpers/GeometryHelper.h"


namespace arbor_content
{

  pandora::StatusCode ClusterCheckAlgorithm::Run()
  {


    const pandora::CaloHitList *pCaloHitList = NULL;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pCaloHitList));

	std::cout << "  ---> CaloHit list size: " << pCaloHitList->size() << std::endl;

#if 0
    for(pandora::CaloHitList::const_iterator iter = pCaloHitList->begin(), endIter = pCaloHitList->end() ;
        endIter != iter ; ++iter)
    {
        const arbor_content::CaloHit *const pCaloHit(dynamic_cast<const arbor_content::CaloHit *>(*iter));
		const pandora::CartesianVector position(pCaloHit->GetPositionVector());
		std::cout << "hit position: " << " " << position.GetX() << " " << position.GetY() << " " << position.GetZ() 
			      << " time: " << pCaloHit->GetTime() << std::endl;
	}
#endif

    return pandora::STATUS_CODE_SUCCESS;
  }


  pandora::StatusCode ClusterCheckAlgorithm::Initialize()
  {
      std::cout << "timing:  "   << m_timing  << std::endl;
      std::cout << "time cut:  " << m_timeCut << std::endl;
      
	  //std::cout << "********* ClusterCheckAlgorithm init ********" << std::endl;
    
	  return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterCheckAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
	m_timing = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "ApplyTiming", m_timing));

    m_timeCut = 100.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "TimeCut", m_timeCut));

    return pandora::STATUS_CODE_SUCCESS;
  }

} 
