/// \file ClusterPurityAlgorithm.cc
/*
 *
 * ClusterPurityAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. juin 2 2016
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "ArborUtility/ClusterPurityAlgorithm.h"

#include "Pandora/AlgorithmHeaders.h"
#include "ArborApi/ArborContentApi.h"
#include "ArborObjects/CaloHit.h"
#include "ArborHelpers/GeometryHelper.h"
#include "ArborHelpers/ReclusterHelper.h"
#include "ArborHelpers/HistogramHelper.h"

namespace arbor_content
{

  extern HistogramManager AHM;

  pandora::StatusCode ClusterPurityAlgorithm::Run()
  {
#if 1
    const pandora::CaloHitList *pCaloHitList = NULL;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pCaloHitList));

    const pandora::ClusterList *pClusterList = NULL;
    //PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));
	
	//std::string m_clusterListName("PhotonClusters");
	std::string m_clusterListName("PerfectPhotonClusters");
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetList(*this, m_clusterListName, pClusterList));
	
	std::cout << "  ---> CaloHitlist size: " << pCaloHitList->size() << std::endl;

	int hitNoMCP = 0;

	for(pandora::CaloHitList::const_iterator iter = pCaloHitList->begin(), endIter = pCaloHitList->end(); endIter != iter; ++iter)
	{
		const pandora::CaloHit* pCaloHit = *iter;
		const pandora::MCParticle* hitMCParticle = NULL;

		try
		{
			hitMCParticle = pandora::MCParticleHelper::GetMainMCParticle(pCaloHit);
			//std::cout << "hit MCP: " << hitMCParticle << ",  PDG: " << hitMCParticle->GetParticleId() << std::endl;
		}
		catch (pandora::StatusCodeException &)
		{
			//std::cout << "  no mcp of hit: " << pCaloHit << ", EM energy: " << pCaloHit->GetElectromagneticEnergy() << std::endl;
			hitMCParticle = NULL;
		}

		if(hitMCParticle==NULL) ++hitNoMCP;
	}

	std::cout << "  ---> hit no MCP: " << hitNoMCP << std::endl;
	std::cout << "  ---> Clusterlist size: " << pClusterList->size() << std::endl;

    for(pandora::ClusterList::const_iterator iter = pClusterList->begin(), endIter = pClusterList->end() ;
        endIter != iter ; ++iter)
    {
		const pandora::Cluster* cluster = *iter;

		float clusterEmEnergy = cluster->GetElectromagneticEnergy();
		const pandora::OrderedCaloHitList& hitList = cluster->GetOrderedCaloHitList();
		//const pandora::CaloHitList& isoHitList = cluster->GetIsolatedCaloHitList();

		pandora::CaloHitList caloHitList;
		hitList.FillCaloHitList(caloHitList);

#if 0
		if(PandoraContentApi::GetPlugins(*this)->GetParticleId()->IsPhoton(cluster))
		{
			std::cout << "This is a photon cluster: " << std::endl;
		}
#endif
    	
		const pandora::MCParticle* clusterMCParticle = NULL;


		try
		{
			clusterMCParticle = pandora::MCParticleHelper::GetMainMCParticle(cluster);
		}
        catch (pandora::StatusCodeException &)
		{
			std::cout << "  no mcp of cluster" << std::endl;
		}

		int clusterMCPDG = 0;

		if(clusterMCParticle != NULL)
		{
			clusterMCPDG = clusterMCParticle->GetParticleId();
		}

		float fullPureHitEnergy = 0.;
		float pureHitEnergy = 0.;
		float noMCPHitEnergy = 0.;

		for(auto it=caloHitList.begin(); it!=caloHitList.end(); ++it)
		{
			auto pCaloHit = *it;
			float hitEnergy = pCaloHit->GetElectromagneticEnergy();

			const pandora::MCParticle* hitMCParticle = NULL;

			try
			{
				hitMCParticle = pandora::MCParticleHelper::GetMainMCParticle(pCaloHit);
			}
			catch (pandora::StatusCodeException &)
			{
				//std::cout << "  no mcp of hit: " << pCaloHit << std::endl;
			}

			if(hitMCParticle == NULL)
			{
				noMCPHitEnergy += hitEnergy;
				continue;
			}

			if(hitMCParticle==clusterMCParticle && hitMCParticle->GetParticleId()==22)
			{
				fullPureHitEnergy += hitEnergy;
			}

			if(hitMCParticle->GetParticleId()==22)
			{
				pureHitEnergy += hitEnergy;
			}
		}

		float clusterFullPurity = fullPureHitEnergy/(clusterEmEnergy - noMCPHitEnergy);
		float clusterPurity = pureHitEnergy/(clusterEmEnergy - noMCPHitEnergy);

		std::string tupleName = "ClusterPurityAlgorithm" + std::string(__func__);
		std::string varListName = "clusterFullPurity:clusterPurity:clusterEnergy:clusterMCPDG";

		std::vector<float> vars;
		vars.push_back( clusterFullPurity );
		vars.push_back( clusterPurity );
		vars.push_back( clusterEmEnergy );
		vars.push_back( clusterMCPDG );
	    AHM.CreateFill(tupleName, varListName, vars);

		//std::cout << "cluster energy: " << clusterEmEnergy << ", purity: " << clusterPurity << std::endl;
	}

#endif


#if 0
	/////////////////////////
    const pandora::PfoList *pPfoList = NULL; 
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pPfoList));

    const pandora::ClusterList *pClusterList = NULL; 
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));

	std::cout << "------- # Cluster : " << pClusterList->size() << std::endl;
	std::cout << "------- # PFO : " << pPfoList->size() << std::endl;

    for(pandora::PfoList::const_iterator iter = pPfoList->begin(), endIter = pPfoList->end(); endIter != iter ; ++iter)
    {
		const pandora::ParticleFlowObject* pfo = *iter;
		int pfoPID = pfo->GetParticleId();
		int pfoCharge = pfo->GetCharge();

		//std::cout << "PFO : " << pfo << ", PID: " << pfoPID << ", charge: " << pfoCharge << std::endl;

		const pandora::TrackList& pfoTrackList = pfo->GetTrackList();
		const pandora::ClusterList& pfoClusterList = pfo->GetClusterList();

		float clustersEnergy = 0.;
		float tracksEnergy = 0.;

		for(pandora::TrackList::const_iterator trackIter = pfoTrackList.begin(); trackIter != pfoTrackList.end(); ++trackIter)
		{
			const pandora::Track* track = *trackIter;
			float trackEnergy = track->GetEnergyAtDca();

			tracksEnergy += trackEnergy;
		}

     	checkClusters(pfoClusterList);
	}


	if(pClusterList!=NULL)
	{
        std::cout << "Checking clusters" << std::endl;
		checkClusters(*pClusterList);
	}

	{
	    ///// check hit
	    double totHitEnergy = 0.;
	    double totAvailableHitEnergy = 0.;

        const pandora::CaloHitList *pCaloHitList = NULL;
        PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pCaloHitList));

        const pandora::CaloHitList localCaloHitList(pCaloHitList->begin(), pCaloHitList->end());

        for (pandora::CaloHitList::const_iterator iter = localCaloHitList.begin(), iterEnd = localCaloHitList.end(); iter != iterEnd; ++iter)
        {
            try
            {
                const pandora::CaloHit *const pCaloHit = *iter;
	    		double hitEnergy = pCaloHit->GetHadronicEnergy();

                if (PandoraContentApi::IsAvailable(*this, pCaloHit))
	    		{
	    			totAvailableHitEnergy += hitEnergy;
	    			//std::cout << "a available hit energy: " << hitEnergy << ", total: " << totAvailableHitEnergy << std::endl;

					//
    			    try
    			    {
    			       const pandora::MCParticle *const pMCParticle(pandora::MCParticleHelper::GetMainMCParticle(pCaloHit));
	    		    }
                    catch (pandora::StatusCodeException &)
                    {
						//std::cout << "no MCP" << std::endl;
                    }
				}

	    		totHitEnergy += pCaloHit->GetHadronicEnergy();
	    	}
            catch (pandora::StatusCodeException &)
            {
            }
	    }

	    std::cout << "total hit energy available: " << totAvailableHitEnergy << ", total hit energy: " << totHitEnergy << std::endl;
	}
#endif

#if 0
	{
        const MCParticleList *pMCParticleList = NULL;
        PANDORA_RETURN_RESULT_IF(STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pMCParticleList));

        for (MCParticleList::const_iterator iterMC = pMCParticleList->begin(), iterMCEnd = pMCParticleList->end(); iterMC != iterMCEnd; ++iterMC)
        {
            try
            {
                const MCParticle *const pPfoTarget = *iterMC;
                PfoParameters pfoParameters;
			}
            catch (StatusCodeException &)
            {
            }
		}
	}
#endif
	
    return pandora::STATUS_CODE_SUCCESS;
  }


  void ClusterPurityAlgorithm::checkClusters(const pandora::ClusterList& pfoClusterList)
  {

	 std::cout << "cluster size: " << pfoClusterList.size() << std::endl;

#if 0
     for(pandora::ClusterList::const_iterator clusterIter = pfoClusterList.begin(); clusterIter != pfoClusterList.end(); ++clusterIter)
     {
    		const pandora::Cluster* cluster = *clusterIter;
    
    		try
    		{
    			const pandora::MCParticle *const pMCClusterParticle(pandora::MCParticleHelper::GetMainMCParticle(cluster));
    		    //std::cout << "Cluster : " << cluster << ", MCPID: " << pMCClusterParticle->GetParticleId() << std::endl;
    		}
    		catch (pandora::StatusCodeException &)
    		{
    		}
    
    
    		const pandora::OrderedCaloHitList& orderedHits = cluster->GetOrderedCaloHitList();
    		const pandora::CaloHitList& isoHits = cluster->GetIsolatedCaloHitList();

			const pandora::MCParticle* firstMCP = NULL;
    
            pandora::CaloHitList hitList;
    		orderedHits.FillCaloHitList(hitList);
    
    		for(pandora::CaloHitList::const_iterator isoHitIter = isoHits.begin(); isoHitIter != isoHits.end(); ++isoHitIter)
    		{
    			const pandora::CaloHit* isoHit = *isoHitIter;
    
    			try
    			{
    			   const pandora::MCParticle *const pMCParticle(pandora::MCParticleHelper::GetMainMCParticle(isoHit));
    			   int mcpCharge = pandora::PdgTable::GetParticleCharge(pMCParticle->GetParticleId());
    
    			   //    std::cout << "isohit MCP: " << pMCParticle << ", PID: " << pMCParticle->GetParticleId()  << 
    			   //		", charge: " << mcpCharge << std::endl;

				   if(firstMCP==NULL)
				   {
				   	 firstMCP = pMCParticle;
				   }

				   if(firstMCP!=NULL && firstMCP != pMCParticle)
				   {
					   //std::cout << "firstMCP: " << firstMCP << ", thisMCP: " << pMCParticle << std::endl;
				   }
    			}
    			catch (pandora::StatusCodeException &)
    			{
    			}
    		}
    
    		for(pandora::CaloHitList::const_iterator hitIter = hitList.begin(); hitIter != hitList.end(); ++hitIter)
    		{
    			const pandora::CaloHit* hit = *hitIter;
    
    			try
    			{
    				const pandora::MCParticle *const pMCParticle(pandora::MCParticleHelper::GetMainMCParticle(hit));
    				int mcpCharge = pandora::PdgTable::GetParticleCharge(pMCParticle->GetParticleId());
    
    			    //std::cout << "hit MCP: " << pMCParticle << ", PID: " << pMCParticle->GetParticleId()  << 
    				//	", charge: " << mcpCharge << std::endl;

				   if(firstMCP==NULL)
				   {
				   	 firstMCP = pMCParticle;
				   }

				   if(firstMCP!=NULL && firstMCP != pMCParticle)
				   {
					   std::cout << "firstMCP: " << firstMCP << ", thisMCP: " << pMCParticle << std::endl;
				   }
    			}
    			catch (pandora::StatusCodeException &)
    			{
    			}
    		}
    	}
#endif
  }

  pandora::StatusCode ClusterPurityAlgorithm::Initialize()
  {
      //std::cout << "timing:  "   << m_timing  << std::endl;
      //std::cout << "time cut:  " << m_timeCut << std::endl;
      
	  //std::cout << "********* ClusterPurityAlgorithm init ********" << std::endl;
    
	  return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ClusterPurityAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
	m_timing = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "ApplyTiming", m_timing));

    m_timeCut = 100.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "TimeCut", m_timeCut));

    return pandora::STATUS_CODE_SUCCESS;
  }

} 
