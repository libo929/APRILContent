/// \file TrackClusterAssociationMVAAlgorithm.cc
/*
 *
 * TrackClusterAssociationMVAAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. avr. 9 2015
 *
 * This file is part of APRILContent libraries.
 * 
 * APRILContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * APRILContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with APRILContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

#include "Pandora/AlgorithmHeaders.h"

#include "APRILTrackClusterAssociation/TrackClusterAssociationMVAAlgorithm.h"
#include "APRILHelpers/ReclusterHelper.h"

#include "APRILHelpers/HistogramHelper.h"

bool shouldMatch(const pandora::Track* const pTrack, const pandora::Cluster* const pCluster)
{
	bool shouldMatch = false;

	const pandora::MCParticle* pTrkMCParticle = NULL;
	const pandora::MCParticle* pClusterMCParticle = NULL;

	try
	{
		pTrkMCParticle = pandora::MCParticleHelper::GetMainMCParticle(pTrack);
	}
    catch (pandora::StatusCodeException &e)
	{
		//std::cout << "Track GetMainMCParticle Exception: " << e.ToString() << std::endl;
		return false;
	}

	try
	{
		pClusterMCParticle = pandora::MCParticleHelper::GetMainMCParticle(pCluster);
	}
    catch (pandora::StatusCodeException &e)
	{
		//std::cout << "Cluster GetMainMCParticle Exception: " << e.ToString() << std::endl;
		return false;
	}
	
	shouldMatch = pTrkMCParticle == pClusterMCParticle ? true : false;

	return shouldMatch;
}

bool SortTracksByEnergy(const pandora::Track *const pLhs, const pandora::Track *const pRhs)
{
   	return (pLhs->GetEnergyAtDca() > pRhs->GetEnergyAtDca());
}

namespace april_content
{

  float MaxTrackClusterAngle = 0.6;
  
  float m_trkR, m_trkZ, m_trkPhi, m_trkTanL, m_trkEnergy;
  float m_cluR, m_cluZ, m_cluPhi, m_cluSize, m_cluEnergy;
  float RDiff, ZDiff, PhiDiff, EnergyDiff;
  float m_trkCluDistance;

  TMVA::Reader* TrackClusterAssociationMVAAlgorithm::m_reader = NULL;

  pandora::StatusCode TrackClusterAssociationMVAAlgorithm::Run()
  {
	if(m_reader==NULL) 
	{
        m_reader = new TMVA::Reader( "!Color:!Silent" ); 
	    
#if 0
	    m_reader->AddVariable( "trkR",                &m_trkR           );
	    m_reader->AddVariable( "trkZ",                &m_trkZ           );
	    m_reader->AddVariable( "trkPhi",              &m_trkPhi         );
        m_reader->AddVariable( "trkTanL",             &m_trkTanL        );
        m_reader->AddVariable( "trkEnergy",           &m_trkEnergy      );
        m_reader->AddVariable( "cluR",                &m_cluR           );
        m_reader->AddVariable( "cluZ",                &m_cluZ           );
        m_reader->AddVariable( "cluPhi",              &m_cluPhi         );
        m_reader->AddVariable( "cluSize",             &m_cluSize        );
        m_reader->AddVariable( "cluEnergy",           &m_cluEnergy      );
        m_reader->AddVariable( "trkCluDistance",      &m_trkCluDistance );
#endif

	    m_reader->AddVariable( "trkR-cluR",                &RDiff           );
	    m_reader->AddVariable( "trkZ-cluZ",                &ZDiff           );
	    m_reader->AddVariable( "trkPhi-cluPhi",            &PhiDiff         );
        m_reader->AddVariable( "trkEnergy-cluEnergy",      &EnergyDiff      );
        m_reader->AddVariable( "trkCluDistance",           &m_trkCluDistance  );

        // --- Book the MVA methods
        TString methodName = TString("BDT method");
        TString weightfile = TString("/home/libo/workplace/tmva/pfa/dataset/weights/TMVAClassification_BDT.weights.xml");
        //TString methodName = TString("BDT method");
        //TString weightfile = TString("/home/libo/workplace/tmva/pfa/dataset/weights/TMVAClassification_BDT.weights.xml");

        try 
        {
	    	m_reader->BookMVA( methodName, weightfile ); 
        }
        catch (...)
        {
	    	std::cout << "Error: MVA reader !!!" << std::endl;
        }
	}

    // extract tracks and clusters eligible for track-cluster associations
    pandora::TrackList trackList; pandora::ClusterList clusterList;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->ExtractAssociationLists(clusterList, trackList));

    if(trackList.empty() || clusterList.empty())
      return pandora::STATUS_CODE_SUCCESS;

	//std::cout << "----> clusterList size: " << clusterList.size() << std::endl;
	//std::cout << "trackList size: " << trackList.size() << std::endl;
    // reset the track-cluster associations
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::RemoveCurrentTrackClusterAssociations(*this));

    AssociationMap associationMap;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->BuildPossibleAssociations(clusterList, trackList, associationMap));
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->PerformAssociations(associationMap));

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode TrackClusterAssociationMVAAlgorithm::ExtractAssociationLists(pandora::ClusterList &clusterList, pandora::TrackList &trackList)
  {
    const pandora::TrackList *pTrackList = NULL;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pTrackList));

    const pandora::ClusterList *pClusterList = NULL;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));
	//std::cout << "-------> the cluster size of list: " << pClusterList->size() << std::endl;

    if(pTrackList->empty() || pClusterList->empty())
      return pandora::STATUS_CODE_SUCCESS;

    // filter clusters
    for(pandora::ClusterList::const_iterator iter = pClusterList->begin() , endIter = pClusterList->end() ;
        endIter != iter ; ++iter)
    {
      const pandora::Cluster *const pCluster = *iter;

      if( ! PandoraContentApi::IsAvailable(*this, pCluster) )
        continue;

      const unsigned int innerPseudoLayer(pCluster->GetInnerPseudoLayer());

      const bool isPhoton(pandora::PHOTON == pCluster->GetParticleId());
      const bool isNeutron(pandora::NEUTRON == pCluster->GetParticleId());
	
	  std::vector<float> vars;

	  vars.push_back( float(isPhoton) );
	  vars.push_back( float(isNeutron) );
	  vars.push_back( float(innerPseudoLayer) );
	  vars.push_back( float(m_maxClusterInnerPseudoLayer) );
	  vars.push_back( float(pCluster->GetNCaloHits()) );

	  HistogramManager::CreateFill("ClusterProperty", "isPhoton:isNeutron:innerPseudoLayer:maxClusterInnerPseudoLayer:nCaloHits", vars);

	  if(isPhoton || isNeutron) 
	  {
		  //std::cout << "isPhoton: " << isPhoton << ", isNeutron: " << isNeutron << std::endl;
		  continue;
	  }

#if 0
      if( innerPseudoLayer > m_maxClusterInnerPseudoLayer )
        continue;
#endif

      clusterList.push_back(pCluster);
    }

    // filter tracks
    for(pandora::TrackList::const_iterator trackIter = pTrackList->begin() , trackEndIter = pTrackList->end() ;
        trackEndIter != trackIter ; ++trackIter)
    {
      const pandora::Track *const pTrack = *trackIter;

      if(!PandoraContentApi::IsAvailable(*this, pTrack))
        continue;

      if(!pTrack->ReachesCalorimeter())
        continue;

#if 0
      if(!pTrack->CanFormPfo())
        continue;
#endif

      trackList.push_back(pTrack);
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  float TrackClusterAssociationMVAAlgorithm::MVADeteriminAssociation(const pandora::Cluster *const pCluster, const pandora::Track *const pTrack) const
  {
    const pandora::CartesianVector trackMomentum(pTrack->GetTrackStateAtCalorimeter().GetMomentum());
    const pandora::CartesianVector trackProjection(pTrack->GetTrackStateAtCalorimeter().GetPosition());

    pandora::CartesianVector innerCentroid(0.f, 0.f, 0.f);

	MaxTrackClusterAngle = 0.6;
    bool canComputeInnerCentroid0 = pandora::STATUS_CODE_SUCCESS == this->ComputeInnerCentroid(pCluster, pTrack, innerCentroid);
	//bool canComputeInnerCentroid1;

	if(canComputeInnerCentroid0==false)
	{
		MaxTrackClusterAngle = 1.e6;
        //canComputeInnerCentroid1 = pandora::STATUS_CODE_SUCCESS == this->ComputeInnerCentroid(pCluster, pTrack, innerCentroid);
	}

    // get b field and track helix
    const float bField(PandoraContentApi::GetPlugins(*this)->GetBFieldPlugin()->GetBField(pandora::CartesianVector(0.f, 0.f, 0.f)));
    const pandora::Helix helix(trackProjection, trackMomentum, pTrack->GetCharge(), bField);

	float trkTanL = trackMomentum.GetZ() / sqrt(trackMomentum.GetX() * trackMomentum.GetX() + trackMomentum.GetY() * trackMomentum.GetY());

    pandora::CartesianVector distanceToHelix(0.f, 0.f, 0.f);
    helix.GetDistanceToPoint(innerCentroid, distanceToHelix);

	std::string tupleName = "MVADeteriminAssociation";
	std::string varListName = "trkR:trkZ:trkPhi:trkTanL:trkEnergy:cluR:cluZ:cluPhi:cluSize:cluEnergy:trkCluDistance:MCMatch:MVAMatch";
	std::vector<float> vars;

	float trkR, trkPhi, trkZ;
	trackProjection.GetCylindricalCoordinates(trkR, trkPhi, trkZ);

	float cluR, cluPhi, cluZ;
	innerCentroid.GetCylindricalCoordinates(cluR, cluPhi, cluZ);
	
	bool isMatched = shouldMatch(pTrack, pCluster);

	/////////////////////////////////////////////////////////////////
	m_trkR = trkR;
	m_trkZ = trkZ;
	m_trkPhi = trkPhi;
	m_trkTanL = trkTanL;
	m_trkEnergy = pTrack->GetEnergyAtDca();

	m_cluR = cluR;
	m_cluZ = cluZ;
	m_cluPhi = cluPhi;
	m_cluSize = pCluster->GetNCaloHits();
    m_cluEnergy = pCluster->GetHadronicEnergy();
	m_trkCluDistance = distanceToHelix.GetZ();

	RDiff = m_trkR - m_cluR;
	ZDiff = m_trkZ - m_cluZ;
	PhiDiff = m_trkPhi - m_cluPhi;
	EnergyDiff = m_trkEnergy - m_cluEnergy;

	// -------------------- MVA ------------------
	float matchProb = m_reader->EvaluateMVA( "BDT method" );
	//std::cout << " matchProb: " << matchProb << std::endl;
	// -------------------- MVA ------------------
	
	vars.push_back( m_trkR );
	vars.push_back( m_trkZ );
	vars.push_back( m_trkPhi );
	vars.push_back( m_trkTanL );
	vars.push_back( m_trkEnergy );

	vars.push_back( m_cluR );
	vars.push_back( m_cluZ );
	vars.push_back( m_cluPhi );
	vars.push_back( m_cluSize );
	vars.push_back( m_cluEnergy );
	vars.push_back( m_trkCluDistance );
	vars.push_back( float(isMatched) );
	vars.push_back( matchProb );
	
	HistogramManager::CreateFill(tupleName, varListName, vars);
	/////////////////////////////////////////////////////////////////

    //return true;
	return -matchProb;

	//return matchingProbability;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  
  pandora::StatusCode TrackClusterAssociationMVAAlgorithm::BuildPossibleAssociations(const pandora::ClusterList &clusterList, const pandora::TrackList &trackList,
      AssociationMap &associationMap)
  {
    //AssociationConstraintsMap contraintsMap;
    MultiAssociationMap multiAssociationMap;

    for(pandora::TrackList::const_iterator trackIter = trackList.begin() , trackEndIter = trackList.end() ;
        trackEndIter != trackIter ; ++trackIter)
    {
      const pandora::Track *const pTrack = *trackIter;
	  //std::cout << "-------> track energy: " << pTrack->GetEnergyAtDca() << std::endl;

      const pandora::Cluster *pBestCluster = NULL;
      float bestCompatibility(std::numeric_limits<float>::max());

      for(pandora::ClusterList::const_iterator iter = clusterList.begin() , endIter = clusterList.end() ;
          endIter != iter ; ++iter)
      {
        const pandora::Cluster *const pCluster = *iter;

#if 0
        bool passedInitCut = this->PassesInitialCuts(pCluster, pTrack);

		if(!passedInitCut) continue;

        AssociationConstraints constraints;
        PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->CalculateAssociationConstraints(pCluster, pTrack, constraints));

        if( ! this->FitConstraints(constraints) ) continue;

        if(constraints.m_compatibility < bestCompatibility)
        {
          bestCompatibility = constraints.m_compatibility;
          pBestCluster = pCluster;
        }
#endif

#if 1
	    //bool isMatched = shouldMatch(pTrack, pCluster);
		
		//if(!isMatched) continue;

		// small value has better compatibility
		float compatibility = MVADeteriminAssociation(pCluster, pTrack);

		// mc matching
		//if(shouldMatch(pTrack, pCluster)) compatibility = -1.e6;

        if(compatibility < bestCompatibility)
        {
#if 0
		  if(!isMatched) 
		  {
			  if(compatibility>-0.3) continue;
		  }
#endif

          bestCompatibility = compatibility;
		  pBestCluster = pCluster;
        }
#endif
      }

      if(NULL != pBestCluster)
      {
		// not allowed ?
        if(m_allowMultiAssociations)
        {
          associationMap[pTrack] = pBestCluster;
          continue;
        }

        MultiAssociationMap::iterator iter = multiAssociationMap.find(pBestCluster);

        if(multiAssociationMap.end() != iter)
        {
          AssociationMap::iterator iter2 = associationMap.find(iter->second);

          if(iter2 == associationMap.end())
          {
            associationMap[pTrack] = pBestCluster;
            multiAssociationMap[pBestCluster] = pTrack;
            continue;
          }

          pandora::TrackList chiTrackList, newChiTrackList;
          chiTrackList.push_back(iter->second);
          newChiTrackList.push_back(pTrack);

          const float chi = ReclusterHelper::GetTrackClusterCompatibility(this->GetPandora(), pBestCluster, chiTrackList);
          const float newChi = ReclusterHelper::GetTrackClusterCompatibility(this->GetPandora(), pBestCluster, newChiTrackList);

          if(chi*chi > newChi*newChi)
          {
            multiAssociationMap[pBestCluster] = pTrack;
            associationMap.erase(iter2);
            associationMap[pTrack] = pBestCluster;
          }
        }
        else
        {
          associationMap[pTrack] = pBestCluster;
          multiAssociationMap[pBestCluster] = pTrack;
        }
      }

#if 0
	  else
	  {
		//std::cout << "-------> track energy: " << pTrack->GetEnergyAtDca() << ", no cluster" << std::endl;

		// if the track energy is greater than a prescribed value but has no associated cluster, then
		// try to check nearby photon candidates ???
		if(!m_usePhotonClusters) continue;
    
		const pandora::ClusterList *pPhotonList = NULL;
		std::string photonListName("PhotonClusters");
    
        if(pandora::STATUS_CODE_SUCCESS != PandoraContentApi::GetList(*this, photonListName, pPhotonList))
        {
			std::cout << "TrackClusterAssociationMVAAlgorithm: cluster list PhotonClusters is not available" << std::endl;
		}

		//if(pPhotonList!=NULL) std::cout << "=============> photon cluster number: " << pPhotonList->size() << std::endl;
	  }
#endif
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode TrackClusterAssociationMVAAlgorithm::PerformAssociations(const AssociationMap &associationMap)
  {
    std::cout << "TrackClusterAssociationMVAAlgorithm::PerformAssociations map: " << associationMap.size() << std::endl;
#if 0	  

	pandora::TrackVector trackVector;

    for(AssociationMap::const_iterator iter = associationMap.begin() , endIter = associationMap.end() ;
        endIter != iter ; ++iter)
    { 
		const pandora::Track *const pTrack(iter->first);
		trackVector.push_back(pTrack);
	}

	std::sort(trackVector.begin(), trackVector.end(), SortTracksByEnergy);

	std::cout << "# of pfo track: " << trackVector.size() << std::endl;

    for (pandora::TrackVector::const_iterator trackIter = trackVector.begin(), trackIterEnd = trackVector.end(); trackIter != trackIterEnd; ++trackIter)
    {
        //const pandora::Track *const pTrack = *trackIter;

        //std::cout << "Pandora: track energy: " << pTrack->GetEnergyAtDca() << std::endl; 
	}
#endif
    for(AssociationMap::const_iterator iter = associationMap.begin() , endIter = associationMap.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::Track *const pTrack(iter->first);
      const pandora::Cluster *const pCluster(iter->second);
	  //std::cout << "--track energy: " << pTrack->GetEnergyAtDca() << " cluster: " << pCluster->GetElectromagneticEnergy() << std::endl;

      if((NULL == pTrack) || (NULL == pCluster)) {
		  //if(pTrack!=NULL) std::cout << "track has no cluster, track energy:  " << pTrack->GetEnergyAtDca() << std::endl;
		  //if(pCluster!=NULL) std::cout << "cluster has no track, cluster energy:  " << std::endl;
        continue;
	  }

      PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::AddTrackClusterAssociation(*this, pTrack, pCluster));
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode TrackClusterAssociationMVAAlgorithm::ComputeInnerCentroid(const pandora::Cluster *const pCluster, const pandora::Track *const pTrack, pandora::CartesianVector &innerCentroid) const
  {
    const unsigned int innerPseudoLayer(pCluster->GetInnerPseudoLayer());
    const pandora::CartesianVector trackMomentum(pTrack->GetTrackStateAtCalorimeter().GetMomentum());
    const pandora::CartesianVector trackProjection(pTrack->GetTrackStateAtCalorimeter().GetPosition());
    const pandora::OrderedCaloHitList &orderedCaloHitList(pCluster->GetOrderedCaloHitList());
    unsigned int nDof(0);

    for(pandora::OrderedCaloHitList::const_iterator iter = orderedCaloHitList.begin(), endIter = orderedCaloHitList.end() ; endIter != iter ; ++iter)
    {
      if( ( iter->first - innerPseudoLayer ) > m_nFirstClusterPseudoLayer )
        break;

      for(pandora::CaloHitList::const_iterator hiter = iter->second->begin(), endhiter = iter->second->end() ; endhiter != hiter ; ++hiter)
      {
        const pandora::CaloHit *const pCaloHit(*hiter);

        const float openingAngle(trackMomentum.GetOpeningAngle(pCaloHit->GetPositionVector() - trackProjection));

        //if(openingAngle > m_maxTrackClusterAngle)
        if(openingAngle > MaxTrackClusterAngle)
          continue;

        ++nDof;
        innerCentroid += pCaloHit->GetPositionVector();
      }
    }

    //	std::cout << " ==> nDof = " << nDof <<  std::endl;

    if(0 == nDof)
      return pandora::STATUS_CODE_FAILURE;

    innerCentroid *= (1.f / nDof);

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  bool TrackClusterAssociationMVAAlgorithm::PassesInitialCuts(const pandora::Cluster *const pCluster, const pandora::Track *const pTrack) const
  {
    if( NULL == pCluster || NULL == pTrack)
      return false;

    const pandora::CartesianVector trackMomentum(pTrack->GetTrackStateAtCalorimeter().GetMomentum());
    const pandora::CartesianVector trackProjection(pTrack->GetTrackStateAtCalorimeter().GetPosition());

    pandora::CartesianVector innerCentroid(0.f, 0.f, 0.f);

	MaxTrackClusterAngle = 0.6;
    bool canComputeInnerCentroid0 = pandora::STATUS_CODE_SUCCESS == this->ComputeInnerCentroid(pCluster, pTrack, innerCentroid);
	bool canComputeInnerCentroid1 = true;

	if(canComputeInnerCentroid0==false)
	{
		MaxTrackClusterAngle = 1.e6;
        canComputeInnerCentroid1 = pandora::STATUS_CODE_SUCCESS == this->ComputeInnerCentroid(pCluster, pTrack, innerCentroid);
	}

#if 0
	bool trkCluMatched = shouldMatch(pTrack, pCluster);
	std::string tupleName0 = "TrackClusterAssociationMVA_COG" + string(__func__);
	std::string varListName0 = "canComputeInnerCentroid:shouldMatch";
	std::vector<float> vars0;
	vars0.push_back( float(canComputeInnerCentroid0) );
	vars0.push_back( float(trkCluMatched) );
	HistogramManager::CreateFill(tupleName0, varListName0, vars0);
#endif

    // get b field and track helix
    const float bField(PandoraContentApi::GetPlugins(*this)->GetBFieldPlugin()->GetBField(pandora::CartesianVector(0.f, 0.f, 0.f)));
    const pandora::Helix helix(trackProjection, trackMomentum, pTrack->GetCharge(), bField);

	float trkTanL = trackMomentum.GetZ() / sqrt(trackMomentum.GetX() * trackMomentum.GetX() + trackMomentum.GetY() * trackMomentum.GetY());

	//std::cout << "e: " << pTrack->GetCharge() << ", b: " << bField << std::endl;
	//std::cout << "TP: " << trackProjection.GetX() << ", " << trackProjection.GetY() << ", " << trackProjection.GetZ() << std::endl;
	//std::cout << "P: " << trackMomentum.GetX() << ", " << trackMomentum.GetY() << ", " << trackMomentum.GetZ() << std::endl;

    //	pandora::CartesianVector projectionOnHelix(0.f, 0.f, 0.f);
    //
    //	if(pandora::STATUS_CODE_SUCCESS != GeometryHelper::GetProjectionOnHelix(helix, innerCentroid, projectionOnHelix))
    //		return false;
	//std::cout << "innerCentroid: " << innerCentroid.GetX() << ", " << innerCentroid.GetY() << ", " << innerCentroid.GetZ() << std::endl;

    pandora::CartesianVector distanceToHelix(0.f, 0.f, 0.f);
    helix.GetDistanceToPoint(innerCentroid, distanceToHelix);

	std::string tupleNameMatched = "TrackClusterAssociationMVAM";
	std::string tupleNameUnmatched = "TrackClusterAssociationMVAU";
	std::string varListName = "trkR:trkZ:trkPhi:trkTanL:trkEnergy:cluR:cluZ:cluPhi:cluSize:cluEnergy:trkCluDistance:shouldMatch:canComputeInnerCentroid0:canComputeInnerCentroid1";
	std::vector<float> vars;

	float trkR, trkPhi, trkZ;
	trackProjection.GetCylindricalCoordinates(trkR, trkPhi, trkZ);

	float cluR, cluPhi, cluZ;
	innerCentroid.GetCylindricalCoordinates(cluR, cluPhi, cluZ);
	
	bool isMatched = shouldMatch(pTrack, pCluster);

	/////////////////////////////////////////////////////////////////
	vars.push_back(trkR);
	vars.push_back(trkZ);
	vars.push_back(trkPhi);
	vars.push_back(trkTanL);
	vars.push_back(pTrack->GetEnergyAtDca());

	vars.push_back(cluR);
	vars.push_back(cluZ);
	vars.push_back(cluPhi);
	vars.push_back(pCluster->GetNCaloHits());
    vars.push_back(pCluster->GetHadronicEnergy());
	
	vars.push_back(distanceToHelix.GetZ());
	vars.push_back( float(isMatched) );
	vars.push_back( float(canComputeInnerCentroid0) );
	vars.push_back( float(canComputeInnerCentroid1) );
	/////////////////////////////////////////////////////////////////

	// generate sigal and background for MVA trainning
	if(isMatched)
	{
		HistogramManager::CreateFill(tupleNameMatched, varListName, vars);
	}
	else
	{
		HistogramManager::CreateFill(tupleNameUnmatched, varListName, vars);
	}

	if(!canComputeInnerCentroid0) return false;

    if( distanceToHelix.GetZ() > m_maxDistanceToHelix )
	{
		//std::cout << "distanceToHelix.Z: " << distanceToHelix.GetZ() << ", m_maxDistanceToHelix: " << m_maxDistanceToHelix << std::endl;
		//std::cout << "pCluster: " << pCluster->GetElectromagneticEnergy() << " track: " << pTrack->GetEnergyAtDca() << " ComputeInnerCentroid failed" << std::endl;
      return false;
	}

    return true;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode TrackClusterAssociationMVAAlgorithm::CalculateAssociationConstraints(const pandora::Cluster *const pCluster, const pandora::Track *const pTrack, AssociationConstraints &constraints)
  {
    if( NULL == pCluster || NULL == pTrack)
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    const pandora::CartesianVector trackMomentum(pTrack->GetTrackStateAtCalorimeter().GetMomentum());
    const pandora::CartesianVector trackProjection(pTrack->GetTrackStateAtCalorimeter().GetPosition());

    pandora::CartesianVector innerCentroid(0.f, 0.f, 0.f);
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->ComputeInnerCentroid(pCluster, pTrack, innerCentroid));

    // get b field and track helix
    const float bField(PandoraContentApi::GetPlugins(*this)->GetBFieldPlugin()->GetBField(pandora::CartesianVector(0.f, 0.f, 0.f)));
    const pandora::Helix helix(trackProjection, trackMomentum, pTrack->GetCharge(), bField);

    pandora::CartesianVector distanceToHelix(0.f, 0.f, 0.f);
    helix.GetDistanceToPoint(innerCentroid, distanceToHelix);

    pandora::TrackList trackList;
    trackList.push_back(pTrack);

    const float openingAngle(trackMomentum.GetOpeningAngle(innerCentroid - trackProjection));
    const float chi = ReclusterHelper::GetTrackClusterCompatibility(this->GetPandora(), pCluster, trackList);

    const float energyCompatibility( m_useEnergyCompatibility ? chi*chi : 1.f );
    const float distanceCompatibility( distanceToHelix.GetZ() / m_maxDistanceToHelix );

    // compatibility as a distance to helix combined with energy information
    const float compatibility( energyCompatibility * distanceCompatibility );

    constraints.m_pCluster = pCluster;
    constraints.m_chi2 = chi*chi;
    constraints.m_trackClusterAngle = openingAngle;
    constraints.m_distanceToHelix = distanceToHelix.GetZ();
    constraints.m_compatibility = compatibility;

#if 0
	std::string tupleName = "TrackClusterAssociationMVA" + string(__func__);
	std::string varListName = "trackR:trackZ";

	std::vector<float> vars;
	//vars.push_back();

	//HistogramManager::CreateFill(tupleName, varListName, vars);
#endif

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  bool TrackClusterAssociationMVAAlgorithm::FitConstraints(const AssociationConstraints &constraints) const
  {
    if( constraints.m_distanceToHelix > m_maxDistanceToHelix )
      return false;

    if( constraints.m_trackClusterAngle > m_maxTrackClusterAngle )
      return false;

    return true;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  bool TrackClusterAssociationMVAAlgorithm::SortByBestCompatibility(const AssociationConstraints &lhs, const AssociationConstraints &rhs)
  {
    return lhs.m_compatibility > rhs.m_compatibility;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode TrackClusterAssociationMVAAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    m_maxClusterInnerPseudoLayer = 3;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxClusterInnerPseudoLayer", m_maxClusterInnerPseudoLayer));

    m_nFirstClusterPseudoLayer = 4;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "NFirstClusterPseudoLayer", m_nFirstClusterPseudoLayer));

    m_maxDistanceToHelix = 25.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxDistanceToHelix", m_maxDistanceToHelix));

    m_maxTrackClusterAngle = 0.6f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxTrackClusterAngle", m_maxTrackClusterAngle));

    m_allowMultiAssociations = true;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "AllowMultiAssociations", m_allowMultiAssociations));

    m_useEnergyCompatibility = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "UseEnergyCompatibility", m_useEnergyCompatibility));

	m_usePhotonClusters = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "UsePhotonClusters", m_usePhotonClusters));

    return pandora::STATUS_CODE_SUCCESS;
  }

} 

