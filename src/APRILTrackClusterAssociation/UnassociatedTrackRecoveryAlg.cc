/// \file UnassociatedTrackRecoveryAlg.cc
/*
 *
 * UnassociatedTrackRecoveryAlg.cc source template automatically generated by a class generator
 * Creation date : jeu. juil. 7 2016
 *
 * This file is part of APRILContent libraries.
 * 
 * APRILContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * APRILContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with APRILContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "APRILTrackClusterAssociation/UnassociatedTrackRecoveryAlg.h"

#include "Pandora/AlgorithmHeaders.h"
#include "APRILHelpers/ReclusterHelper.h"
#include "APRILHelpers/ClusterHelper.h"

namespace april_content
{

  pandora::StatusCode UnassociatedTrackRecoveryAlg::Run()
  {
    pandora::ClusterVector clusterVector; pandora::TrackVector trackVector;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->GetUnassociatedTracks(trackVector));
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->GetUnassociatedClusters(clusterVector));
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->PerformPossibleTrackClusterAssociations(clusterVector, trackVector));

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode UnassociatedTrackRecoveryAlg::GetUnassociatedClusters(pandora::ClusterVector &clusterVector) const
  {
    const pandora::ClusterList *pClusterList = NULL;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));

    for(pandora::ClusterList::const_iterator iter = pClusterList->begin(), endIter = pClusterList->end() ;
        endIter != iter ; ++iter)
    {
      const pandora::Cluster *const pCluster(*iter);

      if(!pCluster->GetAssociatedTrackList().empty())
        continue;

      if(pCluster->GetNCaloHits() == 0)
        continue;

      if(pCluster->GetInnerPseudoLayer() > m_maxClusterInnerPseudoLayer)
        continue;

      if(pCluster->PassPhotonId(this->GetPandora()))
        continue;

      clusterVector.push_back(pCluster);
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode UnassociatedTrackRecoveryAlg::GetUnassociatedTracks(pandora::TrackVector &trackVector) const
  {
    const pandora::TrackList *pTrackList = NULL;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pTrackList));

    const float bField(PandoraContentApi::GetPlugins(*this)->GetBFieldPlugin()->GetBField(pandora::CartesianVector(0.f, 0.f, 0.f)));

    for(pandora::TrackList::const_iterator iter = pTrackList->begin(), endIter = pTrackList->end() ;
        endIter != iter ; ++iter)
    {
      const pandora::Track *const pTrack(*iter);

      if(!pTrack->CanFormPfo())
        continue;

      if(!pTrack->ReachesCalorimeter())
        continue;

      if(!pTrack->GetDaughterList().empty())
        continue;

      const pandora::Helix helix(pTrack->GetTrackStateAtCalorimeter().GetPosition(),
          pTrack->GetTrackStateAtCalorimeter().GetMomentum(), pTrack->GetCharge(), bField);

      if(fabs(helix.GetOmega()) > m_maxOmegaTrack)
        continue;

      if(pTrack->HasAssociatedCluster())
        continue;

      if(pTrack->GetEnergyAtDca() < m_minEnergyAtDca)
        continue;

      if(pTrack->IsProjectedToEndCap())
      {
        const pandora::CartesianVector trackMomentum(pTrack->GetTrackStateAtCalorimeter().GetMomentum());
        const pandora::CartesianVector trackProjection(pTrack->GetTrackStateAtCalorimeter().GetPosition());
        const pandora::CartesianVector endcapNormale(0.f, 0.f, trackProjection.GetZ() > 0 ? 1.f : -1.f);
        const float trackEndcapAngle(trackMomentum.GetOpeningAngle(endcapNormale));

        if(trackEndcapAngle > m_maxEndCapProjectionAngle)
          continue;
      }

      trackVector.push_back(pTrack);
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode UnassociatedTrackRecoveryAlg::PerformPossibleTrackClusterAssociations(const pandora::ClusterVector &clusterVector, const pandora::TrackVector &trackVector) const
  {
	int nUnassociatedTrack(0);
    for(pandora::TrackVector::const_iterator trackIter = trackVector.begin(), trackEndIter = trackVector.end() ;
        trackEndIter != trackIter ; ++trackIter)
    {
      const pandora::Track *const pTrack(*trackIter);

      const float energyAtDca(pTrack->GetEnergyAtDca());

      const pandora::Cluster *pBestCluster(NULL);
      float bestTrackClusterDistance(std::numeric_limits<float>::max());
      float bestChi(std::numeric_limits<float>::max());

      for(pandora::ClusterVector::const_iterator clusterIter = clusterVector.begin(), clusterEndIter = clusterVector.end() ;
          clusterEndIter != clusterIter ; ++clusterIter)
      {
        const pandora::Cluster *const pCluster(*clusterIter);

        if(!pCluster->GetAssociatedTrackList().empty())
          continue;

        float trackClusterDistance(0.f);

        if(pandora::STATUS_CODE_SUCCESS != ClusterHelper::GetTrackClusterDistance(this->GetPandora(), pCluster, pTrack, m_maxTrackClusterDistance, trackClusterDistance))
          continue;

        const float clusterEnergy(pCluster->GetTrackComparisonEnergy(this->GetPandora()));
        const float chi(ReclusterHelper::GetTrackClusterCompatibility(this->GetPandora(), clusterEnergy, energyAtDca));

        if((chi*chi < bestChi*bestChi) && (trackClusterDistance < bestTrackClusterDistance || trackClusterDistance < m_trackClusterDistanceCut2))
        {
          bestTrackClusterDistance = trackClusterDistance;
          bestChi = chi;
          pBestCluster = pCluster;
        }
      }

      if((NULL == pBestCluster) || (fabs(bestChi) > m_maxAssociationChi) || (bestTrackClusterDistance > m_trackClusterDistanceCut))
        continue;

      PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::AddTrackClusterAssociation(*this, pTrack, pBestCluster));
	  ++nUnassociatedTrack;
	  //std::cout << "UnassociatedTrack " << nUnassociatedTrack << ", energy: " << energyAtDca << std::endl;
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode UnassociatedTrackRecoveryAlg::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    m_maxOmegaTrack = 0.002;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxOmegaTrack", m_maxOmegaTrack));

    m_minEnergyAtDca = 0.1;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinEnergyAtDca", m_minEnergyAtDca));

    m_maxEndCapProjectionAngle = M_PI/3.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxEndCapProjectionAngle", m_maxEndCapProjectionAngle));

    m_maxClusterInnerPseudoLayer = 9;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxClusterInnerPseudoLayer", m_maxClusterInnerPseudoLayer));

    m_maxTrackClusterDistance = 400.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxTrackClusterDistance", m_maxTrackClusterDistance));

    m_trackClusterDistanceCut = 100.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "TrackClusterDistanceCut", m_trackClusterDistanceCut));

    m_trackClusterDistanceCut2 = 70.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "TrackClusterDistanceCut2", m_trackClusterDistanceCut2));

    m_maxAssociationChi = 1.8f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxAssociationChi", m_maxAssociationChi));

    return pandora::STATUS_CODE_SUCCESS;
  }

} 

