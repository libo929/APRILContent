  /// \file SimplePfoTestAlgorithm.cc
/*
 *
 * SimplePfoTestAlgorithm.cc source template automatically generated by a class generator
 * Creation date : sam. mars 21 2015
 *
 * This file is part of APRILContent libraries.
 *
 * APRILContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * APRILContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with APRILContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author John Marshall
 */

#include "Pandora/AlgorithmHeaders.h"
#include "Api/PandoraContentApi.h"

#include "APRILCheating/SimplePfoTestAlgorithm.h"
#include "APRILHelpers/ClusterHelper.h"
#include "APRILHelpers/CaloHitHelper.h"
#include "APRILHelpers/ReclusterHelper.h"

#include "APRILHelpers/HistogramHelper.h"


namespace april_content
{

SimplePfoTestAlgorithm::SimplePfoTestAlgorithm()
{
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode SimplePfoTestAlgorithm::Run()
{
	PfoTargetEnergy();
	SimplePfo();

    return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

void SimplePfoTestAlgorithm::PfoTargetEnergy() const
{
    const pandora::MCParticleList *pMCParticleList = NULL;
    PandoraContentApi::GetCurrentList(*this, pMCParticleList);

	if(pMCParticleList != NULL)
	{
		float pfoTargetEnergy = 0.;
		float pfoTargets = 0.;

		for(auto iter = pMCParticleList->begin(); iter != pMCParticleList->end(); ++iter)
		{
			auto pMCParticle = *iter;
			pfoTargetEnergy += pMCParticle->GetEnergy();
			pfoTargets += 1;
		}

		std::vector<float> vars;
		vars.push_back( pfoTargetEnergy );
		vars.push_back( pfoTargets );

        HistogramManager::CreateFill("PfoTargetEnergy", "pfoTargetEnergy:pfoTargets", vars);
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------
 pandora::StatusCode SimplePfoTestAlgorithm::SimplePfo() const
{
    const pandora::MCParticleList *pPfoTargetList = NULL;
    PandoraContentApi::GetCurrentList(*this, pPfoTargetList);
	
	//
	pandora::MCParticleList mcpList;

	//////// track
    const pandora::TrackList *pTrackList = NULL;
    PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pTrackList));

	map<const pandora::MCParticle *const, pandora::TrackList> mcpTrackMap;

    for (pandora::TrackList::const_iterator iter = pTrackList->begin(), iterEnd = pTrackList->end(); iter != iterEnd; ++iter)
	{
        const pandora::Track *const pTrack = *iter;
		const pandora::MCParticle* pTrkMCParticle = NULL;

		try 
		{
			pTrkMCParticle = pandora::MCParticleHelper::GetMainMCParticle(pTrack);
		    if(!pTrkMCParticle->IsPfoTarget()) continue;
		}
        catch (pandora::StatusCodeException &e)
		{
			//continue;
            return pandora::STATUS_CODE_SUCCESS;
		}

        //const pandora::MCParticle *const pTrkPfoTarget(pTrkMCParticle->GetPfoTarget());
        const pandora::MCParticle *const pTrkPfoTarget( pTrkMCParticle );

		if( std::find(mcpList.begin(), mcpList.end(), pTrkPfoTarget) == mcpList.end() )
		{
			mcpList.push_back( pTrkPfoTarget );
		}

		if( mcpTrackMap.find( pTrkPfoTarget ) == mcpTrackMap.end() )
		{
			pandora::TrackList trkList;
			trkList.push_back(pTrack);
			mcpTrackMap[pTrkPfoTarget] = trkList;
		}
		else
		{
			mcpTrackMap[pTrkPfoTarget].push_back( pTrack );
		}
	}

	/////// cluster
    const pandora::ClusterList *pClusterList = NULL;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));

	map<const pandora::MCParticle *const, pandora::ClusterList> mcpClusterMap;

    for (pandora::ClusterList::const_iterator iter = pClusterList->begin(), iterEnd = pClusterList->end(); iter != iterEnd; ++iter)
    {
        const pandora::Cluster *const pCluster = *iter;
        const pandora::MCParticle *const pCluMCParticle(pandora::MCParticleHelper::GetMainMCParticle(pCluster));
		if(!pCluMCParticle->IsPfoTarget()) continue;

        //const pandora::MCParticle *const pCluPfoTarget(pCluMCParticle->GetPfoTarget());
        const pandora::MCParticle *const pCluPfoTarget(pCluMCParticle);

		if( std::find(mcpList.begin(), mcpList.end(), pCluPfoTarget) == mcpList.end() )
		{
			mcpList.push_back( pCluPfoTarget );
		}

		if( mcpClusterMap.find( pCluPfoTarget ) == mcpClusterMap.end() )
		{
			pandora::ClusterList cluList;
			cluList.push_back(pCluster);
			mcpClusterMap[pCluPfoTarget] = cluList;
		}
		else
		{
			mcpClusterMap[pCluPfoTarget].push_back( pCluster );
		}
	}

	if(!mcpList.empty())
	{
		float pfoTargetChargedWithoutClusterEnergy = 0.;
		float pfoTargetChargedEnergy = 0.;
		float pfoTargetNeutralEnergy = 0.;
		float pfoTargets = 0.;

		for(auto iter = mcpList.begin(); iter != mcpList.end(); ++iter)
		{
			auto pMCParticle = *iter;

#if 1
			pandora::TrackList& trackList = mcpTrackMap[pMCParticle];
			pandora::ClusterList& clusterList = mcpClusterMap[pMCParticle];

			// only track list has object
		    if(!trackList.empty() && clusterList.empty())
			{
				//pfoTargetChargedWithoutClusterEnergy += pMCParticle->GetEnergy();
#if 1
			    for(auto trackIter = trackList.begin(); trackIter != trackList.end(); ++trackIter)
			    {
					auto pTrk = *trackIter;

					if( (pTrk->CanFormPfo() || pTrk->CanFormClusterlessPfo()) && pTrk->GetParentList().empty() )
					{
						pfoTargetChargedEnergy += pTrk->GetEnergyAtDca();
					}
			    }
#endif
			}


			////////////////////////////////////////////////////
			//  both lists have object
			if( (!trackList.empty()) && (!clusterList.empty()) )
			{
				// MC energy
				// pfoTargetChargedEnergy += pMCParticle->GetEnergy();

				// track energy + cluster energy
#if 1
				std::cout << "both has object" << std::endl;

				pandora::ClusterList cluList;
			
			    for(auto trackIter = trackList.begin(); trackIter != trackList.end(); ++trackIter)
			    {
					auto pTrk = *trackIter;

					if( (pTrk->CanFormPfo() || pTrk->CanFormClusterlessPfo()) && pTrk->GetParentList().empty() )
					{
						pfoTargetChargedEnergy += pTrk->GetEnergyAtDca();

			            // check track cluster association
					    if(pTrk->HasAssociatedCluster())
					    {
				            const pandora::Cluster* pClu = pTrk->GetAssociatedCluster();

					    	if( std::find(cluList.begin(), cluList.end(), pClu) == cluList.end() )
					    	{
					    		cluList.push_back( pClu );
					    	}
					    }
					}
			    }

				// if cluster has no associated track, add its energy to pfo
#if 1
			    for(auto clusterIter = clusterList.begin(); clusterIter != clusterList.end(); ++clusterIter)
				{
					auto pClu = *clusterIter;

					if( std::find(cluList.begin(), cluList.end(), pClu) == cluList.end() )
					{
                        const pandora::MCParticle *const pCluMCParticle(pandora::MCParticleHelper::GetMainMCParticle(pClu));
                        const bool isPhoton(pandora::PHOTON == pCluMCParticle->GetParticleId());
                        float clusterEnergy(isPhoton ? pClu->GetCorrectedElectromagneticEnergy(this->GetPandora()) : pClu->GetCorrectedHadronicEnergy(this->GetPandora()));

					    std::cout << "Add cluster energy" << std::endl;
					    pfoTargetNeutralEnergy += clusterEnergy;
					}
				}
#endif

#endif
			}

			// only cluster list has object
			if(trackList.empty() && (!clusterList.empty()) )
			{
				//pfoTargetNeutralEnergy += pMCParticle->GetEnergy();

#if 1
				float mcpEnergy = pMCParticle->GetEnergy();
			    pandora::ClusterList& mcpClusterList = mcpClusterMap[pMCParticle];

				float mcpClusterEnergy = 0.;
				float mcpClusterSize = 0.;

				float falseHitSize = 0.;
				float falseHitEnergy = 0.;

			    for(auto clusterIter = mcpClusterList.begin(); clusterIter != mcpClusterList.end(); ++clusterIter)
				{
					auto pCluster = *clusterIter;

                    const pandora::MCParticle *const pCluMCParticle(pandora::MCParticleHelper::GetMainMCParticle(pCluster));
                    const bool isPhoton(pandora::PHOTON == pCluMCParticle->GetParticleId());
                    float clusterEnergy(isPhoton ? pCluster->GetCorrectedElectromagneticEnergy(this->GetPandora()) : pCluster->GetCorrectedHadronicEnergy(this->GetPandora()));

					pfoTargetNeutralEnergy += clusterEnergy;

					mcpClusterEnergy += clusterEnergy;
					mcpClusterSize += pCluster->GetNCaloHits() + pCluster->GetNIsolatedCaloHits();

					// loop cluster hit
					pandora::CaloHitList clusterCaloHitList;
					pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

					for( auto hit : clusterCaloHitList)
					{
                        const pandora::MCParticle *const mcParticle(pandora::MCParticleHelper::GetMainMCParticle(hit));

						if( mcParticle != pCluMCParticle )
						{
							++falseHitSize;
							if( isPhoton )
							{
								falseHitEnergy += hit->GetElectromagneticEnergy();
							}
							else
							{
								falseHitEnergy += hit->GetHadronicEnergy();
							}
						}
					}
				}

		        std::vector<float> vars;
		        vars.push_back( mcpEnergy );
		        vars.push_back( mcpClusterEnergy );
		        vars.push_back( mcpClusterSize );
		        vars.push_back( falseHitSize );
		        vars.push_back( falseHitEnergy );

                HistogramManager::CreateFill("neutralMCP", "mcpEnergy:mcpClusterEnergy:mcpClusterSize:falseHitSize:falseHitEnergy", vars);
#endif
			}


			// this seems alwags false 
#if 0
			if( trackList.empty() && clusterList.empty() )
			{
				//pfoTargetEnergy += pMCParticle->GetEnergy();
				std::cout << "both empty" << std::endl;
			}
#endif

#endif

			//pfoTargetEnergy += pMCParticle->GetEnergy();
			pfoTargets += 1;
		}

		//////////////////////////////// get the missing pfo energy
		float missingPfoEnergy = 0.;

		for(auto pfo : *pPfoTargetList)
		{
			if( std::find( mcpList.begin(), mcpList.end(), pfo ) == mcpList.end() )
			{
				missingPfoEnergy += pfo->GetEnergy();

				float pid = pfo->GetParticleId();
				float energy = pfo->GetEnergy();
				float innerR = pfo->GetInnerRadius();
				float outerR = pfo->GetOuterRadius();
				float innerZ = pfo->GetVertex().GetZ();
				float outerZ = pfo->GetEndpoint().GetZ();

		        std::vector<float> vars;
		        vars.push_back( pid );
		        vars.push_back( energy );
		        vars.push_back( innerR );
		        vars.push_back( outerR );
		        vars.push_back( innerZ );
		        vars.push_back( outerZ );

				HistogramManager::CreateFill("MissingPfo", "pid:energy:innerR:outerR:innerZ:outerZ", vars);
			}
		}

		//////////////////////////////// get the extra pfo energy
		float extraPfoEnergy = 0.;

		for(auto pfo : mcpList)
		{
			if( std::find( pPfoTargetList->begin(), pPfoTargetList->end(), pfo ) == pPfoTargetList->end() )
			{
				extraPfoEnergy += pfo->GetEnergy();
			}
		}
		
		////////////////////////////////
		std::vector<float> vars;
		vars.push_back( pfoTargetChargedWithoutClusterEnergy );
		vars.push_back( pfoTargetChargedEnergy );
		vars.push_back( pfoTargetNeutralEnergy );
		vars.push_back( missingPfoEnergy );
		vars.push_back( extraPfoEnergy );
		vars.push_back( pfoTargets );

		///////////////////////////////
        HistogramManager::CreateFill("SimplePfoEnergy", 
		"pfoTargetChargedWithoutClusterEnergy:pfoTargetChargedEnergy:pfoTargetNeutralEnergy:missingPfoEnergy:extraPfoEnergy:pfoTargets", vars);
	}

    return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode SimplePfoTestAlgorithm::ReadSettings(const pandora::TiXmlHandle /* xmlHandle */)
{
#if 0
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "OutputPfoListName", m_outputPfoListName));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ProcessAlgorithm(*this, xmlHandle,
        "ClusterAssociation", m_associationAlgorithmName));
#endif

    return pandora::STATUS_CODE_SUCCESS;
}

}
