/// \file ConnectorPlusTool.cc
/*
 *
 * ConnectorPlusTool.cc source template automatically generated by a class generator
 * Creation date : mar. dï¿½c. 8 2015
 *
 * This file is part of APRILContent libraries.
 * 
 * APRILContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * APRILContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with APRILContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "APRILTools/ConnectorPlusTool.h"

#include "Pandora/AlgorithmHeaders.h"

#include "APRILObjects/CaloHit.h"
#include "APRILObjects/Connector.h"
#include "APRILHelpers/CaloHitHelper.h"
#include "APRILHelpers/CaloHitRangeSearchHelper.h"

namespace april_content
{

  // this tool is applied after photon clusters are created
  pandora::StatusCode ConnectorPlusTool::Process(const pandora::Algorithm &algorithm, const pandora::CaloHitList *const /* pCaloHitList */)
  {
	//std::cout << " ConnectorPlusTool : pCaloHitList " << pCaloHitList << ", size: " << pCaloHitList->size() << std::endl;
	
	// TODO:: paramter: from
    // ordered calo hit list of ECAL
    pandora::OrderedCaloHitList& orderedEcalCaloHitList = *( CaloHitRangeSearchHelper::GetOrderedEcalCaloHitList() );
    pandora::OrderedCaloHitList& orderedCaloHitList = *( CaloHitRangeSearchHelper::GetOrderedCaloHitList() );

	// seed hits
	pandora::CaloHitVector seedHits;

	// the reverse iterator
	pandora::OrderedCaloHitList::const_reverse_iterator layerEndIter = orderedEcalCaloHitList.rbegin();
	
	// maximum ECAL layer
	const unsigned int maxLayer = layerEndIter->first;

	// going back in the layers
	// check m_maxBackLayer
	std::advance(layerEndIter, m_maxBackLayer);

	// search seed hits in ECAL
    for(pandora::OrderedCaloHitList::const_reverse_iterator layerIter = orderedEcalCaloHitList.rbegin();
			layerEndIter != layerIter ; ++layerIter)
    {
      for(pandora::CaloHitList::const_iterator iterI = layerIter->second->begin(), endIterI = layerIter->second->end() ;
          endIterI != iterI ; ++iterI)
      {
        const april_content::CaloHit *const pCaloHitI = dynamic_cast<const april_content::CaloHit *const>(*iterI);

        if(NULL == pCaloHitI)
          continue;

        // check for availability
        if(m_connectOnlyAvailable && !PandoraContentApi::IsAvailable<pandora::CaloHit>(algorithm, pCaloHitI))
          continue;

        if(!m_shouldUseIsolatedHits && pCaloHitI->IsIsolated())
          continue;

		// get hit with backward connector but without forward connector
        if( !APRILContentApi::GetConnectorList(pCaloHitI, BACKWARD_DIRECTION).empty() && 
			APRILContentApi::GetConnectorList(pCaloHitI, FORWARD_DIRECTION).empty() )
		{
			seedHits.push_back( pCaloHitI );
			//std::cout << "seed hit in ecal: " << pCaloHitI->GetPseudoLayer() << std::endl;
		}
	  }
	}

	/////////////////////////////////////////////////////////
	// from ECAL to HCAL
	//
	// FIXME:: bad name
	pandora::CaloHitVector seedHitsInHCAL;

	//
	for(int iHit = 0; iHit < seedHits.size(); ++iHit)
	{
		//std::cout << "seedHits.size: " << seedHits.size() << ", iHit: " << iHit << std::endl;
        const april_content::CaloHit *const pCaloHitI = dynamic_cast<const april_content::CaloHit *const>( seedHits.at(iHit) );

		//int pseudoLayerI = pCaloHitI->GetPseudoLayer();

		//std::cout << "hit: " << pCaloHitI << ", layer: " << pseudoLayerI << std::endl;

        //for(unsigned int pl = pseudoLayerI+1 ; pl <= pseudoLayerI + m_maxPseudoLayerConnection ; pl++)
        for(unsigned int pl = maxLayer+1 ; pl <= maxLayer + m_maxPseudoLayerConnection ; ++pl)
        {
          pandora::OrderedCaloHitList::const_iterator findIter = orderedCaloHitList.find(pl);

          if(orderedCaloHitList.end() == findIter) continue;

		  const pandora::CartesianVector &position(pCaloHitI->GetPositionVector());

          const float searchRange(300.);

          int layer = pl;
          pandora::CaloHitList hitsInRange;

          CaloHitRangeSearchHelper::SearchHitsInLayer(position, layer, searchRange, hitsInRange);

		  //std::cout << "hits in layer " << layer << ": " << hitsInRange.size() << std::endl;

          for(pandora::CaloHitList::const_iterator iterJ = hitsInRange.begin(), endIterJ = hitsInRange.end() ;
              endIterJ != iterJ ; ++iterJ)
          {
            const april_content::CaloHit *const pCaloHitJ = dynamic_cast<const april_content::CaloHit *const>(*iterJ);

            if(NULL == pCaloHitJ)
              continue;

            // check if already connected
            if(APRILContentApi::IsConnected(pCaloHitI, pCaloHitJ, FORWARD_DIRECTION))
              continue;

            // check for availability
            if(m_connectOnlyAvailable && !PandoraContentApi::IsAvailable<pandora::CaloHit>(algorithm, pCaloHitJ))
              continue;

            if(m_shouldDiscriminateConnectedHits && !APRILContentApi::GetConnectorList(pCaloHitJ, BACKWARD_DIRECTION).empty())
              continue;

            const pandora::CartesianVector &positionVectorI(pCaloHitI->GetPositionVector());
            const pandora::CartesianVector &positionVectorJ(pCaloHitJ->GetPositionVector());
            const pandora::HitType hitTypeJ(pCaloHitJ->GetHitType());
            const float difference = (positionVectorJ - positionVectorI).GetMagnitude();

            // FIXME
			if( difference > 120. ) continue;

            const float angle = (positionVectorJ - positionVectorI).GetOpeningAngle(positionVectorI);



            const float transverseDistance = std::sin( angle ) * difference;
            const pandora::Granularity &granularity(PandoraContentApi::GetGeometry(algorithm)->GetHitTypeGranularity(hitTypeJ));

            const float maxTransverseDistance = granularity <= pandora::FINE ?
                m_maxTransverseDistanceFine : m_maxTransverseDistanceCoarse;

            const float maxConnectionAngle = granularity <= pandora::FINE ?
                m_maxConnectionAngleFine : m_maxConnectionAngleCoarse;

            // check transverse distance
            if(transverseDistance > maxTransverseDistance)
              continue;

            // check angle
            if(angle > maxConnectionAngle)
              continue;

            // connect !
            PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, APRILContentApi::Connect(pCaloHitI, pCaloHitJ, FORWARD_DIRECTION));
		
			seedHitsInHCAL.push_back(pCaloHitJ);
          }
		}
	}
	

	std::cout << "Initial seedHitsInHCAL size: " << seedHitsInHCAL.size() << std::endl;
	// HCAL
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	for(int iHit = 0; iHit < seedHitsInHCAL.size(); ++iHit)
	{
		//std::cout << "seedHitsInHCAL size: " << seedHitsInHCAL.size() << ", iHit: " << iHit << std::endl;
        const april_content::CaloHit *const pCaloHitI = dynamic_cast<const april_content::CaloHit *const>( seedHitsInHCAL.at(iHit) );

		// maximum ECAL layer
		//const unsigned int maxLayer = orderedEcalCaloHitList.rbegin()->first;

		//std::cout << "maxLayer: " << maxLayer << std::endl;
		int pseudoLayerI = pCaloHitI->GetPseudoLayer();

		//std::cout << "hit: " << pCaloHitI << ", layer: " << pseudoLayerI << std::endl;

        for(unsigned int pl = pseudoLayerI+1 ; pl <= pseudoLayerI + m_maxPseudoLayerConnection ; pl++)
        //for(unsigned int pl = maxLayer+1 ; pl <= maxLayer + m_maxPseudoLayerConnection ; ++pl)
        {
          pandora::OrderedCaloHitList::const_iterator findIter = orderedCaloHitList.find(pl);

          if(orderedCaloHitList.end() == findIter) continue;

		  const pandora::CartesianVector &position(pCaloHitI->GetPositionVector());

          const float searchRange(m_hitSearchRange);

          int layer = pl;
          pandora::CaloHitList hitsInRange;

          CaloHitRangeSearchHelper::SearchHitsInLayer(position, layer, searchRange, hitsInRange);

		  //std::cout << " searching in HCAL: hits in layer " << layer << ": " << hitsInRange.size() << std::endl;

          for(pandora::CaloHitList::const_iterator iterJ = hitsInRange.begin(), endIterJ = hitsInRange.end() ;
              endIterJ != iterJ ; ++iterJ)
          {
            const april_content::CaloHit *const pCaloHitJ = dynamic_cast<const april_content::CaloHit *const>(*iterJ);

            if(NULL == pCaloHitJ)
              continue;

            // check if already connected
            if(APRILContentApi::IsConnected(pCaloHitI, pCaloHitJ, FORWARD_DIRECTION))
              continue;

            // check for availability
            if(m_connectOnlyAvailable && !PandoraContentApi::IsAvailable<pandora::CaloHit>(algorithm, pCaloHitJ))
              continue;

            if(m_shouldDiscriminateConnectedHits && !APRILContentApi::GetConnectorList(pCaloHitJ, BACKWARD_DIRECTION).empty())
              continue;

            const pandora::CartesianVector &positionVectorI(pCaloHitI->GetPositionVector());
            const pandora::CartesianVector &positionVectorJ(pCaloHitJ->GetPositionVector());
            const pandora::HitType hitTypeJ(pCaloHitJ->GetHitType());
            const float difference = (positionVectorJ - positionVectorI).GetMagnitude();

            // FIXME
			if( difference > 55. ) continue;

            const float angle = (positionVectorJ - positionVectorI).GetOpeningAngle(positionVectorI);

            const float transverseDistance = std::sin( angle ) * difference;
            const pandora::Granularity &granularity(PandoraContentApi::GetGeometry(algorithm)->GetHitTypeGranularity(hitTypeJ));

            const float maxTransverseDistance = granularity <= pandora::FINE ?
                m_maxTransverseDistanceFine : m_maxTransverseDistanceCoarse;

            const float maxConnectionAngle = granularity <= pandora::FINE ?
                m_maxConnectionAngleFine : m_maxConnectionAngleCoarse;

            // check transverse distance
            if(transverseDistance > maxTransverseDistance)
              continue;

            // check angle
            if(angle > maxConnectionAngle)
              continue;

            // connect !
            PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, APRILContentApi::Connect(pCaloHitI, pCaloHitJ, FORWARD_DIRECTION));
		
			seedHitsInHCAL.push_back(pCaloHitJ);

			//std::cout << "  ---> add a hit in seedHitsInHCAL: " << pCaloHitJ << std::endl;
          }
		}
	}

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ConnectorPlusTool::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
	m_maxBackLayer = 3;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxBackLayer", m_maxBackLayer));

	m_hitSearchRange = 200.;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "HitSearchRange", m_hitSearchRange));

    m_maxPseudoLayerConnection = 4;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxPseudoLayerConnection", m_maxPseudoLayerConnection));

    m_connectOnlyAvailable = true;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "ConnectOnlyAvailable", m_connectOnlyAvailable));

    m_maxConnectionAngleFine = 0.6;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxConnectionAngleFine", m_maxConnectionAngleFine));

    m_maxConnectionAngleCoarse = 0.9;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxConnectionAngleCoarse", m_maxConnectionAngleCoarse));

    m_maxTransverseDistanceFine = 20.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxTransverseDistanceFine", m_maxTransverseDistanceFine));

    m_maxTransverseDistanceCoarse = 65.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxTransverseDistanceCoarse", m_maxTransverseDistanceCoarse));

    m_shouldUseIsolatedHits = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "ShouldUseIsolatedHits", m_shouldUseIsolatedHits));

    m_shouldDiscriminateConnectedHits = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "ShouldDiscriminateConnectedHits", m_shouldDiscriminateConnectedHits));

    return pandora::STATUS_CODE_SUCCESS;
  }

} 

