/// \file MissingEnergyReclusteringAlgorithm.cc
/*
 *
 * MissingEnergyReclusteringAlgorithm.cc source template automatically generated by a class generator
 * Creation date : mer. fï¿½vr. 24 2016
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

//#define __DEBUG__

#include "ArborReclustering/MissingEnergyReclusteringAlgorithm.h"

#include "Pandora/AlgorithmHeaders.h"

#include "ArborApi/ArborContentApi.h"
#include "ArborHelpers/ReclusterHelper.h"
#include "ArborHelpers/ClusterHelper.h"
#include "ArborHelpers/SortingHelper.h"
#include "ArborHelpers/BDTBasedClusterIdHelper.h"
#include "ArborHelpers/TrackClusterPrintHelper.h"
#include "ArborHelpers/ClusterTrackEnergyFillingHelper.h"

std::string arbor_content::MissingEnergyReclusteringAlgorithm::m_clusterName = "";
std::string arbor_content::MissingEnergyReclusteringAlgorithm::m_photonClusterName = "";
std::string arbor_content::MissingEnergyReclusteringAlgorithm::m_originalClusterListName = "";
std::string arbor_content::MissingEnergyReclusteringAlgorithm::m_bestReclusterClusterListName = "";

arbor_content::MissingEnergyReclusteringAlgorithm::UIntVector 
arbor_content::MissingEnergyReclusteringAlgorithm::m_originalClusterIndices = UIntVector(1,0);

namespace arbor_content
{

  pandora::StatusCode MissingEnergyReclusteringAlgorithm::Run()
  {
	// FIXME
	m_clusterName = "PrimaryTrees";
	m_photonClusterName = "PhotonClusters";

	// FIXME
	// Do we really need this recalculating ? optional ?
    // start by recalculating track-cluster association
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::RunDaughterAlgorithm(*this, m_trackClusterAssociationAlgName));

	//////
	//std::cout << "Preparing clusters" << std::endl;

	// It seems that we can declare those varibles locally, not as members of this class? WHY ??? 
	pandora::ClusterVector clusterVector;
    pandora::ClusterList   photonList;
	
	PrepareClusters(clusterVector, photonList);

	//std::cout << "Recluster clusters" << std::endl;
	ReclusterCluster(clusterVector, photonList);

	/////////////// do we need to check the of each track ? the unassociated track ?
	//CheckClusters();

    return pandora::STATUS_CODE_SUCCESS;
  }

  pandora::StatusCode MissingEnergyReclusteringAlgorithm::CheckClusters()
  {
	// get run or event number
	//GetPandora().GetSettings();
	bool badEvent = false;
	
	// check from cluster side
	const pandora::ClusterList* clusterList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, clusterList));

	pandora::ClusterVector clusterVector;

	if(clusterList != NULL && !clusterList->empty())
	{
		clusterVector.insert(clusterVector.begin(), clusterList->begin(), clusterList->end());
	}

    for(unsigned int i=0 ; i<clusterVector.size() ; ++i)
    {
      const pandora::Cluster *const pCluster = clusterVector[i];

	  float trackEnergy = 0.;

	  if( NULL != pCluster && ShouldReclusterCluster(pCluster, trackEnergy))
	  {
		  std::cout << "-----------> Cluster should do reclustering: " << pCluster->GetHadronicEnergy() << std::endl;
		  ClusterTrackEnergyFillingHelper::FillEnergy(pCluster->GetHadronicEnergy(), trackEnergy);
		  if(fabs(pCluster->GetHadronicEnergy() - trackEnergy) > 2.)
		  {
			badEvent = true;
		  }
	  }
	}

	// check from track side
	const pandora::TrackList* trackList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, trackList));

	pandora::TrackVector trackVector;
	if(trackList != NULL && !trackList->empty())
	{
		trackVector.insert(trackVector.begin(), trackList->begin(), trackList->end());
	}

	std::cout << "track size: " << trackVector.size() << std::endl;

    for(unsigned int i=0 ; i<trackVector.size() ; ++i)
    {
      const pandora::Track* const pTrack = trackVector[i];
	  std::cout << "test track energy : " << pTrack->GetEnergyAtDca() << std::endl;

	  if(NULL != pTrack)
	  {
		  if(pTrack->HasAssociatedCluster()) 
		  {
			  const pandora::Cluster * cluster = pTrack->GetAssociatedCluster();
		      std::cout << "=============> track: " << pTrack->GetEnergyAtDca() << " ---- cluster: "
		      	        << cluster->GetHadronicEnergy() << std::endl;
		  }
		  else
		  {
			  std::cout << "Track has no cluster...." << std::endl;
			  ClusterTrackEnergyFillingHelper::FillEnergy(0, pTrack->GetEnergyAtDca());
			  if(pTrack->GetEnergyAtDca()>2.) 
			  {
				 badEvent = true;
			  }
		  }
	  }
	}

#if 1
	if(badEvent)
	{
       for(unsigned int i=0 ; i<clusterVector.size() ; ++i)
       {
         const pandora::Cluster *const pCluster = clusterVector[i];
		 PandoraContentApi::Delete<pandora::Cluster>(*this, pCluster);
	   }

	   // get photon cluster and delete ...
	   const std::string photonListName("PhotonClusters");
	   PandoraContentApi::ReplaceCurrentList<pandora::Cluster>(*this, photonListName);

	   const pandora::ClusterList* photonList = NULL;
	   PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, photonList));
	
	   pandora::ClusterVector photonVector;

	   if(photonList != NULL && !photonList->empty())
	   {
	   	  photonVector.insert(photonVector.begin(), photonList->begin(), photonList->end());
	   }

       for(unsigned int i=0 ; i<photonVector.size() ; ++i)
       {
		 std::cout << "delete photon vector..." << std::endl;
         const pandora::Cluster *const pCluster = photonVector[i];
		 PandoraContentApi::Delete<pandora::Cluster>(*this, pCluster);
	   }
	}
#endif

	return pandora::STATUS_CODE_SUCCESS;
  }

#if 1
  //////////////////////////////////////////////
  pandora::StatusCode MissingEnergyReclusteringAlgorithm::PrepareClusters(pandora::ClusterVector& clusterVector,
		                                                                  pandora::ClusterList&   photonList)
  {
    // get current cluster list
	const pandora::ClusterList* clusterList = NULL;
	clusterList = NULL;

	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, clusterList));
	
	if (pandora::STATUS_CODE_SUCCESS != PandoraContentApi::GetList(*this, m_clusterName, clusterList))
	{
#ifdef __DEBUG__
		std::cout << m_clusterName << " is not found." << std::endl;
#endif
	}
	else
	{
#ifdef __DEBUG__
		std::cout << m_clusterName << " is found." << std::endl;
#endif
	}

	// we include the photon clusters in reclustering, since there is a probability that hadronic
	// cluster is identified as photon cluster
    const pandora::ClusterList* m_pPhotonClusterList = NULL;

    if (pandora::STATUS_CODE_SUCCESS != PandoraContentApi::GetList(*this, m_photonClusterName, m_pPhotonClusterList)) 
	{
#ifdef __DEBUG__
		std::cout << m_photonClusterName << " is not found." << std::endl;
#endif
	} 
	else 
	{
#ifdef __DEBUG__
		std::cout << m_photonClusterName << " is found." << std::endl;
#endif
	}

#ifdef __DEBUG__ 
#if 0
	std::cout << "Print clusters: clusterList " << std::endl;
    if(clusterList != NULL) TrackClusterPrintHelper::PrintCluster(clusterList);
	std::cout << "Print clusters: m_pPhotonClusterList " << std::endl;
	if(m_pPhotonClusterList != NULL) TrackClusterPrintHelper::PrintCluster(m_pPhotonClusterList);
#endif
#endif

    if(clusterList != NULL && !clusterList->empty())
	{
		//std::cout << "insert cluster" << std::endl;
		clusterVector.insert(clusterVector.begin(), clusterList->begin(), clusterList->end());
    
		//std::cout << "done ..." << std::endl;

#ifdef __DEBUG__ 
		std::cout << "cluster size: " << clusterList->size() << ", clusterVector size: " << clusterVector.size() << std::endl;
#endif
	}

    if(m_pPhotonClusterList != NULL && !m_pPhotonClusterList->empty()) 
	{ 
		clusterVector.insert(clusterVector.end(), m_pPhotonClusterList->begin(), m_pPhotonClusterList->end());

#ifdef __DEBUG__ 
		std::cout << "photon cluster size: " << m_pPhotonClusterList->size() << ", clusterVector size: " 
			      << clusterVector.size() << std::endl;
#endif
	}

	//// sort 
    std::sort(clusterVector.begin(), clusterVector.end(), SortingHelper::SortByTrackClusterCompatibility(&this->GetPandora()));

#ifdef __DEBUG__
	//std::cout << "sort the clusters... " << std::endl;
	std::cout << "-----------------> the sorted cluster:" << std::endl;

    for(unsigned int i=0 ; i<clusterVector.size() ; ++i)
    {
      const pandora::Cluster *const pCluster = clusterVector[i];
	  std::cout << "---energy of cluster: " << pCluster->GetElectromagneticEnergy() << std::endl;


      const pandora::TrackList trackList(pCluster->GetAssociatedTrackList());
      for (pandora::TrackList::const_iterator trackIter = trackList.begin(), trackIterEnd = trackList.end(); trackIter != trackIterEnd; ++trackIter) 
	  {
		  std::cout << "  ->track energy: " << (*trackIter)->GetEnergyAtDca() << std::endl;
	  }
	}
#endif

	std::reverse(clusterVector.begin(), clusterVector.end());

	// m_photonList is the recorder of all clusters in the photon cluster list
	// maybe just using pPhotonClusterList is OK ...
	photonList.insert(m_pPhotonClusterList->begin(), m_pPhotonClusterList->end());

#ifdef __DEBUG__
	std::cout << "-----------------> the sorted cluster:" << std::endl;

    for(unsigned int i=0 ; i<clusterVector.size() ; ++i)
    {
      const pandora::Cluster *const pCluster = clusterVector[i];
	  std::cout << "---energy of cluster: " << pCluster->GetElectromagneticEnergy() << std::endl;


      const pandora::TrackList trackList(pCluster->GetAssociatedTrackList());
      for (pandora::TrackList::const_iterator trackIter = trackList.begin(), trackIterEnd = trackList.end(); trackIter != trackIterEnd; ++trackIter) 
	  {
		  std::cout << "  ->track energy: " << (*trackIter)->GetEnergyAtDca() << std::endl;
	  }
	}
#endif


	// move all clusters in the photon cluster list into the cluster list
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_INITIALIZED, !=, 
	       		                  PandoraContentApi::SaveList(*this, m_photonClusterName, m_clusterName, photonList));

	return pandora::STATUS_CODE_SUCCESS;
  }
#endif

#if 1
  pandora::StatusCode MissingEnergyReclusteringAlgorithm::ReclusterCluster(pandora::ClusterVector& clusterVector,
		                                                                   pandora::ClusterList&   photonList)
  {
	/////////////// check each cluster
    for(unsigned int i=0 ; i<clusterVector.size() ; ++i)
    {
      const pandora::Cluster *const pCluster = clusterVector[i];

	  float trackEnergy;

	  if( NULL == pCluster || !ShouldReclusterCluster(pCluster, trackEnergy) ) continue;
	  //std::cout << "deal with cluster: " << pCluster->GetElectromagneticEnergy() << std::endl;

      // the clusters and tracks for reclustering
      pandora::ClusterList reclusterClusterList;
      reclusterClusterList.insert(pCluster);
      pandora::TrackList reclusterTrackList(pCluster->GetAssociatedTrackList());

	  // FIXME: maybe should set the vector as this
      // UIntVector originalClusterIndices(1, i);  // one int with value i
	  m_originalClusterIndices.clear();
	  m_originalClusterIndices.push_back(i);

	  /////
	  if(SearchNearbyClusters(clusterVector, pCluster, reclusterClusterList) == pandora::STATUS_CODE_FAILURE) continue;

	  /////
	  ExecuteReclustering(pCluster, reclusterClusterList);

	  /////
	  ReAssociateTrackCluster();

	  /////
	  TidyClusters(clusterVector, photonList);

  	  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::EndReclustering(*this, m_bestReclusterClusterListName));
    }

	// put photon clusters back from clusters
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_INITIALIZED, !=, 
	        		                PandoraContentApi::SaveList(*this, m_clusterName, m_photonClusterName, photonList));


#if 0
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));
	std::cout << "******* print cluster..." << std::endl;
	TrackClusterPrintHelper::PrintCluster(pClusterList);
#endif

	return pandora::STATUS_CODE_SUCCESS;
  }

  bool MissingEnergyReclusteringAlgorithm::ShouldReclusterCluster(const pandora::Cluster *const pCluster, float& trackEnergy)
  {
      const pandora::TrackList trackList(pCluster->GetAssociatedTrackList());
      unsigned int nTrackAssociations(trackList.size());

      if((nTrackAssociations < m_minTrackAssociations) || (nTrackAssociations > m_maxTrackAssociations)) return false;

      float trackEnergySum(0.);

      for (pandora::TrackList::const_iterator trackIter = trackList.begin(), trackIterEnd = trackList.end(); 
	      trackIter != trackIterEnd; ++trackIter)
	  {
        trackEnergySum += (*trackIter)->GetEnergyAtDca();
	  }

	  trackEnergy = trackEnergySum;

      if(trackEnergySum < m_minTrackMomentum) return false;

      const float chi(ReclusterHelper::GetTrackClusterCompatibility(this->GetPandora(), pCluster, trackList));
	  m_bestChi = chi;
	  

#ifdef __DEBUG__
	  std::cout << "chi: " << chi << ", minChi2: " << m_minChi2ToRunReclustering << ", trackEnergySum: " << trackEnergySum 
		        << ", cluster energy: " << pCluster->GetElectromagneticEnergy() << std::endl;
#endif

      // check for chi2 and missing energy in charged cluster
      if(chi*chi < m_minChi2ToRunReclustering || chi > 0.f) return false;

      // check for clusters that leave the detector
      if(ClusterHelper::IsClusterLeavingDetector(this->GetPandora(), pCluster)) return false;

	  return true;
  }

  pandora::StatusCode MissingEnergyReclusteringAlgorithm::SearchNearbyClusters( pandora::ClusterVector& clusterVector, 
		   const pandora::Cluster *const pCluster, pandora::ClusterList& reclusterClusterList)
  {
      reclusterClusterList.insert(pCluster);

      pandora::ClusterFitResult parentFitResult;
      pandora::CartesianVector parentCentroid(0.f, 0.f, 0.f);
      pandora::ClusterFitHelper::FitFullCluster(pCluster, parentFitResult);

	  pandora::CartesianVector clusterInitialDirection = pCluster->GetInitialDirection();
      const pandora::StatusCode centroidStatusCode(ClusterHelper::GetCentroid(pCluster, parentCentroid));

      //------------->>>>>> find nearby clusters to potentially merge-in
      for(unsigned int j=0 ; j<clusterVector.size() ; ++j)
      {
        const pandora::Cluster *const pOtherCluster = clusterVector[j];
        if((NULL == pOtherCluster) || (pCluster == pOtherCluster)) continue;

		//std::cout << "test cluster energy : " << pOtherCluster->GetElectromagneticEnergy() << std::endl;

#if 1
		float bdtVal(1000.);
		BDTBasedClusterIdHelper::BDTEvaluate(pOtherCluster, bdtVal);
		//std::cout << "BDT: " << bdtVal << std::endl;

		// if it is photon cluster which is identified by BDT
		//FIXME: cut for BDT
		if(bdtVal>0.3) continue;
#endif

		// only neutral cluster ???
        if( !pOtherCluster->GetAssociatedTrackList().empty() ) continue;

        float clusterHitsDistance = std::numeric_limits<float>::max();
        PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::GetClosestDistanceApproach(pOtherCluster, pCluster, clusterHitsDistance));

		//std::cout << "cluster dist: " << clusterHitsDistance << ", m_maxClusterHitsDistance: " << m_maxClusterHitsDistance << std::endl;

        if(clusterHitsDistance < m_maxClusterHitsDistance)
        {
          reclusterClusterList.insert(pOtherCluster);
          m_originalClusterIndices.push_back(j);
        }
        else
        {
			//FIXME
          if(clusterHitsDistance > 1000.) continue;

          if(pandora::STATUS_CODE_SUCCESS != centroidStatusCode || !parentFitResult.IsFitSuccessful()) continue;

          pandora::CartesianVector daughterCentroid(0.f, 0.f, 0.f);
          if(pandora::STATUS_CODE_SUCCESS != ClusterHelper::GetCentroid(pOtherCluster, daughterCentroid)) continue;

		  const float angle2( clusterInitialDirection.GetOpeningAngle( daughterCentroid - parentCentroid ) );
          if( angle2 > m_maxNeighborClusterAngle ) continue;

          reclusterClusterList.insert(pOtherCluster);
          m_originalClusterIndices.push_back(j);
        }
      }

	  //std::cout << "the nearby clusters: " << std::endl;
	  //TrackClusterPrintHelper::PrintCluster(&reclusterClusterList);

      if(1 == reclusterClusterList.size()) 
	  { 
		  return pandora::STATUS_CODE_FAILURE;
	  }
	  else
	  {
		  return pandora::STATUS_CODE_SUCCESS;
	  }
  }

  pandora::StatusCode MissingEnergyReclusteringAlgorithm::ExecuteReclustering(const pandora::Cluster *const pCluster, 
		  pandora::ClusterList& reclusterClusterList)
  {
	  //------------>>>>>> do reclustering 
      pandora::TrackList reclusterTrackList(pCluster->GetAssociatedTrackList());

      // initialize reclustering
      PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::InitializeReclustering(*this,
      reclusterTrackList, reclusterClusterList, m_originalClusterListName));

      m_bestReclusterClusterListName = m_originalClusterListName;

      for(pandora::StringVector::const_iterator clusteringAlgIter = m_clusteringAlgorithmList.begin(), 
	  endClusteringAlgIter = m_clusteringAlgorithmList.end() ; endClusteringAlgIter != clusteringAlgIter ; ++clusteringAlgIter)
      {
		/////
        const pandora::ClusterList *pReclusterClusterList = NULL;
        std::string reclusterClusterListName;
        PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::RunReclusteringAlgorithm(*this,
            *clusteringAlgIter, pReclusterClusterList, reclusterClusterListName));

        if(pReclusterClusterList->empty()) continue;

		/////
        PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::RunDaughterAlgorithm(*this, m_associationAlgorithmName));

        PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::PostRunReclusteringAlgorithm(*this, reclusterClusterListName));

        // run monitoring algorithm if provided
        if(!m_monitoringAlgorithmName.empty())
        {
          PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::RunDaughterAlgorithm(*this,
              m_monitoringAlgorithmName));
        }
      
		// FIXME::
		if(IsBestReclustering(reclusterClusterListName)) m_bestReclusterClusterListName = reclusterClusterListName;

      }// for each algorithm


	return pandora::STATUS_CODE_SUCCESS;
  }

  bool MissingEnergyReclusteringAlgorithm::IsBestReclustering(const std::string reclusterClusterListName)
  {
        const pandora::ClusterList *pReclusterClusterList = NULL;
        PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetList(*this, reclusterClusterListName, pReclusterClusterList));

		bool isBestReclustering = false;

		//std::cout << "pReclusterClusterList size: " << pReclusterClusterList->size() << std::endl;

        for(pandora::ClusterList::const_iterator clusterIter = pReclusterClusterList->begin(), clusterEndIter = pReclusterClusterList->end() ;
            clusterEndIter != clusterIter ; ++ clusterIter)
        {
          const pandora::Cluster *const pReclusterCluster = *clusterIter;

          if( pReclusterCluster->GetAssociatedTrackList().empty() ) continue;

          //if( pReclusterCluster->GetAssociatedTrackList().size() != trackList.size() ) continue;

          pandora::ClusterList reclusterList;
          reclusterList.insert(pReclusterCluster);

          ReclusterResult reclusterResult;
          if(pandora::STATUS_CODE_SUCCESS != ReclusterHelper::ExtractReclusterResults(this->GetPandora(), *pReclusterClusterList, reclusterResult))
            continue;

          const float newChi(reclusterResult.GetChi());
          const float newChi2(reclusterResult.GetChi2());

		  //std::cout << "reclustering algorithm: " << ", the new chi: " << newChi 
		//	        << ", m_bestChi: " << m_bestChi << std::endl;  

          if(newChi2 < m_bestChi*m_bestChi)
          {
            m_bestChi = newChi;
			isBestReclustering = true;
			//std::cout << "a best clustering: " << std::endl;
			
            if(newChi2 < m_maxChi2ToStopReclustering)
              break;
          }

		  // FIXME
          //break;
        }
		//------->>>> record the best reclustering

		// FIXME
		return isBestReclustering;
  }

  pandora::StatusCode MissingEnergyReclusteringAlgorithm::ReAssociateTrackCluster()
  {
      //-------------> Recreate track-cluster associations for chosen recluster candidates
      PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::TemporarilyReplaceCurrentList<pandora::Cluster>(*this, m_bestReclusterClusterListName));
	  /////// >>>>>> ??????????? is this correct ??????????
      PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::RunDaughterAlgorithm(*this, m_trackClusterAssociationAlgName));

    return pandora::STATUS_CODE_SUCCESS;
  }

#if 1
  pandora::StatusCode MissingEnergyReclusteringAlgorithm::TidyClusters(pandora::ClusterVector& clusterVector,
		                                                               pandora::ClusterList&   photonList)
  {
      // ------>>>>> tidy the cluster vector used for reclustering
      if( m_originalClusterListName != m_bestReclusterClusterListName )
      {
        // remove clusters used in reclustering from the list
        for(UIntVector::const_iterator iter = m_originalClusterIndices.begin(), endIter = m_originalClusterIndices.end() ;
            endIter != iter ; ++iter)
		{
		  // if a photon cluster, also remove it in the photon cluster
		  pandora::ClusterList::const_iterator cluIter = photonList.find(clusterVector[*iter]);
		  if(cluIter != photonList.end())
		  {
			  photonList.erase(cluIter);
		  }

          clusterVector[*iter] = NULL;
		}

        // add the newly created clusters to the list
        const pandora::ClusterList *pReclusterClusterList = NULL;
        PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetList(*this, m_bestReclusterClusterListName, pReclusterClusterList));

        for(pandora::ClusterList::const_iterator clusterIter = pReclusterClusterList->begin(), clusterEndIter = pReclusterClusterList->end() ;
            clusterEndIter != clusterIter ; ++ clusterIter)
        {
          const pandora::Cluster *const pReclusterCluster = *clusterIter;

		  // Bo: we want to add all created clusters to the list ...
          //if(pReclusterCluster->GetAssociatedTrackList().empty()) continue;

          clusterVector.push_back(pReclusterCluster);
        }
      }

    return pandora::STATUS_CODE_SUCCESS;
  }


#endif

#endif


  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode MissingEnergyReclusteringAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    m_minTrackAssociations = 1;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinTrackAssociations", m_minTrackAssociations));

    m_maxTrackAssociations = 1;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxTrackAssociations", m_maxTrackAssociations));

    m_minChi2ToRunReclustering = 1.8f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinChi2ToRunReclustering", m_minChi2ToRunReclustering));

    m_maxChi2ToStopReclustering = 0.5f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxChi2ToStopReclustering", m_maxChi2ToStopReclustering));

    m_maxClusterHitsDistance = 70.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxClusterHitsDistance", m_maxClusterHitsDistance));

    m_maxNeighborClusterAngle = 0.5f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxNeighborClusterAngle", m_maxNeighborClusterAngle));

    m_minTrackMomentum = 0.8f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MinTrackMomentum", m_minTrackMomentum));

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ProcessAlgorithmList(*this, xmlHandle,
        "clusteringAlgorithms", m_clusteringAlgorithmList));

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ProcessAlgorithm(*this, xmlHandle,
       "ClusterAssociation", m_associationAlgorithmName));

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ProcessAlgorithm(*this, xmlHandle,
        "TrackClusterAssociation", m_trackClusterAssociationAlgName));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ProcessAlgorithm(*this, xmlHandle,
        "Monitoring", m_monitoringAlgorithmName));

    return pandora::STATUS_CODE_SUCCESS;
  }


} 
