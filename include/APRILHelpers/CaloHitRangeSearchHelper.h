  /// \file CaloHitRangeSearchHelper.h
/*
 *
 * CaloHitRangeSearchHelper.h header template automatically generated by a class generator
 * Creation date : lun. mars 30 2015
 *
 * This file is part of APRILContent libraries.
 * 
 * APRILContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * APRILContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with APRILContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef CALOHITRANGESEARCHHELPER_H
#define CALOHITRANGESEARCHHELPER_H

#include "Pandora/PandoraInternal.h"
#include "Pandora/StatusCodes.h"

#include "APRILObjects/CaloHit.h"
#include "APRILObjects/Connector.h"
#include "APRILHelpers/CaloMetric.h"

#include <mlpack/core.hpp>
#include <mlpack/core/math/range.hpp>
#include <mlpack/methods/range_search/range_search.hpp>

namespace pandora { class Algorithm; class CaloHit; class Track; }

namespace april_content
{
typedef mlpack::range::RangeSearch<CaloMetric, arma::mat, mlpack::tree::MeanSplitBallTree> CaloRangeSearch;

/** 
 * @brief CaloHitRangeSearchHelper class
 */ 
class CaloHitRangeSearchHelper 
{
public:
	// build 
    static pandora::StatusCode FillMatixByPoints(const std::vector<pandora::CartesianVector>& points, arma::mat& caloHitsMatrix);

    static pandora::StatusCode BuildRangeSearch(const pandora::CaloHitList *const pCaloHitList, bool reBuild = false);
	
    static pandora::StatusCode BuildHitCollectionOfLayers(const pandora::CaloHitList *const pCaloHitList);

    static pandora::StatusCode BuildHitCollectionOfEcalLayers(const pandora::CaloHitList *const pEcalCaloHitList);

    static pandora::StatusCode BuildHitCollectionOfHcalLayers(const pandora::CaloHitList *const pHcalCaloHitList);
  
	static pandora::StatusCode BuildHitCollectionOfMuonLayers(const pandora::CaloHitList *const pMuonCaloHitList);

    static pandora::StatusCode BuildCaloRangeSearch(const pandora::CaloHitVector& caloHitVector);

    // search 

    static pandora::StatusCode SearchNeighbourHitsInRange(pandora::CartesianVector testPosition, float distance, pandora::CaloHitList& hitsInRange);

    static pandora::StatusCode SearchHitsInLayer(pandora::CartesianVector testPosition, int pseudoLayer,
		  float distance, pandora::CaloHitList& hitsInRange);
  
	static pandora::StatusCode SearchEcalHitsInLayer(pandora::CartesianVector testPosition, int pseudoLayer,
		  float distance, pandora::CaloHitList& hitsInRange);

	static pandora::StatusCode SearchHcalHitsInLayer(pandora::CartesianVector testPosition, int pseudoLayer,
		  float distance, pandora::CaloHitList& hitsInRange);

	static pandora::StatusCode SearchMuonHitsInLayer(pandora::CartesianVector testPosition, int pseudoLayer,
		  float distance, pandora::CaloHitList& hitsInRange);

    static pandora::StatusCode SearchHitsInRange4D(const pandora::CaloHitVector& caloHitVector, const std::vector<float>& testPosition, 
			float distance, pandora::CaloHitList& hitsInRange);

	static pandora::OrderedCaloHitList* GetOrderedCaloHitList()     { return &m_orderedCaloHitList;     }
	static pandora::OrderedCaloHitList* GetOrderedEcalCaloHitList() { return &m_orderedEcalCaloHitList; }
	static pandora::OrderedCaloHitList* GetOrderedHcalCaloHitList() { return &m_orderedHcalCaloHitList; }
	static pandora::OrderedCaloHitList* GetOrderedMuonCaloHitList() { return &m_orderedMuonCaloHitList; }

	///////

	static double m_fFillingTime;
	static double m_fGetttingTime;

	static pandora::OrderedCaloHitList m_orderedCaloHitList;
	static pandora::OrderedCaloHitList m_orderedEcalCaloHitList;
	static pandora::OrderedCaloHitList m_orderedHcalCaloHitList;
	static pandora::OrderedCaloHitList m_orderedMuonCaloHitList;

private:
	static arma::mat m_caloHitsMatrix;

    static pandora::StatusCode FillMatixFromCaloHits(const pandora::CaloHitVector& caloHitVector, arma::mat& caloHitsMatrix);
    static pandora::StatusCode FillMatix4DFromCaloHits(const pandora::CaloHitVector& caloHitVector, arma::mat& caloHitsMatrix4D);

	// all hits
	static const pandora::CaloHitList* m_pCaloHitList;

	// all hits on each layer
	static const pandora::CaloHitList* m_pCaloHitListOfLayers;

	// all ecal hits on each layer
	static const pandora::CaloHitList* m_pEcalCaloHitListOfLayers;

	// all hcal hits on each layer
	static const pandora::CaloHitList* m_pHcalCaloHitListOfLayers;

	// all muon hits on each layer
	static const pandora::CaloHitList* m_pMuonCaloHitListOfLayers;

	//-----------------
	static pandora::CaloHitVector m_caloHitVector;

	static std::vector<pandora::CaloHitVector> m_caloHitVectorOfLayers;
	static std::vector<pandora::CaloHitVector> m_ecalCaloHitVectorOfLayers;
	static std::vector<pandora::CaloHitVector> m_hcalCaloHitVectorOfLayers;
	static std::vector<pandora::CaloHitVector> m_muonCaloHitVectorOfLayers;

	static mlpack::range::RangeSearch<> m_rangeSearch;
	static CaloRangeSearch m_caloRangeSearch;

	static std::vector< mlpack::range::RangeSearch<> > m_rangeSearchOfLayers;
	static std::vector< mlpack::range::RangeSearch<> > m_ecalRangeSearchOfLayers;
	static std::vector< mlpack::range::RangeSearch<> > m_hcalRangeSearchOfLayers;
	static std::vector< mlpack::range::RangeSearch<> > m_muonRangeSearchOfLayers;

	//----------------
    static pandora::StatusCode BuildOrderedHitsAndSearchRange(const pandora::CaloHitList *const pCaloHitList,
		  pandora::OrderedCaloHitList& orderedCaloHitList, std::vector<pandora::CaloHitVector>& caloHitVectorOfLayers,
		  std::vector< mlpack::range::RangeSearch<> >& rangeSearchOfLayers);

    static pandora::StatusCode BuildHitCollectionForSearching(
		  const pandora::CaloHitList *const               pCaloHitList,
		  const pandora::CaloHitList*&                    pCaloHitListOfLayers,
		  pandora::OrderedCaloHitList&                    orderedCaloHitList, 
		  std::vector<pandora::CaloHitVector>&            caloHitVectorOfLayers, 
		  std::vector< mlpack::range::RangeSearch<> >&    rangeSearchOfLayers);

    static pandora::StatusCode SearchHitsInRange(mlpack::range::RangeSearch<>& rangeSearch, pandora::CaloHitVector& caloHitVector, 
		  pandora::CartesianVector testPosition, float distance, pandora::CaloHitList& hitsInRange);
};

} 

#endif  
