  /// \file TrackClusterAssociationMVAAlgorithm.h
/*
 *
 * TrackClusterAssociationMVAAlgorithm.h header template automatically generated by a class generator
 * Creation date : jeu. avr. 9 2015
 *
 * This file is part of APRILContent libraries.
 * 
 * APRILContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * APRILContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with APRILContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef TRACKCLUSTERASSOCIATIONMVAALGORITHM_H
#define TRACKCLUSTERASSOCIATIONMVAALGORITHM_H

#include "Pandora/Algorithm.h"

#include "TMVA/Reader.h"
#include "TMVA/MethodCuts.h"

namespace april_content
{

/** 
 * @brief TrackClusterAssociationMVAAlgorithm class
 */ 
class TrackClusterAssociationMVAAlgorithm : public pandora::Algorithm
{
 public:
	/**
	 *  @brief  Factory class for instantiating algorithm
	 */
	class Factory : public pandora::AlgorithmFactory
	{
	public:
		pandora::Algorithm *CreateAlgorithm() const;
	};

private:
	pandora::StatusCode Run();
	pandora::StatusCode ReadSettings(const pandora::TiXmlHandle xmlHandle);

	/**
	 *  @brief  AssociationConstraints struct
	 */
	struct AssociationConstraints
	{
		const pandora::Cluster *m_pCluster;
		float                   m_chi2;
		float                   m_trackClusterAngle;
		float                   m_distanceToHelix;
		float                   m_compatibility;
	};

	typedef std::vector<AssociationConstraints> AssociationConstraintsVector;
	typedef std::map<const pandora::Track*, AssociationConstraintsVector> AssociationConstraintsMap;
	typedef std::map<const pandora::Track*, const pandora::Cluster*> AssociationMap;
	typedef std::map<const pandora::Cluster*, const pandora::Track*> MultiAssociationMap;

	/**
	 *  @brief  Extract the cluster and track lists eligible for track-cluster associations
	 *
	 *  @param  clusterList the cluster list to receive
	 *  @param  trackList the track list to receive
	 */
	pandora::StatusCode ExtractAssociationLists(pandora::ClusterList &clusterList, pandora::TrackList &trackList);

	/**
	 *  @brief  Build the possible track-cluster associations
	 *
	 *  @param  clusterList the input cluster list
	 *  @param  trackList the input track list
	 *  @param  associationMap the association map to receive
	 */
	pandora::StatusCode BuildPossibleAssociations(const pandora::ClusterList &clusterList, const pandora::TrackList &trackList,
			AssociationMap &associationMap);

	/**
	 *  @brief  Perform the track-cluster association
	 *
	 *  @param  associationMap the input association map
	 */
	pandora::StatusCode PerformAssociations(const AssociationMap &associationMap);

	/**
	 *
	 */
	pandora::StatusCode ComputeInnerCentroid(const pandora::Cluster *const pCluster, const pandora::Track *const pTrack, pandora::CartesianVector &innerCentroid) const;

	/**
	 *  @brief  Whether the track-cluster pair passes simple cuts for a possible association
	 *
	 *  @param  pCluster the input cluster
	 *  @param  pTrack the input track
	 */
	bool PassesInitialCuts(const pandora::Cluster *const pCluster, const pandora::Track *const pTrack) const;

	float MVADeteriminAssociation(const pandora::Cluster* const pCluster, const pandora::Track* const pTrack) const;

	/**
	 *  @brief  Calculate the track-cluster association constraints for a possible association
	 *
	 *  @param  pCluster the input cluster
	 *  @param  pTrack the input track
	 *  @param  constraints the track-cluster association constraints
	 */
	pandora::StatusCode CalculateAssociationConstraints(const pandora::Cluster *const pCluster, const pandora::Track *const pTrack, AssociationConstraints &constraints);

	/**
	 *  @brief  Whether the set of constraints passes the final cuts for an association
	 *
	 *  @param  constraints the constraints to check
	 */
	bool FitConstraints(const AssociationConstraints &constraints) const;

	/**
	 *  @brief  Sort association constraints by compatibility (std::sort)
	 */
	static bool SortByBestCompatibility(const AssociationConstraints &lhs, const AssociationConstraints &rhs);

private:
	unsigned int                   m_maxClusterInnerPseudoLayer;   ///< The maximum cluster inner pseudo layer cut
	unsigned int                   m_nFirstClusterPseudoLayer;     ///< The number of cluster pseudo layers for the inner centroid evaluation

	float                          m_maxDistanceToHelix;           ///< The maximum distance between a track helix and the cluster inner centroid
	float                          m_maxTrackClusterAngle;         ///< The maximum angle between the track projection and the cluster inner centroid

	bool                           m_allowMultiAssociations;       ///< Whether to allow multi track associations for a single cluster
	bool                           m_useEnergyCompatibility;       ///< Whether to use energy information for association

	bool                           m_usePhotonClusters;

	static TMVA::Reader*           m_reader;
};

//------------------------------------------------------------------------------------------------------------------------------------------

inline pandora::Algorithm *TrackClusterAssociationMVAAlgorithm::Factory::CreateAlgorithm() const
{
    return new TrackClusterAssociationMVAAlgorithm();
}

} 

#endif  //  TRACKCLUSTERASSOCIATIONMVAALGORITHM_H
