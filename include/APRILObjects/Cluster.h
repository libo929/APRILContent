/*
 *
 * Cluster.h header template automatically generated by a class generator
 * Creation date : lun. mars 30 2015
 *
 * This file is part of APRILContent libraries.
 * 
 * APRILContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * APRILContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with APRILContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef APRILCLUSTER_H
#define APRILCLUSTER_H

#include "Objects/Cluster.h"

#include "Api/PandoraApi.h"
#include "Api/PandoraContentApi.h"


#include "Pandora/PandoraInputTypes.h"
#include "APRILApi/APRILInputTypes.h"

#include "APRILApi/APRILContentApi.h"

//#include "APRILObjects/APRILMetaData.h"

namespace april_content
{

class ClusterFactory;

class ClustersOrderParameter
{
public:
	ClustersOrderParameter()
	: m_orderParameter(std::numeric_limits<float>::max())
	{
	}

	ClustersOrderParameter(std::vector<float> parameters, std::vector<float> powers) 
	: m_parameters(parameters), m_powers(powers)
	{
		if(m_parameters.size() != m_powers.size())
		{
			std::cout << "parameters and powers length are not consistent!" << std::endl;
            throw pandora::StatusCodeException(pandora::STATUS_CODE_FAILURE);
		}

		m_orderParameter = 1.;

		for(int i = 0; i < m_parameters.size(); ++i)
		{
			m_orderParameter *= std::pow(m_parameters.at(i), m_powers.at(i));
		}
	}

	bool operator<(const ClustersOrderParameter& a) const
	{
		return m_orderParameter < a.m_orderParameter;
	}

	std::vector<float>        m_parameters;        
	std::vector<float>        m_powers;        

	float                     m_orderParameter;
};

/** 
 *  @brief  Cluster class
 */ 
class APRILCluster : public pandora::Cluster
{
public:
	float GetMergedHadronicEnergy();

	std::vector<APRILCluster*>& GetMotherCluster();

    void  Reset();
	void  ResetRelationShip();
    void  ClearMotherCluster();
	const std::set<APRILCluster*>& GetClustersToMerge() const;
	void  ClearClustersToMerge();
    void  GetAllClustersToMerge(std::set<APRILCluster*>& allClustersToMerge) const;
	const std::vector<APRILCluster*>& GetNearbyClusters() const;
	const APRILCluster* GetMotherAtSearch() const;

	const pandora::CartesianVector& GetAxis() const;
	const pandora::CartesianVector& GetIntercept() const;
	const pandora::CartesianVector& GetCentroid() const;
	const pandora::CartesianVector& GetStartingPoint() const;
	const pandora::CartesianVector& GetEndpoint() const;

	const pandora::OrderedCaloHitList& GetMainOrderedClusterHits() const;
	const pandora::CaloHitList& GetMainClusterHits() const;

    bool IsRoot();
    bool HasMotherAtSearch();
    bool IsDaughter(APRILCluster* cluster);
	bool IsPhoton();
	bool IsFragment();

    void SetHasMotherAtSearch(bool hasMotherAtSearch = true);
	void SetMotherAtSearch(APRILCluster* cluster);
	void ResetMotherAtSearch();
	void SetMotherCluster(APRILCluster* cluster);
	void SetClustersToMerge(const std::vector<APRILCluster*>& clusterVector);
	void RemoveFromClustersToMerge(APRILCluster* cluster);
	void SetNearbyClusters(const std::vector<APRILCluster*>& clusterVector);

	void SetAxis(pandora::CartesianVector axis);
	void SetIntercept(pandora::CartesianVector intercept);
	void SetCentroid(pandora::CartesianVector centrod);
	void SetStartingPoint(pandora::CartesianVector startingPoint);
	void SetEndpoint(pandora::CartesianVector endpoint);

	void SetMainOrderedClusterHits(pandora::OrderedCaloHitList mainOrderedClusterHits);
	void SetMainClusterHits(pandora::CaloHitList mainClusterHits);

	void SetOrderParameterWithMother(APRILCluster* motherCluster, ClustersOrderParameter& clustersOrderParameter);

    ClustersOrderParameter GetOrderParameterWithMother(APRILCluster* motherCluster);

	void SetPhoton(bool isPhoton);
	void SetRoot();
	void SetFragment();

private:

    //
	APRILCluster(const PandoraContentApi::Cluster::Parameters &parameters);

	~APRILCluster();


protected:
	std::vector<APRILCluster*> m_motherCluster;

	std::set<APRILCluster*> m_clustersToMerge;
	std::vector<APRILCluster*> m_nearbyClusters;

	pandora::CartesianVector m_axis;
	pandora::CartesianVector m_intercept;
	pandora::CartesianVector m_centroid;
	pandora::CartesianVector m_startingPoint;
	pandora::CartesianVector m_endpoint;

	bool m_isPhoton;
	bool m_isRoot;
	bool m_hasMotherAtSearch;
	bool m_isFragment;

	APRILCluster*              m_motherAtSearch;
  
	std::map<APRILCluster*, ClustersOrderParameter> m_orderWithMotherClusters;

	pandora::OrderedCaloHitList m_mainOrderedClusterHits;
	pandora::CaloHitList m_mainClusterHits;

    friend class ClusterFactory;
};

} 

#endif 
